<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 概述](#1-概述)
- [2. 设备直接分配](#2-设备直接分配)
- [3. 设备 I/O 地址空间的访问](#3-设备-io-地址空间的访问)
  - [3.1. 直接分配时客户 I/O 操作访问 I/O 地址空间的两种方法](#31-直接分配时客户-io-操作访问-io-地址空间的两种方法)
  - [3.2. Port I/O 转换表](#32-port-io-转换表)
  - [3.3. MMIO 转换表](#33-mmio-转换表)
  - [3.4. 修改设备 PCI BAR](#34-修改设备-pci-bar)
- [4. 设备发现](#4-设备发现)
- [5. 配置 DMA 重映射数据结构](#5-配置-dma-重映射数据结构)
- [6. 设备中断虚拟化](#6-设备中断虚拟化)
- [7. 案例分析: 网卡的直接分配在 Xen 中的实现](#7-案例分析-网卡的直接分配在-xen-中的实现)
- [8. 进阶](#8-进阶)

<!-- /code_chunk_output -->

# 1. 概述

将 VT-d 技术运用到 VMM 的 I/O 虚拟化中

在"**设备模拟**"和"**类虚拟化**"**两种 I/O 虚拟化技术**中, **所有客户机**都**共享平台硬件设备**. 考虑一种情况, 当**VMM**运行在一台有**10 块网卡**的服务器上, 前两种技术完全可能**只使用一块网卡！！！** 来满足**所有客户机的网络 I/O 需求！！！**, 这必然导致**低性能！！！** 和**资源的浪费！！！**.

第 2 章提到, **I/O 只有三个方面内容！！！**.

1) **驱动程序！！！**通过**I/O 地址空间(PIO 或 MMIO)操作设备！！！**, 即 **设备直接分配技术！！！** 解决的问题.

2) **设备！！！** 通过 **DMA 读取/复制数据！！！**, 已经由 **VT-d 的 DMA 重映射技术！！！** 解决.

3) **中断**, 5.4 已经介绍过

**设备直接分配**技术很好解决. 可以把**某个设备直接分配给一个客户机**, 让**客户机的 I/O 访问直接访问到设备的 I/O 地址空间！！！**, 从宏观看, 这个客户机直接操作了平台的硬件设备.

# 2. 设备直接分配

设备直接分配的一个问题是**如何阻止**来自**未分配到该设备的客户机的 I/O 访问！！！**.

例如, 系统中有三个客户机(0、1、2), 其中客户机 1 分配到网卡 A, 则要阻止客户机 0、2 对网卡 A 的访问, 一个最直接的方法是**隐藏**, 让客户机 0 和客户机 2 认为网卡 A 根本就不存在. 实际上, 无论是"设备模拟"还是"类虚拟化"技术, 平台的硬件对于客户机都是透明的, 所谓隐藏主要是针对运行"设备模拟器"的客户机/宿主机, 或拥有"类虚拟化"后端驱动的客户机/宿主机而言的. 隐藏的方式视具体的情况而定, 例如可以在拥有硬件设备的客户机/宿主机加载驱动程序前, 先给要分配出去的设备加载一个**伪驱动作为占位符**. 由于没有真正的驱动程序, 该设备就不会被访问到.

# 3. 设备 I/O 地址空间的访问

设备直接分配的**另一个问题**是如何让**客户机的 I/O 操作直接访问到设备真实的 I/O 地址空间**

## 3.1. 直接分配时客户 I/O 操作访问 I/O 地址空间的两种方法

第 2 章说过, **PCI 设备**的**I/O 地址空间**通过**PCI BAR(Base Address Register)报告给 OS！！！**. 通过 PCI BAR 的最后一位标识 I/O 端口还是 MMIO.

为此, 有**两种选择**供**设备直接分配技术**使用.

1) 将**设备的真实 PCI BAR 报告给客户机**, 并通过**VMCS 的 I/O bitmap**和**EPT**使**客户机的端口 I/O**和**MMIO**都**不引起 VM-Exit！！！**, 则**客户机 OS**的**驱动**可以**直接访问设备的 I/O 地址空间**

2) 建立**转换表**, 报告**虚拟的 PCI BAR 给客户机**, 当客户机访问到**虚拟的 I/O 地址空间**时, VMM 负责**截获**操作, 并通过**转换表将 I/O 请求转发到设备的 I/O 地址空间**.

两种方法中,  **方法1) **是高效的(不引起 VM-Exit)和简单的(**直接报告真实的 PCI BAR 给客户机**), 实际运用会**存在一些问题**. 通常, **VMM**产品会使用**多种 I/O 虚拟化技术**, **客户机**的**I/O 请求**, 可能一部分由"**设备模拟**"技术满足, 一部分由**设备直接分配技术**满足. 例如, **一个客户机**, 它的**显卡**是由"**设备模拟器**"模拟的, 但**网卡**又是操作的**真实设备**. 在 2.6 提到, **设备的 PCI BAR**通常是**BIOS 配置**并由**OS 直接使用**. 在上述情况中,

- 由"**设备模拟器！！！**"提供的**设备的 PCI BAR！！！**由**虚拟 BIOS 配置！！！**,
- 而**真实设备！！！**的**PCI BAR**由 **平台的 BIOS！！！** 配置,

两者之间就**可能冲突！！！**. 这种情况下, 在操作系统看来就是**资源冲突**, 很可能**停用其中一个设备**.

另外, **OS！！！**有权利**修改设备的 PCI BAR**, 但应该**阻止客户机！！！直接修改真实设备的 PCI BAR**, 这是为**防止真实设备之间的 PCI BAR 冲突！！！**, 以及在客户机销毁时把设备分配给其它客户机使用.

所以, 在实现**设备直接分配技术**中, 通常采用**方法⓶！！！**, 即**建立转换表**. 根据**I/O 地址空间**的划分, 转换表分为**Port I/O 转换表！！！**和**MMIO 转换表！！！**.

## 3.2. Port I/O 转换表

对于**Port I/O**, 在**VMCS**时提过, 可通过 **I/O bitmap！！！** 来控制 **客户机访问某个端口是否引起 VM-Exit！！！**.

这样, 完全可以使用"**设备模拟器**"的**虚拟 BIOS！！！**(或**其他手段！！！**, 取决于 VMM 使用的**I/O 虚拟技术**)为分配给客户机的**真实设备**生成**虚拟的 PCI BAR(存放 MMIO 或 PIO 的地址！！!**), 将它报告**给客户 OS**, 并**修改 I/O bitmap！！！**使**客户机**在访问这些**I/O 端口**时产生**VM-Exit**.

同时, **VMM**维护了一张**虚拟 PCI BAR 到真实 PCI BAR 的映射表！！！**. 当**客户机**通过**虚拟的 PCI BAR**发起**I/O 操作**时, 会**因为 VM-Exit！！！陷入到 VMM**中, **VMM**即可通过**转换表**获得**真实设备的 I/O 端口**, 帮客户及将请求**转发到真实硬件**.

## 3.3. MMIO 转换表

对于**MMIO**, 其**访问方式和内存访问一样**. 完全可以使用**内存虚拟化技术**来解决这个问题.

在**虚拟 BIOS**产生**虚拟 PCI BAR**之后, 只需将**虚拟的 MMIO 地址空间**映射到设备**真实的 MMIO 地址空间**上, 当**客户机**通过**虚拟的 MMIO 地址空间访问设备**时, 内存虚拟化机制处理一切.

举例, 如果**当前 VMM 使用 EPT**, 则客户机在**第一次访问虚拟 MMIO 地址空间**时会**陷入到 VMM**. 此时, 可修改 EPT 页表建立起**虚拟 MMIO 地址空间**到设备**真实 MMIO 地址空间**的映射, 则在以后访问中, **客户机**对**该虚拟 MMIO 地址空间的访问**就**不会陷入到 VMM**.

## 3.4. 修改设备 PCI BAR

除了解决**客户机直接访问设备 I/O 地址空间**问题, **转换表**还可以满足**客户机修改设备 PCI BAR！！！**的情况. 此时, 只需要修改虚拟的 PCI BAR 并维护修改后的值到真实 PCI BAR 的映射即可. 如何截获**修改 PCI BAR**的操作. 请参照 2.6 提到的两个 I/O 端口 0xCF8\~0xCFF. 只需要**截获**客户机对**这个两个端口的操作**即可.

# 4. 设备发现

前面解决客户机如何访问真实设备问题, 如何让**客户机 OS 发现真正的设备**?

VMM 通常会使用**多种 I/O 虚拟化技术！！！**, 其中一项**必然！！！**会**虚拟 PCI 总线**(一般, 这是"**设备模拟器**"的工作), 所以**只需**将**真实设备**"挂接"到这条**虚拟的 PCI 总线**上, **客户 OS 枚举 PCI 设备**时**必然会发现分配它**. 第 2 张关于 PCI 设备介绍可知, **PCI 设备暴露给 OS 的接口**是**PCI 配置空间**, 一个自然想法就是将**真实设备的 PCI 配置空间暴露给客户 OS**. 前面提到, **PCI 配置空间的 PCI BAR**通常是**虚拟 BIOS 生成**的. 那么更进一步, 可以**为设备生成整个虚拟的 PCI 配置空间！！！**.

为让**客户 OS 正确识别**分配给它的设备, 这个**虚拟的 PCI 配置空间**中, 表示**设备标识**的**前 16 个字节**(见 2.6)需要使用**真实的信息！！！**, 这是没关系的. 这些信息**不会被客户 OS 修改！！！**, 也**不会冲突！！！**. 将**生成的 PCI 配置空间**以一个**虚拟设备的形式**挂接在**虚拟 PCI 总线**上, 当**客户 OS 枚举总线时**即可发现该设备并加载正确地驱动程序.

# 5. 配置 DMA 重映射数据结构

VT-d 对 DMA 重映射进行地址转换. 对于**VMM 的实现者**, 使用该技术**关键**在于

- **为所分配的设备正确设置根条目和上下文条目**,
- **建立 I/O 页表**. **每个客户机**有**一张 I/O 页表**, 通常在**客户机创建初期**根据**客户机内存大小**、**VT-d 硬件支持的页表级数**、**页大小**创建.

假设**Guest ID 为 1**, **I/O 页表！！！**已经**创建好位于地址 A！！！**, **根条目表**和**上下文条目表**已经在**VMM 加载初期创建好！！！**, 要分配设备的 BDF 是{00:03:00}.

1) 找到**设备**对应的**DHRD 结构**. 一个 DHRD 结构对应一个 DMA 重映射硬件. 里面的**Register Base Address**指向该 DMA 重映射硬件寄存器的基地址

2) 获得该结构的**根条目表**, 通过**BDF 的 bus 字段**获得该设备对应**根条目项**(以下称 Root Entry0)

疑问: 怎么获得 root entry table 的???

3) 通过**Root Entry0**的**CTP 字段**获得**上下文条目表**, 用**BDF**的**dev:func**字段**索引该表**, 获得**设备对应的上下文条目**. 如果该上下文条目 **不存在！！！**, **分配一个**并**将地址写入 Root Entry0 的 CTP 字段**.

4) 将**I/O 页表的地址 A**填入**上下文条目**的**ASR 字段**, 在**DID 字段**写入**Guest ID 1**, 在 p 字段写入 1.

5) **刷新上下文条目的缓存**.

上面只介绍了主要字段的配置, 其余字段也要根据格式正确配置. 在刷新操作后, 该设备的 DMA 请求就会被 DMA 重映射硬件截获并进行地址转换.

# 6. 设备中断虚拟化

DMA **最后一步**往往是**设备**用**中断报告驱动程序操作**完成. 在**设备直接分配给客户机**, 以及**DMA 重映射到客户机内存**情况下, 设备的中断也需要注入给客户机. 5.4 已经介绍过.

# 7. 案例分析: 网卡的直接分配在 Xen 中的实现

以 Xen3.2 为例, 其它 VMM 原理类似

首先, VMM 需要知道要**直接分配的设备的标识**, 这里通常使用**PCI 设备的 BDF 号**标识设备. 设备标识由用户指定. 假设网卡的 BDF 是 03:00.1

下一步, **隐藏设备**. 方法很多, Xen 方法是在 GRUB 启动选项中指定设备的 BDF, 然后在启动过程中不去使用这些设备. 网卡为例, 用户可增加 Domain 0 的启动选项 pciback.hide=(03:00.0), 这样, Domain 就不会为网卡(03:00.0)加载驱动, 该网卡在系统启动之后就处在未使用状态.

设备被隐藏后可**直接分配给虚拟机**. 同样, 用户在客户机配置文件中指定该设备的 BDF 号. Xen 里面, 用户可以在 HVM 的配置文件中增加 `pci=['03:00.0']`.

Xen 获得直接分配请求后, 首先将设备呈献给客户机, 通过在**设备模型**中**虚拟一个 PCI 网卡**来实现. 客户机 OS 对该虚拟 PCI 网卡的操作请求都会被转交给物理网卡, 物理网卡处理完后的结果通过该虚拟 PCI 网卡返回给客户机 OS.

Xen 负责虚拟 PCI 网卡和物理网卡之间的交互. 具体来说, Xen 主要需要做:

首先, 由于**虚拟 PCI 网卡的 BDF**和**物理网卡的 BDF** 不一定相同, 因此 Xen 负责**两者转换**.

其次, **虚拟 PCI 网卡的 I/O 空间**(MMIO 和 Port I/O)和**物理网卡**不一定相同, 因此 Xen 为两者**建立映射**.

再次, 虚拟网卡的中断和物理网卡也是一样的, 因此 Xen 负责进行**中断的转发**.

最后, Xen 需要为物理网卡设置**VT-d 页表**, 确保客户机操作系统发出 DMA 请求时, 硬件能正确处理 DMA 地址.

# 8. 进阶

客户机被销毁, 它所拥有的真实硬件应该能够被重新利用, 分配给其它客户机使用, 这要求设备能够进行再分配.

只需要重新为设备生成新的 PCI 配置空间, 建立映射, 并挂接到新客户机的虚拟 PCI 总线上, 并修改设备对应的上下文条目, 就可以将设备分配给新的客户机使用了.