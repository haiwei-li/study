
为了支持 vLPI 的直接注入, 再分发器增加了两个额外的寄存器:

- **GICR_VPROPBASER**: 该寄存器设置虚拟 LPI 配置表的地址. 与物理 LPI 配置表一样, 虚拟 LPI 配置表记录 vLPI 的配置. vLPI 的配置对同一 VM 中的所有 vPE 都是全局的. ARM 预计, VM 中的所有 vPE 将使用相同的虚拟配置表副本.

- **GICR_VPENDBASER**: 该寄存器设置虚拟 LPI 挂起表 (VPT) 的地址. 与物理 LPI 挂起表一样, VPT 记录 vLPI 的挂起状态. 每个 vPE 都有自己的私有 VPT.

#### 9.1.1 调度的虚拟 PE

单个物理 PE 可能托管多个 vPE, 管理程序在它们之间进行上下文切换. 当前正在运行的 vPE 被称为已调度. 当 GICR_VPENDBASER 设置为指向其 VPT 时, vPE 被定义为已调度.

已调度 vPE 的虚拟中断可以直接注入. 如果目标 vPE 未被调度, 则虚拟中断将记录在相应的 VPT 中, 标记为挂起.

在 vPE 之间进行上下文切换时, 管理程序必须更新再分发器寄存器, 具体操作如下:

- **清除 GICR_VPENDBASER.Valid**: 清除 Valid 位通知再分发器正在进行上下文切换. 再分发器将从虚拟 CPU 接口检索任何挂起的虚拟中断, 并确保内存中的 VPT 正确.

- **轮询 GICR_VPENDBASER.Dirty, 直到其值为 0**:Dirty 位表示再分发器已完成对 VPT 的更新. 在该位为 0 之前, 不能调度新的 vPE.

- **更新 GICR_VPROPBASER**: 如果在同一 VM 的不同 vPE 之间切换, 此操作可能不是必需的.

- **更新 GICR_VPENDBASER, 并将 Valid 设置为 1**: 将 Valid 位设置为 1 通知再分发器新的 vPE 现在有效, 并且可以将该 vPE 的虚拟中断转发到虚拟 CPU 接口.

VPT 的前 1KB 由实现定义. ARM 预计, 实现将使用此空间记录信息, 以便在上下文切换时更快地解析 VPT. 当调度 vPE 时, 必须通知再分发器此区域是否包含有效数据. 软件使用 GICR_VPENDBASER.IDAI 指示该空间是否有效:

- **GICR_VPENDBASER.IDAI == 1(无效)**: 保留区域无效, 再分发器必须解析整个 VPT. 在以下情况下必须设置 IDAI 位:

  - vPE 被移动到连接到不同 GIC 实现的再分发器.

  - vPE 自 VPT 分配以来首次被调度, 并且在分配时整个表未被清零.

- **GICR_VPENDBASER.IDAI == 0(有效)**: 保留区域有效, 再分发器可以依赖存储在那里的值. ARM 预计这是最常见的情况. 在以下情况下可以清除 IDAI 位:

  - vPE 在其上一次调度的同一再分发器上调度.

  - vPE 在连接到相同 GIC 的不同再分发器上调度.

  - vPE 自 VPT 分配以来首次被调度, 并且在分配时整个 VPT 被清零(这意味着没有挂起的中断).

    - 注: 限制条件是在分配时 VPT 全为零, 而不是首次调度时全为零. 如果存在针对 vPE 的 ITS 映射, 则在创建和首次驻留之间可能会设置虚拟中断为挂起状态.
