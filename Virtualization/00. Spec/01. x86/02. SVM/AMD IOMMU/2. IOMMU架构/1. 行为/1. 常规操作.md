通过IOMMU的典型**请求流**如下: 
* IOMMU不会翻译**IOMMU生成**的**读取**, **写入**和**中断事务**. 
* 从**上游**到达的事务必须**保持不变**地**传递到下游**. 
* 从**下游到达的事物**, 包括响应、防护或刷新命令必须不更改地传递到上游. 
* 下游到达IOMMU排除范围内的引用地址的事务必须不更改地传递到上游. 
* 来自下游的**内存读取**和**写入**事务会导致在**设备表**(Device Table)中进行表查找, 以获取发出请求的I/O设备的**DomainID**并**查找I/O页表**.  I/O页表中需要**进一步的表查找**, 以执行**地址转换**和**权限检查**. 在执行权限检查和地址转换之后, 如果I/O设备允许交易, 则IOMMU将结果交易向上游转发. 
* 来自下游的**地址转换请求**会在表查找中进行内存读取和写入事务. 转换后的地址和访问许可信息将返回到发出请求的外围设备. 需要**软件**来使**外围设备缓存**的**地址转换映射无效**. 
* 来自下游的外围页请求将导致**事件日志条目**(如果不支持), 或者导致外围页请求日志条目被写入系统内存.  (可选的PPR自动响应可修改此行为. )
* **中断地址**永远**不会**转换为**系统内存地址**, 但是可以为消息信令中断(MSI)保留的物理地址范围可以视作转换的内存地址(例如ACPI地址范围, PCI配置空间映射). 
* **上游中断**(从下游来的给上游发的中断??)导致在**设备表**中查找表, 然后在**中断重新映射表**中查找表以**重新映射中断**. 在执行检查和中断重新映射之后, 如果I/O设备允许中断, 则IOMMU将产生的中断**转发到上游**.  SMI请求可以选择通过SMI筛选器, 并且不使用中断重新映射表. 
* 来自下游设备的Port I/O空间事务会导致**设备表**查找, 以确定是否允许I / O设备访问端口I / O空间. 
* IOMMU在系统内存中维护一个**事件日志**, 其中包含未正常完成的事务的详细信息. 
* IOMMU维护一个可选的**guest虚拟APIC日志**, 其中包含guest未运行时到达的中断请求的详细信息. 
* 如果I / O设备被标记为能够生成预转换的地址, 则IOMMU不会进一步转换来自设备的预转换的内存读取和写入请求. 
* IOMMU处理**命令队列**中的命令. 

可选的MARC功能允许从集成I / O设备(例如GPU)进行访问, 从而在访问系统内存的定义区域时绕过IOMMU. 

除了从下游设备传递事务之外, IOMMU还插入自己的事务以执行对系统内存的读写操作, 并发出中断信号. 

允许IOMMU缓存页表和设备表内容, 以加快转换速度. 定义了无效协议, 以便软件在更新表时可以使缓存内容与内存保持一致. 当软件启动不保留处理器或芯片组状态的挂起操作时, 存储在寄存器中的IOMMU的状态将丢失, 必须作为恢复序列的一部分进行恢复. 

当系统软件处理PCI热插拔通知时, 应检查ACPI表以确定将为外围设备提供服务的IOMMU, 然后对IOMMU进行适当的编程. 