
可以将本书源码编译为 64 位版本.

多数模块, 只需要维护一份代码, 即并不需要分别编写 64 位版本以及 32 位版本的代码. 极少部分才区分

# 使用符号__X64

为了做到 64 位和 32 位版本**只维护一份代码**, 需要将代码以**32 位形式**进行编译. 同时, 引进__X64 符号控制机器码的生成.

```assembly
bits 32             ;;重要, 以 32 位形式进行编译
        ... ...
%ifdef __X64
        ;;
        ;; 此处插入 64 位特定的代码!
        ;;
%else
        ;;
        ;; 此处插入 32 位特定的代码!
        ;;
%endif
        ... ...
```

注意: 由于在`64-bit`模式下, **绝大多数指令**的**操作位**默认为**32 位**, 导致多数指令机器码在 64 位和 32 位环境下是一样的! 只有**少量的指令**, 我们需要进行特别处理. 因此, 引进`__X64`是为了解决某些特定指令的使用.

代码统一在**32 位下编译**后, 处理器无论运行在`64-bit`模式下, 还是 32 位保护模式下, 都能正确执行. 当然, 除了某些需要特殊处理器的指令, 下面了解一下.

# 指令操作数

64 位和 32 位混合编译之前, 有必要先了解下 x86/64 体系中**指令**的`operand size`(**操作数宽度**), 以及`address size`(**地址宽度**)相关知识. 更详细介绍看 http://www.mouseos.com/x64/index.html .

**指令**的**操作数大小**及**地址大小**有**default**(默认)和**effective**(有效)两种情况.

表 1\-1 列出处理器各种工作模式下的 default operand size(默认操作数宽度)与 default address size(默认地址宽度), effective operand size(有效的操作数宽度)与 effective address size(有效的地址宽度).

![2020-01-24-22-29-47.png](./images/2020-01-24-22-29-47.png)

![2020-01-24-22-33-24.png](./images/2020-01-24-22-33-24.png)

指令的默认 operand size、address size 由 CS.D 和 CS.L 位(IA\-32e/long\-mode 可用)决定.

-

另外, stack address(栈地址, 或栈指针)的宽度由 SS.B 位决定, 但不能被 override(改写).

-

栈地址宽度不能被 address\-size override prefix(地址宽度改写前缀)修改, 例如下面的代码.

```assembly
DB 67h          ; address override prefix
push eax        ; 32 位的栈地址不能被改写
```

上面的示例, 企图使用地址宽度改写前缀 67H 修改栈地址为 16 位是不起作用的. PUSH 指令中的 32 位栈地址仍然是 32 位.

然而, 指令的 default operand size(默认操作数宽度), 以及 default address size(默认地址宽度)都可以使用 override prefix(改写前缀)进行修改.

-
...

# 64-bit 模式下的其他指令处理

对于较复杂的部分函数分别单独实现了 32 位与 64 位版本.


# 函数重定义表