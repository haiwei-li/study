<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 16 位字段值](#1-16-位字段值)
- [2. 32 位字段值](#2-32-位字段值)
- [3. 64 位字段值](#3-64-位字段值)
- [4. natural-width 位字段值](#4-natural-width-位字段值)
- [5. 总结](#5-总结)

<!-- /code_chunk_output -->

VMREAD 指令的**源操作数**提供**字段 ID 值**, **目标操作数**接收读取的 **VMCS 字段值**.

VMWRITE 指令的**目标操作数**提供**字段 ID 值**, **源操作数**提供需要**写入的值**.

> 字段 ID 值永远是 32 位, 而读/写的字段值可能是 16/32/64/natural-width 位宽

对于**不同宽度的字段值**有相应的**读写原则**.

# 1. 16 位字段值

在 32 位模式下,

* **VMREAD** 指令读取 **VMCS 字段值**放入目标操作数的 `bits 15:0`, **目标操作数**的 `bits 31:16` **清 0**.
* **VMWRITE** 指令将**源操作数**的 `bits 15:0` 写入相应的 VMCS 字段, 源操作数的 `bits 31:16` **忽略**.

在 64 位模式下,

* **VMREAD** 指令读取 VMCS 字段值放入目标操作数 `bits 15:0`, **目标操作数**的 `bits 63:16` 清 0.
* **VMWRITE** 指令将源操作数的 `bits 15:0` 写入相应的 VMCS 字段, **源操作数**的 `bits 63:16` 忽略.

# 2. 32 位字段值

在 32 位模式下,

* **VMREAD** 指令读取 VMCS 字段值放入 32 位目标操作数.
* **VMWRITE** 指令将 32 位源操作数写入 VMCS 字段.

在 64 位模式下,
* **VMREAD** 指读取 VMCS 字段值放入目标操作数的 `bits 31:0`, 目标操作数的 `bits 63:32` **清 0**.
* **VMWRITE** 指令将源操作数的 `bits 31:0` 写入相应 VMCS 字段, 源操作数的 `bits 63:32` **忽略**.

# 3. 64 位字段值

在 32 位模式下, 完整的**读取**需要分**两次进行**:

* **VMREAD** 指令读 **full** 字段, 得到 VMCS 字段的 `bits 31:0` 值放入目标操作数, 得到的 VMCS 字段的 `bits 63:32` 忽略. 这就得到了 64 位字段值的低 32 位.
* **VMREAD** 指令读 **high** 字段, 得到 VMCS 字段的 `bits 63:32` 值放入目标操作数, 得到的 VMCS 字段的 `bits 31:0` 忽略.

注: 也就是说 **32 位模式**下 vmread 指令的**目标操作数**还是 **32 位**, 但是因为访问的是 **64 位字段值**, 所以需要**针对性再填充下**

见下面`总结`

在 32 位模式下, 完整的**写入**需要分**两次进行**:

* **VMWRITE** 指令写 **full** 字段, 源操作数写入 VMCS 字段的 `bits 31:0`, VMCS 字段的 `bits 63:32` 被清 0.
* **VMWRITE** 指令写 **high** 字段, 源操作数写 VMCS 字段的 `bits 63:32`, VMCS 字段的 `bits 31:0` 不变.

在 64 位模式下, **直接读写 full 字段**, 对应完整的 64 位字段, **无须读写 high 字段**.

在 64 位模式下,
* **如果读 high 字段**, 则 **VMCS 字段**的 `bits 63:32` 值放入**目标操作数**的 `bits 31:0`, **目标操作数**的 `bits 63:32` 清 0.
* **如果写 high 字段**, 则**源操作数**的`bits 31:0` 写入 **VMCS 字段**的 `bits 63:32`, **源操作数**的 `bits 63:32` 忽略, VMCS 字段的 `bits 31:0` 不变.

# 4. natural-width 位字段值

**此类型的字段**在支持 64 位架构的处理器上是 64 位, 否则为 32 位. `natural-width` 字段**只有一个字段 ID** (full 字段, 不存在 high 字段). `natural-width` 字段的读写分为如下三个方面.

(1) 在 **64** 位架构处理器的 **32** 位模式下

> 64 位架构上, vmcs 字段是 64 位宽

* VMREAD 指令读 VMCS 字段的 `bits 31:0` 放入目标操作数, VMCS 字段的 `bits 63:32` **忽略**.

* VMWRITE 指令将**源操作数**写 VMCS 字段的 `bits 31:0`, VMCS 字段的 `bits 63:32` **清 0**.

(2) 在 **64** 位架构处理器的 **64** 位模式下

* VMREAD 指令读 64 位 VMCS 字段值放入目标操作数.

* VMWRITE 指令将 64 位源操作数写入 64 位 VMCS 字段

(3) 在 **32** 位架构处理器上, 只有 **32** 位模式读写方式

* VMREAD 指令读 32 位 VMCS 字段值放入目标操作数.

* VMWRITE 指令将 32 位源操作数写入 32 位 VMCS 字段.

下面一段代码演示对 VMCS 字段进行写操作:

......

# 5. 总结

区分清楚 a. 字段 ID 值; b. 字段值; c. 操作数位数 的关系

1. **字段 ID 值有效位永远是 32 位, 而读/写的字段值可能是 16/32/64/natural-width 位宽**

2. 而 VMREAD/VMWRITE 指令在 **32 位模式**下固定使用 **32 位的操作数**, 在 **64 位**模式下固定使用 **64 位操作数**. (包括源操作数和目的操作数)

3. 所以就算 32 位模式下得到 64 位字段值, 但是操作数是 32 位, 所以会将得到的字段值进行切割(要么去掉低 32, 要么去掉高 32 位), 剩下的来填充操作数

4. 而 64 位模式得到的 32 位字段值, 但是操作数是 64 位, 所以会将得到的字段值进行填充, 然后给操作数