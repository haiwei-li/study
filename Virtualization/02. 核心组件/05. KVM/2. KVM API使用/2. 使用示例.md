
本节将以一个非常简单的例子展示 QEMU 和 KVM 的关系. 这个例子包括两个部分, 第一部分是一个精简版内核, 这个内核非常简单, 它的任务仅仅是向 I/O 端口写入数据. 第二部分可以看作是一个精简版的 QEMU, 它的任务也非常简单, 就是将上述精简内核的端口数据打印出来.

精简的内核代码如下: 向端口 0xf1 写入 Hello 字符串, 然后调用 hlt 指令

```assembly

```

使用如下命令编译上述汇编代码.

```

```

精简版的 QEMU 代码如下.

```cpp

```

编译并执行该文件.

```

```

可以看到这个名为 light-qemu 的精简版 QEMU 输出了精简版内核向端口写入的数据. 下面对 light-qemu 程序进行简单介绍.

KVM 通过一组 ioctl 向用户空间导出接口, 这些接口能够用于虚拟机的创建, 虚拟机内存的设置, 虚拟机 VCPU 的创建与运行等. 按照接口所使用的文件描述符 (file descriptor, fd) 不同, KVM 的这组 ioctl 接口可以分为三类:

1) 系统全局的 ioctl, 这类 ioctl 的作用对象是 KVM 模块本身, 比如一些全局的配置项, 创建虚拟机的 ioctl 也在此例.

2) 虚拟机相关的 ioctl, 这类 ioctl 的作用对象是一台虚拟机, 比如设置虚拟机的内存布局, 创建虚拟机 VCPU 也在此例.

3) 虚拟机 VCPU 相关的 ioctl, 这类 ioctl 的作用对象是一个虚拟机的 VCPU, 比如说开始虚拟机 VCPU 的运行.

在 light-qemu 中, 首先通过打开 "/dev/kvm" 获取系统中 KVM 子系统的文件描述符 kvmfd, 为了保持应用层和内核的统一, 可以通过 ioctl(KVM_GET_API_VERSION)获取 KVM 的版本号, 从而使应用层知道相关接口在内核是否有支持.

接着在 kvmfd 上面调用 ioctl(KVM_CREATE_VM)创建一个虚拟机, 该 ioctl 返回一个代表虚拟机的文件描述符 vmfd. 这代表了一个完整的虚拟机系统, 可以通过 vmfd 控制虚拟机的内存, VCPU 等. 内存是一个计算机必不可少的组件, 所以在创建了虚拟机之后, 需要给虚拟机分配物理内存, 虚拟机的物理内存对应 QEMU 的进程地址空间, 这里使用 mmap 系统调用分配了一页虚拟机内存, 并且将精简版的内核代码读入了这段空间中. 之后用分配的虚拟内存地址初始化 kvm_userspace_memory_region 对象, 然后调用 ioctl(KVM_SET_USER_MEMORY_REGION), 这就为虚拟机指定了一个内存条. 其中 slot 用来表示不同的内存空间, guest_phys_addr 表示这段空间在虚拟机物理内存空间的位置, memory_size 表示这段物理空间的大小, userspace_addr 则表示这段物理空间对应在宿主机上的虚拟机地址.

设置好虚拟机的内存后, light-qemu 接着在 vmfd 上调用 ioclt(KVM_CREATE_VCPU)来创建虚拟机 VCPU. 每一个 VCPU 都有一个 struct kvm_run 结构, 用来在用户态 (这里是 light-qemu) 和内核态 (KVM) 共享数据. 用户态程序需要将这段空间映射到用户空间, 为此首先调用 ioctl(KVM_GET_VCPU_MMAP_SIZE)得到这个结构的大小, 注意这里是对 kvmfd 调用 ioctl, 因为这个对 KVM 所有 VCPU 都是一样的. 接着调用 mmap, 将 kvm_run 映射到了用户态空间.

为了让虚拟机 VCPU 运行起来, 需要设置 VCPU 的相关寄存器, 其中段寄存器和控制寄存器等特殊寄存器存放在 kvm_sregs, 通过 ioctl(KVM_GET_SREGS)读取和修改, 通用寄存器存放在结构 kvm_regs 中, 通过 ioctl(KVM_SET_REGS)读取和修改. 最重要的是设置 CS 和 IP 寄存器, light-qemu 都将其设置为 0, 由于代码加在了虚拟机物理地址 0 处, 所以虚拟机 VCPU 运行的时候直接从地址 0 处取指令开始运行.

至此, 一个简单的虚拟机和虚拟机 VCPU, 内存都已经准备完毕, 寄存器也设置好了, 这个时候可以让虚拟机运行起来了. 通常在一个循环中对 vcpufd 调用 ioctl(KVM_RUN). 内核在处理这个 ioctl 时会把 VCPU 调度到物理 CPU 上运行, VCPU 在运行过程中遇到一些敏感指令时会退出, 如果内核态的 KVM 不能处理就会交给应用层软件处理, 此时 ioctl 系统调用返回, 并且将一些信息保存到 kvm_run, 这样用户态程序就能够知道导致虚拟机退出的原因, 然后根据原因进行相应的处理. 在这个例子中, 虚拟机内核向端口写数据会产生 KVM_EXIT_IO 的退出, 表示虚拟机内部读写了端口, 在输出了端口数据之后让虚拟机继续执行, 执行到最后一个 hlt 指令时, 会产生 KVM_EXIT_HLT 类型的退出, 此时虚拟机运行结束.

当然, 与精简的 QEMU 和精简的内核相比, 实际的 QEMU 和实际的操作系统的内核复杂度都远远超过这个水平, 但是其基本原理都是类似的.