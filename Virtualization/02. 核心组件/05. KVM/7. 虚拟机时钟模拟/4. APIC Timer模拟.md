
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. APIC timer 中断](#1-apic-timer-中断)
  - [1.1. 硬件原理](#11-硬件原理)
  - [1.2. 流程简介](#12-流程简介)
- [2. 相关结构体](#2-相关结构体)
- [3. 创建和初始化虚拟定时器设备](#3-创建和初始化虚拟定时器设备)
- [4. 配置定时器模式: 写 LVTT](#4-配置定时器模式-写-lvtt)
- [5. 设置定时器: 写 TMICT 或 TSC-Deadline](#5-设置定时器-写-tmict-或-tsc-deadline)
  - [5.1. 定时器的触发](#51-定时器的触发)
  - [5.2. 整体流程](#52-整体流程)
  - [5.3. 入口代码](#53-入口代码)
  - [5.4. set_target_expiration(): 设置目标过期时间](#54-set_target_expiration-设置目标过期时间)
  - [5.5. restart_apic_timer(): 重启 apic timer 定时器](#55-restart_apic_timer-重启-apic-timer-定时器)
    - [5.5.1. start_hv_timer(): 优先使用 hv timer](#551-start_hv_timer-优先使用-hv-timer)
    - [5.5.2. start_sw_timer(): 使用 sw timer](#552-start_sw_timer-使用-sw-timer)
      - [5.5.2.1. start_sw_period(): 周期性或一次性模式](#5521-start_sw_period-周期性或一次性模式)
      - [5.5.2.2. start_sw_tscdeadline(): tscdeadline 模式](#5522-start_sw_tscdeadline-tscdeadline-模式)
- [6. timer 到期](#6-timer-到期)
  - [6.1. preemption timer 到期](#61-preemption-timer-到期)
    - [6.1.1. 整体流程](#611-整体流程)
    - [6.1.2. handle_preemption_timer(): 到期 vmexit 处理函数](#612-handle_preemption_timer-到期-vmexit-处理函数)
    - [6.1.3. preemption timer 处理](#613-preemption-timer-处理)
  - [6.2. hrtimer 到期的外部中断](#62-hrtimer-到期的外部中断)
    - [6.2.1. 整体流程](#621-整体流程)
    - [6.2.2. apic_timer_fn(): hrtimer 到期的响应函数](#622-apic_timer_fn-hrtimer-到期的响应函数)
  - [6.3. apic_timer_expired(): apic timer 已经到期处理](#63-apic_timer_expired-apic-timer-已经到期处理)
- [7. trace](#7-trace)
  - [7.1. 使用 ftrace](#71-使用-ftrace)
    - [7.1.1. tscdeadline_immed](#711-tscdeadline_immed)
    - [7.1.2. tscdeadline](#712-tscdeadline)
      - [7.1.2.1. Intel 禁用 preemption timer](#7121-intel-禁用-preemption-timer)
      - [7.1.2.2. Intel 启用 preemption timer](#7122-intel-启用-preemption-timer)
      - [7.1.2.3. AMD 启用 avic](#7123-amd-启用-avic)
      - [7.1.2.4. AMD 禁用 avic](#7124-amd-禁用-avic)

<!-- /code_chunk_output -->

# 1. APIC timer 中断

## 1.1. 硬件原理

见 `Architecture/Learning/x86_64 编程体系探索及编程/第 4 篇 中断体系/第 18 章 local APIC 体系/12. APIC timer.md`

## 1.2. 流程简介

前面提到, APIC Timer 的 APIC 定时器有 3 种定时器模式: 周期触发 periodic 和一次性触发 one-shot 和 TSC-Deadline 模式.

![2020-05-26-09-28-21.png](./images/2020-05-26-09-28-21.png)

从图中可以看到, timer 中断大概分为下面几步

注: 详细见 `Architecture/Learning/x86_64 编程体系探索及编程/第 4 篇 中断体系/第 18 章 local APIC 体系/12. APIC timer.md`中 APIC timer 的操作步骤

guest 的 lapic 是通过 host 上的 hrtimer 模拟的, guest 的 timer 到期后, vCPU 收到 host 上 hrtimer interrupt, 导致 vCPU vmexit, KVM 把这个 timer interrupt inject 给 guest, guest 里最终感受到了 timer fire 的 interrupt, 这个过程比较长, 等 guest 里感受到 timer fire 的时候, 实际已经格外经历了上述虚拟化 tax.  社区的 advance lapic timer 让 guest 的 timer 提前到期, 这样加上虚拟化层的 tax, 期望 guest 感受到 timer fire 的时间与 guest 期望的 timer 到期时间接近.


1. 设置 timer 模式, 通过写 LVTT 实现, 发生 VM-exit

2. 虚拟机设置 APIC timer, 主要包括两个, 写 TMICT 寄存器(用于 one-shot/period 模式); 写 TSCDEADLINE MSR 寄存器(用于 tscdeadline 模式). 从而发生 vm-exit, 进入 KVM 中

3. 在 KVM 中, 模拟虚拟机的 APIC 设置, 先设置这几个寄存器, 然后启用 lapic timer 定时器(优先使用**hv timer**`<preemption timer>`, 其次使用**hrtimer**)作为中断源, 最后进入 Guest 模式

intel 下还有 posted interrupt, amd 下有 doorbell 机制

4. timer 到期会发生 vm-exit, 进入 KVM 中

* preemption timer 导致的 vm-exit, exit reason 就是 preemption timer
* hrtimer 到期会产生外部中断, 导致虚拟机 vm-exit, 这个 exit reason 是外部中断到期后处理

5. KVM 中调用 timer 处理函数, 注入中断, 进入 guest 模式

6. 虚拟机执行时间中断处理函数, 发送 EOI, 导致 vm-exit

7. KVM 中模拟 EOI 行为后, 进入 Guest 模式

注: TMICT, Timer Initial Count 寄存器

注 2: 还有 exitless timer 情况

a. 设置 timer
b. 启动 timer
c. 停止 timer
d. 取消 timer

下面分析 QEMU-KVM 模拟 APIC Timer**周期触发**(periodic)**模式**中断过程

# 2. 相关结构体

```cpp
// arch/x86/kvm/lapic.h
struct kvm_lapic {
        // APIC Timer
        struct kvm_timer lapic_timer;
}
```

`struct kvm_lapic`详细见`Virtualization/KVM/5. IO 虚拟化/4. Interrupt/2. 数据结构.md`

```cpp
// arch/x86/kvm/lapic.h
struct kvm_timer {
        // 这个 timer 使用 hrtimer
        struct hrtimer timer;
        s64 period;                             /* unit: ns */
        ktime_t target_expiration;
        u32 timer_mode;
        u32 timer_mode_mask;
        u64 tscdeadline;
        // 通过 blame 看到最开始是 tscdeadline 模式下给 advanced timer 用
        u64 expired_tscdeadline;
        u32 timer_advance_ns;
        s64 advance_expire_delta;
        atomic_t pending;                       /* accumulated triggered timers */
        bool hv_timer_in_use;
};
```

# 3. 创建和初始化虚拟定时器设备

由于 APIC Timer 设备实际就是**lapic**的一个**功能**, 所以在创建 lapic 设备同时, 也就辅助设置了.

不存在 qemu 侧流程

```cpp
int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
{
        ......
        // 建立 hrtimer 定时器, 回调函数 apic_timer_fn
        hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,
                     HRTIMER_MODE_ABS_HARD);
        // hrtimer 定时器回调函数, 即 APIC Timer 设备产生中断的函数
        apic->lapic_timer.timer.function = apic_timer_fn;
        ......
}
```

该如何模拟 APIC Timer 设备呢?对于**周期性时钟中断**, 我们可以采用**定时器方式**, **一定间隔**调用一次**中断源产生函数**, **模拟时钟中断发生**.

首先创建一个**定时器**, 然后初始化**APIC Timer 设备**产生**中断的函数**, 实际就是定时器回调函数.


查看:

```
/sys/kernel/debug/kvm/97073-19/vcpu3/lapic_timer_advance_ns
```

# 4. 配置定时器模式: 写 LVTT

```cpp
void kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
{
        case APIC_LVTT:
                if (!kvm_apic_sw_enabled(apic))
                        val |= APIC_LVT_MASKED;
                val &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);
                kvm_lapic_set_reg(apic, APIC_LVTT, val);
                apic_update_lvtt(apic);
                break;
}
```

# 5. 设置定时器: 写 TMICT 或 TSC-Deadline



## 5.1. 定时器的触发

```cpp
vmx_handle_exit [kvm_intel]() {
handle_wrmsr [kvm_intel]() {
kvm_set_msr [kvm]() {
vmx_set_msr [kvm_intel]() {
kvm_set_msr_common [kvm]() {
kvm_set_lapic_tscdeadline_msr [kvm]() {

// 写寄存器 TMICT, 初始计数寄存器, one-shot/period
void kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
{
        case APIC_TMICT:
                // tscdeadline 模式, 直接忽略返回
                if (apic_lvtt_tscdeadline(apic))
                        break;
                // 取消 lapic 的 hrtimer
                hrtimer_cancel(&apic->lapic_timer.timer);
                // 设置 lapic 的 APIC_TMICT 寄存器值
                kvm_lapic_set_reg(apic, APIC_TMICT, val);
                // 启用 lapic 的 timer
                start_apic_timer(apic);
                break;
}
```

```cpp
// 写 tscdeadline 的 msr 寄存器, tscdeadline 模式, tsc 到达触发中断
void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)
{
        struct kvm_lapic *apic = vcpu->arch.apic;
        // lapic 不在内核态实现,
        // 或 lapic 处于 oneshot 模式
        // 或 lapic 处于周期性模式,
        // 则直接返回
        if (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||
                        apic_lvtt_period(apic))
                return;
        // 取消 lapic 的 hrtimer
        hrtimer_cancel(&apic->lapic_timer.timer);
        // 设置 lapic timer 的 tscdeadline 值
        apic->lapic_timer.tscdeadline = data;
        // 启用 lapic 的 timer
        start_apic_timer(apic);
}
```

启用上面的定时器, 最终会调用 apic timer 回调函数

## 5.2. 整体流程

```cpp
start_apic_timer()  // 启动 apic timer 定时器
 ├─ __start_apic_timer(apic, APIC_TMICT); // 传入 TMICT 初始计数寄存器
 |   ├─ atomic_set(&apic->lapic_timer.pending, 0); // 清空 lapci timer 的 pending
 |   ├─ set_target_expiration(apic, count_reg); // 设置到期时间, 当前流程中, 周期性/一次性模式情况下才调用, tscdeadline 不会调用
 |   |   ├─ ktime_t now = ktime_get(); // 获取当前 ktime
 |   |   ├─ apic->lapic_timer.period = tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT)); // 设置触发周期时间, 即 TMICT 初始计数寄存器值, 即 TMICT 寄存器的值(只不过转换成 ns 单位)
 |   |   ├─ apic->lapic_timer.tscdeadline = 0; return false; // TMICT 为 0 的话, 意味着停止一次性/周期性 timer, 则设置 tscdeadline 为 0 然后返回
 |   |   ├─ limit_periodic_timer_frequency(apic); //
 |   |   ├─ deadline = apic->lapic_timer.period; // 等于 TMICT
 |   |   ├─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, deadline); // tscdeadline 设置, 虚拟机 tsc+deadline
 |   |   └─ apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline); // target_expiration 设置, now + deadline
 |   └─ restart_apic_timer();  // 重启定时器
 |       ├─ preempt_disable(); // 关闭抢占
 |       ├─ !period(apic) && pending; return;// 如果 apic timer 当前不是周期模式(即一次性/tscdeadline 模式)而且有 pending 事件, 直接返回, 不重启
 |       ├─ start_hv_timer(); // 优先使用 hv timer, 即 preemption timer
 |       |   ├─ kvm_can_use_hv_timer(vcpu); // 不能使用 hv timer, 则直接返回 false
 |       |   ├─ !apic->lapic_timer->tscdeadline; return false// tscdeadline 是 0, 则直接返回 false
 |       |   ├─ kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired); // 设置 vmx->hv_deadline_tsc, 失败则直接返回 false
 |       |   |   ├─ guest_tscl = kvm_read_l1_tsc(vcpu, tscl);// 获取虚拟机 tsc
 |       |   |   ├─ delta_tsc = max(ktimer->tscdeadline, guest_tscl) - guest_tscl;// 虚拟机 tscdeadline 的 tsc 差值
 |       |   |   ├─ vmx->hv_deadline_tsc = tscl + delta_tsc;// 设置 hv_deadline_tsc
 |       |   |   └─ *expired = !delta_tsc; // 设置是否到期
 |       |   ├─ ktimer->hv_timer_in_use = true; // 设置 apic timer 的 hv timer 在使用
 |       |   ├─ hrtimer_cancel(&ktimer->timer); // 取消 hrtimer 定时器
 |       |   ├─ cancel_hv_timer(apic); // 非周期性且有 timer pending, 取消 hv timer
 |       |   |   ├─ kvm_x86_ops.cancel_hv_timer(apic->vcpu); // 取消 hv timer
 |       |   |   |   └─ to_vmx(vcpu)->hv_deadline_tsc = -1; //
 |       |   |   └─ ktimer->hv_timer_in_use = false; // 设置 apic timer 的 hv timer 不在使用
 |       |   ├─ apic_timer_expired(apic, false); // 非周期性, 没有 pending 且已经到期,
 |       |   |   ├─ kvm_get_running_vcpu();
 |       |   |   └─ kvm_apic_local_deliver(); //
 |       |   |       └─ __apic_accept_irq();
 |       |   |           └─ vmx_deliver_posted_interrupt();
 |       |   |               └─ kvm_get_running_vcpu();
 |       |   └─ cancel_hv_timer(vcpu); // 非周期性, 没有 pending 且已经到期, 取消 hv timer
 |       |   |   └─ vmx_cancel_hv_timer(); //
 |       ├─ start_sw_timer(); // 不能使用 hv timer, 则使用 sw timer
 |       |   ├─ cancel_hv_timer(); // 如果 hv timer 在使用, 则取消 hv timer
 |       |   ├─ (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending)); return; // 如果不是周期性的, 但是存在 pending, 直接返回
 |       |   ├─ start_sw_period(); // 周期性或一次性模式, 调用这个
 |       |   |   ├─ (!apic->lapic_timer.period); return; // 如果周期为 0(一般是 TMICT), 表明停用 one-shot 或 period, 直接返回
 |       |   |   ├─ apic_timer_expired(apic, false); // 当前时间晚于 target_expiration, 即已经过期, 则直接注入 pending timer irq
 |       |   |   ├─ apic_lvtt_oneshot(apic); return;// 已经到期并且是一次性模式, 则直接结束, 返回
 |       |   |   ├─ advance_periodic_target_expiration();// 已经过期, 对于周期性的, 设置周期性下一次目标超时时间
 |       |   |   |   ├─ apic->lapic_timer.target_expiration = ktime_add_ns(apic->lapic_timer.target_expiration, apic->lapic_timer.period) // 下一个周期的超时时间
 |       |   |   |   ├─ delta = ktime_sub(apic->lapic_timer.target_expiration, now); // 下一个周期的超时时间和现在时间的差值
 |       |   |   |   └─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, delta); // 设置 tscdeadline = 虚拟机中当前 tsc + 差值
 |       |   |   └─ hrtimer_start(lapic_timer.timer, apic->lapic_timer.target_expiration, HRTIMER_MODE_ABS_HARD); // 启用 hrtimer, 一次性或者周期性的
 |       |   └─ start_sw_tscdeadline(vcpu); // tscdeadline 模式, 调用这个
 |       |   |   ├─ tscdeadline = ktimer->tscdeadline; // 获取 apic timer 的 tscdeadline 值
 |       |   |   ├─ local_irq_save(flags); // 关闭中断
 |       |   |   ├─ ns = (tscdeadline - guest_tsc) * 1000000ULL; // 根据 vcpu tsc 频率得到目标 tscdeadline 与虚拟机 tsc 差值, ns 单位
 |       |   |   ├─ do_div(ns, this_tsc_khz); // 根据 vcpu 的 tsc 计数频率计算差
 |       |   |   ├─ hrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD); // 当还没有到期并且差值大于 advanced timer 调整时间, 即没有超时, 则启用 hrtimer
 |       |   |   ├─ apic_timer_expired(apic, false); // 已经到期了
 |       |   |   └─ local_irq_restore(flags); // 恢复中断
 |       └─ preempt_enable(); // 打开抢占
```

## 5.3. 入口代码

```cpp
// Timer initial counter register, timer 初始计数寄存器
#define APIC_TMICT 0x380

// arch/x86/kvm/lapic.c
static void start_apic_timer(struct kvm_lapic *apic)
{
        // APIC_TMICT 是初始计数寄存器
        __start_apic_timer(apic, APIC_TMICT);
}

static void __start_apic_timer(struct kvm_lapic *apic, u32 count_reg)
{
        // 清空 lapci timer 的 pending
        atomic_set(&apic->lapic_timer.pending, 0);
        // APIC timer 是周期性模式或者一次性模式 并且
        // 设置到期时间失败的话, 直接返回
        // 当前流程 count_reg 是 APIC_TMICT
        if ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
            && !set_target_expiration(apic, count_reg))
                return;
        // 重启 apic timer 定时器
        restart_apic_timer(apic);
}
```

只有**周期性/一次性**模式, 才会去调用`set_target_expiration()`**设置目标过期时间**, 再调用`restart_apic_timer()`, 启用 apic timer 定时器.

如果是**周期性/一次性**模式的话, 但是`set_target_expiration()`返回 false 的话, 直接返回, 也就是停止 timer. 结合代码可以看到, 停止也就是周期性/一次性模式下设置 TMICT 为 0, 符合 APIC 的硬件语义.

对于 tscdeadline 模式, 直接调用`restart_apic_timer()`, 启用 apic timer 定时器

## 5.4. set_target_expiration(): 设置目标过期时间

当前流程中, 只有**周期性/一次性**模式才调用, tscdeadline 模式不调用

```cpp
// 这个函数本身是都会调用, 不限于周期性/一次性
// 根据传入的 count_reg 计数寄存器(apic 的一个寄存器)设置到期时间
static bool set_target_expiration(struct kvm_lapic *apic, u32 count_reg)
{
        ktime_t now;
        // 读取当前 tsc
        u64 tscl = rdtsc();
        s64 deadline;
        // 当前 ktime
        now = ktime_get();
        // 获取 TMICT 寄存器值, 设置触发周期时间
        // 即, TMICT 初始计数寄存器值(转换成 ns 单位)
        apic->lapic_timer.period =
                        tmict_to_ns(apic, kvm_lapic_get_reg(apic, APIC_TMICT));
        // 如果初始计数寄存器值为 0, 则是停止 one shot/period
        if (!apic->lapic_timer.period) {
                // 设置 tscdeadline 为 0, 返回 false
                apic->lapic_timer.tscdeadline = 0;
                return false;
        }

        // 再往下面, 说明 period 即 TMICT 不为 0, 即已经有初始计数值了
        limit_periodic_timer_frequency(apic);
        // deadline 就是 TMICT 初始计数寄存器的值(只不过转换成 ns 单位)
        deadline = apic->lapic_timer.period;
        // 周期性/一次性时
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {
                // 传入的不是 TMICT 寄存器时, 当前流程不进入
                if (unlikely(count_reg != APIC_TMICT)) {
                        // deadline 是 count_reg 寄存器值(只不过转换成 ns 单位)
                        deadline = tmict_to_ns(apic,
                                     kvm_lapic_get_reg(apic, count_reg));
                        // count_reg 寄存器值小于 0 的话, 还是使用 TMICT 寄存器值
                        if (unlikely(deadline <= 0))
                                // deadline 还是 TMICT
                                deadline = apic->lapic_timer.period;
                        // count_reg 寄存器值大于 TMICT 值, 即大于初始计数器值
                        // 使用 TMICT 值
                        else if (unlikely(deadline > apic->lapic_timer.period)) {
                                pr_info_ratelimited(
                                    "kvm: vcpu %i: requested lapic timer restore with "
                                    "starting count register %#x=%u (%lld ns) > initial count (%lld ns). "
                                    "Using initial count to start timer.\n",
                                    apic->vcpu->vcpu_id,
                                    count_reg,
                                    kvm_lapic_get_reg(apic, count_reg),
                                    deadline, apic->lapic_timer.period);
                                // 设置传入的 count_reg 寄存器为 0
                                kvm_lapic_set_reg(apic, count_reg, 0);
                                // deadline 等于 TMICT
                                deadline = apic->lapic_timer.period;
                        }
                }
        }
        // tscdeadline 值 = 虚拟机 tsc + deadline
        apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +
                nsec_to_cycles(apic->vcpu, deadline);
        // 到期时间 = now + deadline
        apic->lapic_timer.target_expiration = ktime_add_ns(now, deadline);

        return true;
}
```

1. 将 TMICT 初始计数寄存器值(转换成 ns 单位)作为 lapic timer 的触发周期, `apic->lapic_timer.period`

`tmict_to_ns()` 用于将**初始计数值**转换成 ns 单位, 初始计数值类似于 TMICT 寄存器的值.

```cpp
#define APIC_BUS_CYCLE_NS 1
static inline u64 tmict_to_ns(struct kvm_lapic *apic, u32 tmict)
{
        // 根据 clock 时钟频率将 tmict(初始计数)转换成 ns 单位
        return (u64)tmict * APIC_BUS_CYCLE_NS * (u64)apic->divide_count;
}
```

2. 计算 deadline, 默认 TMICT 寄存器的值;
3. 设置`apic->lapic_timer.tscdeadline`为 `虚拟机 tsc + deadline`
4. 设置`apic->lapic_timer.target_expiration`为 `ktime_get() + deadline`

## 5.5. restart_apic_timer(): 重启 apic timer 定时器

```cpp
static void restart_apic_timer(struct kvm_lapic *apic)
{
        preempt_disable();
        // 不是周期性模式 并且
        // apic timer 有 pending 事件, 直接退出
        if (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))
                goto out;
        // 优先使用 hv timer
        if (!start_hv_timer(apic))
                start_sw_timer(apic);
out:
        preempt_enable();
}
```

如果**不是周期性模式**时(即**一次性/tscdeadline 模式**), 而 apic timer**有 pending 事件**, 则不启动 timer, 直接退出.

先试图启用 hv timer, 如果启动失败, 则使用 sw timer.

### 5.5.1. start_hv_timer(): 优先使用 hv timer

这个就是`preemption timer`

```cpp

static bool start_hv_timer(struct kvm_lapic *apic)
{
        // 获取 apic timer
        struct kvm_timer *ktimer = &apic->lapic_timer;
        struct kvm_vcpu *vcpu = apic->vcpu;
        bool expired;

        WARN_ON(preemptible());
        // 判断能不能使用 hv_timer
        if (!kvm_can_use_hv_timer(vcpu))
                return false;
        // tscdeadline 是 0, 直接返回 false
        if (!ktimer->tscdeadline)
                return false;
        // 对应 vmx 的 vmx_set_hv_timer, 设置 vmx->hv_deadline_tsc
        // 设置失败, 直接返回 false
        if (kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired))
                return false;
        // 设定 hv timer 正在使用
        ktimer->hv_timer_in_use = true;
        // 取消 lapic hrtimer
        hrtimer_cancel(&ktimer->timer);

        /*
         * To simplify handling the periodic timer, leave the hv timer running
         * even if the deadline timer has expired, i.e. rely on the resulting
         * VM-Exit to recompute the periodic timer's target expiration.
         */
        // 非周期性, 也就是 one-shot 或 tscdeadline 模式
        if (!apic_lvtt_period(apic)) {
                /*
                 * Cancel the hv timer if the sw timer fired while the hv timer
                 * was being programmed, or if the hv timer itself expired.
                 */
                // timer pending 事件存在
                if (atomic_read(&ktimer->pending)) {
                        // 取消 hv timer
                        cancel_hv_timer(apic);
                // 没有 pending, 已经到期
                } else if (expired)
                        apic_timer_expired(apic, false);
                        // 取消 hv timer
                        cancel_hv_timer(apic);
                }
        }

        trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);

        return true;
}
```

1. 判断能否使用 hv timer, 不能使用即退出

```cpp
bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
{
        return kvm_x86_ops.set_hv_timer
               // mwait 没有透传, 或 kvm 不能能够 post timer interrupt
               && !(kvm_mwait_in_guest(vcpu->kvm) ||
                    kvm_can_post_timer_interrupt(vcpu));
}
```

mwait 指令没有透传给虚拟机, 或者不能够 post timer interrupt, 这个都不成立, 则表明能够使用 hv timer, 为什么???

preemption 只有 vcpu run 才会生效, 非透传下虚拟机 pause 不会 vmexit, 而 hlt 会



2. 设置 hv timer, 调用 vmx 的`vmx_set_hv_timer`, 设置`vmx->hv_deadline_tsc`, 设置失败则直接返回

```cpp
static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,
                            bool *expired)
{
        struct vcpu_vmx *vmx;
        u64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;
        // 获取 lapic timer
        struct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;

        vmx = to_vmx(vcpu);
        // 读取 host tsc
        tscl = rdtsc();
        // 读取 guest tsc ???
        guest_tscl = kvm_read_l1_tsc(vcpu, tscl);
        // 虚拟机 tscdeadline 到期的差值, 可能是 0
        delta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;
        // timer advanced
        lapic_timer_advance_cycles = nsec_to_cycles(vcpu,
                                                    ktimer->timer_advance_ns);

        if (delta_tsc > lapic_timer_advance_cycles)
                // tscdeadline 到期的差值大于 advanced time, 则减去这个 advanced time
                delta_tsc -= lapic_timer_advance_cycles;
        else
                delta_tsc = 0;

        /* Convert to host delta tsc if tsc scaling is enabled */
        if (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&
            delta_tsc && u64_shl_div_u64(delta_tsc,
                                kvm_tsc_scaling_ratio_frac_bits,
                                vcpu->arch.tsc_scaling_ratio, &delta_tsc))
                return -ERANGE;

        /*
         * If the delta tsc can't fit in the 32 bit after the multi shift,
         * we can't use the preemption timer.
         * It's possible that it fits on later vmentries, but checking
         * on every vmentry is costly so we just use an hrtimer.
         */
        if (delta_tsc >> (cpu_preemption_timer_multi + 32))
                return -ERANGE;
        // 让下次到期的 tsc, 经过 advanced time 调整了, 所以会更提前到期
        vmx->hv_deadline_tsc = tscl + delta_tsc;
        // tsc 差是 0, 表明已经过期
        *expired = !delta_tsc;
        return 0;
}
```

其实就是设置`vmx->hv_deadline_tsc = tscl + delta_tsc;`

3. 对于**非周期性**(即`tscdeadline`或`one-shot`)
* 如果已经有 pending 的, 则取消 hv timer 后返回;
* 如果没有 timer pending 且已经到期, 调用`apic_timer_expired()`再取消 hv timer.

```cpp
static void cancel_hv_timer(struct kvm_lapic *apic)
{
        WARN_ON(preemptible());
        WARN_ON(!apic->lapic_timer.hv_timer_in_use);
        // 调用 vmx_cancel_hv_timer
        kvm_x86_ops.cancel_hv_timer(apic->vcpu);
        // hv timer 设为不在用
        apic->lapic_timer.hv_timer_in_use = false;
}
```

```cpp
static void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)
{
        // 设置 hv_deadline_tsc 为 -1
        to_vmx(vcpu)->hv_deadline_tsc = -1;
}
```

注: 很明显, kvm-unit-test 的`tscdeadline_immed`会走这个到这个`apic_timer_expired()`流程

### 5.5.2. start_sw_timer(): 使用 sw timer

```cpp
static void start_sw_timer(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;

        WARN_ON(preemptible());
        // hv timer 在使用, 则取消
        if (apic->lapic_timer.hv_timer_in_use)
                cancel_hv_timer(apic);
        // 不是周期性, 但是存在 pending, 直接返回
        if (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))
                return;
        // 周期性或一次性模式
        if (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))
                start_sw_period(apic);
        // tscdeadline 模式
        else if (apic_lvtt_tscdeadline(apic))
                start_sw_tscdeadline(apic);
        trace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);
}
```

1. 如果 hv timer 在使用, 则取消;
2. 对于非周期性但是却存在 pending 的, 直接返回;
3. 针对周期性或一次性的, 调用`start_sw_period()`;
4. 针对 tscdeadline 的, 调用`start_sw_tscdeadline()`;

#### 5.5.2.1. start_sw_period(): 周期性或一次性模式

使用`apic->lapic_timer.target_expiration`

```cpp
static void start_sw_period(struct kvm_lapic *apic)
{
        // 周期为 0, 直接返回
        if (!apic->lapic_timer.period)
                return;
        // 当前时间晚于 target_expiration
        if (ktime_after(ktime_get(),
                        apic->lapic_timer.target_expiration)) {
                // 已经过期了, 处理
                apic_timer_expired(apic, false);
                // oneshot 的话, 不用做什么了, 直接返回
                if (apic_lvtt_oneshot(apic))
                        return;
                // 周期性的, 设置下个周期的超时时间 target_expiration
                advance_periodic_target_expiration(apic);
        }
        // 启用 hrtimer, 超时时间是 apic->lapic_timer.target_expiration
        hrtimer_start(&apic->lapic_timer.timer,
                apic->lapic_timer.target_expiration,
                HRTIMER_MODE_ABS_HARD);
}
```

1. 如果**周期为 0**(一般是 TMICT 初始计数寄存器值), 表明**停用 oneshot 或者周期性**, 则直接返回, 不启用
2. 如果当前时间晚于目标过期时间, 即**已经过期**的:
- 调用`apic_timer_expired()`处理过期, 其中会进行中断注入, 下面详细讲
- 如果是**一次性的话**, 那就此**结束**, 直接返回
- 否则(**周期性**)调用`advance_periodic_target_expiration()`设置**下一次的周期性目标过期时间**
3. 如果没有过期或者已经过期的进行了处理但是是周期性的, 则启动 apic timer 的 hrtimer, 超时时间是`apic->lapic_timer.target_expiration`(`ktime_get() + deadline`),

apic timer 的 hrtimer 是在 lapic 创建时候初始化的, 该 hrtimer 的中断响应回调函数是`apic_timer_fn()`, 详细见`中断虚拟化`部分

```cpp
// 设置周期性的下一次超时时间
static void advance_periodic_target_expiration(struct kvm_lapic *apic)
{
        // 当前时间
        ktime_t now = ktime_get();
        // 当前 tsc
        u64 tscl = rdtsc();
        ktime_t delta;

        /*
         * Synchronize both deadlines to the same time source or
         * differences in the periods (caused by differences in the
         * underlying clocks or numerical approximation errors) will
         * cause the two to drift apart over time as the errors
         * accumulate.
         */
        // 设置 target_expiration = 下一个周期的超时时间
        apic->lapic_timer.target_expiration =
                ktime_add_ns(apic->lapic_timer.target_expiration,
                                apic->lapic_timer.period);
        // 下一个周期超时时间和现在时间的差值
        delta = ktime_sub(apic->lapic_timer.target_expiration, now);
        // 设置 tscdeadline = 虚拟机中当前 tsc + 差值
        apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +
                nsec_to_cycles(apic->vcpu, delta);
}
```

总结:

- 对于周期性的, 无论如何都会**启用 hrtimer**;
- 对于一次性的, **已经过期的直接注入一次**, 否则**启用 hrtimer**

#### 5.5.2.2. start_sw_tscdeadline(): tscdeadline 模式

使用`apic->lapic_timer.tscdeadline`

```cpp
static void start_sw_tscdeadline(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;
        u64 guest_tsc, tscdeadline = ktimer->tscdeadline;
        u64 ns = 0;
        ktime_t expire;
        struct kvm_vcpu *vcpu = apic->vcpu;
        unsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;
        unsigned long flags;
        ktime_t now;

        if (unlikely(!tscdeadline || !this_tsc_khz))
                return;
        // 关中断
        local_irq_save(flags);
        // 当前时间
        now = ktime_get();
        // 虚拟机 tsc 值
        guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
        // 目标 tscdeadline 与虚拟机 tsc 差值
        ns = (tscdeadline - guest_tsc) * 1000000ULL;
        // 根据 vcpu tsc 计数频率得到差值的 ns 单位值
        do_div(ns, this_tsc_khz);
        // tscdeadline 大于虚拟机当前 tsc, 即没有超时
        // 并且差值大于 advanced timer 调整的时间
        if (likely(tscdeadline > guest_tsc) &&
            likely(ns > apic->lapic_timer.timer_advance_ns)) {
                // tscdeadline 的到期时间
                expire = ktime_add_ns(now, ns);
                // advanced timer 进行的调整
                expire = ktime_sub_ns(expire, ktimer->timer_advance_ns);
                // 启用 hrtimer, 超时时间是 expire
                hrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);
        } else
                // timer 超时, 直接注入
                apic_timer_expired(apic, false);
        // 恢复中断
        local_irq_restore(flags);
}
```
不存在周期性的说法

1. 关闭中断
2.
3. 恢复中断

# 6. timer 到期

步骤三和步骤四

涉及到 "acknowledge interrupt on exit" 机制, 可以参见 intel 手册关于外部中断部分.

有两个相关 commit:

f2485b3e0c6c0aa3a9546babc2fad3739e964ebb

d7a08882a0a4b4e176691331ee3f492996579534

在`vm-entry`之前, 会调用`vmx_update_hv_timer(vcpu);`

在`vm-entry`之前, 会调用`kvm_wait_lapic_expire(vcpu);`

## 6.1. preemption timer 到期

### 6.1.1. 整体流程

```cpp
handle_preemption_timer()  // preemption timer 处理
 ├─ handle_fastpath_preemption_timer(vcpu); //
 |   ├─ kvm_lapic_expired_hv_timer(vcpu); // 清空 lapci timer 的 pending
 |   |   ├─ preempt_disable(); // 禁用抢占
 |   |   ├─ cancel_hv_timer(apic); // 取消 hv timer
 |   |   |   ├─ kvm_x86_ops.cancel_hv_timer(apic->vcpu); // 取消 hv timer
 |   |   |   |   └─ to_vmx(vcpu)->hv_deadline_tsc = -1; //
 |   |   |   └─ ktimer->hv_timer_in_use = false; // 设置 apic timer 的 hv timer 不在使用
 |   |   ├─ apic_timer_expired(apic, false); //
 |   |   |   ├─ kvm_get_running_vcpu();
 |   |   |   └─ kvm_apic_local_deliver(); //
 |   |   |   |   └─ __apic_accept_irq();
 |   |   |   |       └─ vmx_deliver_posted_interrupt();
 |   |   |   |           └─ kvm_get_running_vcpu();
 |   |   ├─ apic_lvtt_period() && apic->lapic_timer.period; // 周期性的
 |   |   |   ├─ advance_periodic_target_expiration();// 已经过期, 对于周期性的, 设置周期性下一次目标超时时间
 |   |   |   |   ├─ apic->lapic_timer.target_expiration = ktime_add_ns(apic->lapic_timer.target_expiration, apic->lapic_timer.period) // 下一个周期的超时时间
 |   |   |   |   ├─ delta = ktime_sub(apic->lapic_timer.target_expiration, now); // 下一个周期的超时时间和现在时间的差值
 |   |   |   |   └─ apic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) + nsec_to_cycles(apic->vcpu, delta); // 设置 tscdeadline = 虚拟机中当前 tsc + 差值
 |   |   |   └─ restart_apic_timer();  // 重启定时器
 |   |   └─ preempt_disable(); // 打开抢占
```

### 6.1.2. handle_preemption_timer(): 到期 vmexit 处理函数

preemption timer 到期会发生 vmexit, exit reason 就是`preemption timer`, 最终在`vmx_handle_exit`中调用了`handle_preemption_timer`

两种情况调用:

1. `CONFIG_RETPOLINE`下直接调用并 return

```cpp
#ifdef CONFIG_RETPOLINE
        if (exit_reason == EXIT_REASON_MSR_WRITE)
                return kvm_emulate_wrmsr(vcpu);
        else if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)
                return handle_preemption_timer(vcpu);
        ......
#endif
```

2. 或者在函数最后调用

```cpp
return kvm_vmx_exit_handlers[exit_reason](vcpu);
```

### 6.1.3. preemption timer 处理

```cpp
static int handle_preemption_timer(struct kvm_vcpu *vcpu)
{
        handle_fastpath_preemption_timer(vcpu);
        return 1;
}

static fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)
{
        struct vcpu_vmx *vmx = to_vmx(vcpu);

        if (!vmx->req_immediate_exit &&
            !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled)) {
                kvm_lapic_expired_hv_timer(vcpu);
                return EXIT_FASTPATH_REENTER_GUEST;
        }

        return EXIT_FASTPATH_NONE;
}
```

```cpp
// arch/x86/kvm/lapic.c
void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)
{
        struct kvm_lapic *apic = vcpu->arch.apic;

        preempt_disable();
        /* If the preempt notifier has already run, it also called apic_timer_expired */
        if (!apic->lapic_timer.hv_timer_in_use)
                goto out;
        WARN_ON(rcuwait_active(&vcpu->wait));
        cancel_hv_timer(apic);
        apic_timer_expired(apic, false);

        if (apic_lvtt_period(apic) && apic->lapic_timer.period) {
                advance_periodic_target_expiration(apic);
                restart_apic_timer(apic);
        }
out:
        preempt_enable();
}
```

## 6.2. hrtimer 到期的外部中断

### 6.2.1. 整体流程

```cpp
// hrtimer 到期处理函数
apic_timer_fn()  // hrtimer 到期处理函数
 ├─ apic_timer_expired(apic, false); // 已经到期了
 |   ├─ set_target_expiration(apic, count_reg); //
 ├─ lapic_is_periodic(apic) // 周期性
 |   ├─ advance_periodic_target_expiration(apic); // 设置周期性的目标过期时间
 |   ├─ hrtimer_add_expires_ns(&ktimer->timer, ktimer->period); // 修改 hrtimer, 以便再次重启使用
 |   └─ return HRTIMER_RESTART; // 周期性的, 所以重启 hrtimer
 └─ return HRTIMER_NORESTART; // one-shot/tscdeadline 模式, 不重启 hrtimer
```

### 6.2.2. apic_timer_fn(): hrtimer 到期的响应函数

hrtimer 到期后的响应函数

```cpp
static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)
{
        struct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);
        struct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);
        // 到期处理函数
        apic_timer_expired(apic, true);
        // 周期性
        if (lapic_is_periodic(apic)) {
                // 设置周期性的下一次目标超时时间
                advance_periodic_target_expiration(apic);
                // 修改 hrtimer
                hrtimer_add_expires_ns(&ktimer->timer, ktimer->period);
                // 重启 hrtimer
                return HRTIMER_RESTART;
        } else
                // 一次性或 tscdeadline, 不重启
                return HRTIMER_NORESTART;
}
```


## 6.3. apic_timer_expired(): apic timer 已经到期处理

无论`hvtimer(preemption timer)`还是`sw timer`, 都可能会调用到

```cpp
static void apic_timer_expired(struct kvm_lapic *apic, bool from_timer_fn)
{
        struct kvm_vcpu *vcpu = apic->vcpu;
        struct kvm_timer *ktimer = &apic->lapic_timer;
        // 如果有 pending, 返回
        if (atomic_read(&apic->lapic_timer.pending))
                return;
        // tscdeadline 模式或者 hv timer 在使用
        if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
                // 设置 expired_tscdeadline
                ktimer->expired_tscdeadline = ktimer->tscdeadline;
        // 不是从 timer 回调函数过来的 并且 apicv 激活
        if (!from_timer_fn && vcpu->arch.apicv_active) {
                WARN_ON(kvm_get_running_vcpu() != vcpu);
                // 注入 pending timer irq
                kvm_apic_inject_pending_timer_irqs(apic);
                return;
        }
        // vcpu 使用 posted timer interrupt
        if (kvm_use_posted_timer_interrupt(apic->vcpu)) {
                // 等它到期
                if (apic->lapic_timer.timer_advance_ns)
                        __kvm_wait_lapic_expire(vcpu);
                // 注入 pending timer irq
                kvm_apic_inject_pending_timer_irqs(apic);
                return;
        }
        // pending 加 1
        atomic_inc(&apic->lapic_timer.pending);
        // 设置 pending
        kvm_set_pending_timer(vcpu);
}
```

```cpp
static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)
{
        struct kvm_timer *ktimer = &apic->lapic_timer;

        kvm_apic_local_deliver(apic, APIC_LVTT);
        //
        if (apic_lvtt_tscdeadline(apic)) {
                // tscdeadline 设为 0
                ktimer->tscdeadline = 0;
        } else if (apic_lvtt_oneshot(apic)) {
                // tscdeadline 设为 0
                ktimer->tscdeadline = 0;
                // 目标过期时间设为 0
                ktimer->target_expiration = 0;
        }
}
```

```cpp
int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)
{
        // 获取 lvt 寄存器值, 这里是 LVT timer 寄存器
        u32 reg = kvm_lapic_get_reg(apic, lvt_type);
        int vector, mode, trig_mode;

        if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
                // lvtt 的 vector
                vector = reg & APIC_VECTOR_MASK;
                // lvtt 的 mode
                mode = reg & APIC_MODE_MASK;
                // lvtt 的 trig_mode
                trig_mode = reg & APIC_LVT_LEVEL_TRIGGER;
                // lapic 接收中断
                return __apic_accept_irq(apic, mode, vector, 1, trig_mode,
                                        NULL);
        }
        return 0;
}
```

`kvm_apic_local_deliver()`用于传递中断到 lapci 相应功能单元, `__apic_accept_irq`函数在`中断虚拟化`有分析

```cpp
void kvm_set_pending_timer(struct kvm_vcpu *vcpu)
{
        // 设置 vcpu->requests 中的 KVM_REQ_PENDING_TIMER 位为 1
        kvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);
        // 唤醒这个 vcpu
        kvm_vcpu_kick(vcpu);
}
```



# 7. trace

## 7.1. 使用 ftrace

```
cd /sys/kernel/debug/tracing/
echo nop > current_tracer
echo 0 > tracing_on
echo ':mod:kvm' > set_ftrace_filter
echo ':mod:kvm_amd' >> set_ftrace_filter
echo ':mod:kvm_intel' >> set_ftrace_filter
echo > set_graph_function
echo > set_ftrace_pid
echo pvclock_gtod_notify > set_ftrace_notrace
echo 1 > tracing_on
echo function_graph > current_tracer
```

如果效果不明显, 使用下面类似的

```
cd /sys/kernel/debug/tracing/
echo nop > current_tracer
echo 0 > tracing_on
echo > set_graph_function
echo > set_ftrace_pid
echo > set_ftrace_filter
echo vcpu_enter_guest > set_graph_function
echo handle_exit >> set_graph_function
echo kvm_emulate_wrmsr >> set_graph_function
echo kvm_set_lapic_tscdeadline_msr >> set_graph_function
echo kvm_cpu_has_pending_timer >> set_graph_function
echo kvm_inject_pending_timer_irqs >> set_graph_function
echo pvclock_gtod_notify > set_ftrace_notrace
echo 1 > tracing_on
echo function_graph > current_tracer
```


使用 `kvm-unit-test` 的 vmexit 中的`tscdeadline`和`tscdeadline_immed`, 当然也可以自己编写`kvm-unit-test`测试

- intel 还涉及`preemption timer`和`posted interrupt`
        - intel 启用/禁用`preemption timer`会有影响
- AMD 也有`posted interrupt`, 但是没有`preemption timer`, 但是 AMD 有 avic
        - AMD 启用/禁用 avic 影响到 apicv, 进而影响 posted interrupt

### 7.1.1. tscdeadline_immed

### 7.1.2. tscdeadline

1. 仅仅打开 tscdeadline, 将代码修改下, 只执行一次

```diff
diff --git a/Makefile b/Makefile
index 0e21a49..625ed48 100644
--- a/Makefile
+++ b/Makefile
@@ -50,7 +50,8 @@ include $(SRCDIR)/$(TEST_DIR)/Makefile

 COMMON_CFLAGS += -g $(autodepend-flags) -fno-strict-aliasing -fno-common
 COMMON_CFLAGS += -Wall -Wwrite-strings -Wempty-body -Wuninitialized
-COMMON_CFLAGS += -Wignored-qualifiers -Werror
+#COMMON_CFLAGS += -Wignored-qualifiers -Werror
+COMMON_CFLAGS += -Wignored-qualifiers

 frame-pointer-flag=-f$(if $(KEEP_FRAME_POINTER),no-,)omit-frame-pointer
 fomit_frame_pointer := $(call cc-option, $(frame-pointer-flag), "")
diff --git a/x86/run b/x86/run
index 8b2425f..a56f822 100755
--- a/x86/run
+++ b/x86/run
@@ -37,7 +37,8 @@ else
        pc_testdev="-device testdev,chardev=testlog -chardev file,id=testlog,path=msr.out"
 fi

-command="${qemu} --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
+#command="${qemu} --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
+command="${qemu} -cpu host,-x2apic --no-reboot -nodefaults $pc_testdev -vnc none -serial stdio $pci_testdev"
 command+=" -machine accel=$ACCEL -kernel"
 command="$(timeout_cmd) $command"

diff --git a/x86/vmexit.c b/x86/vmexit.c
index 47efb63..4cf64a6 100644
--- a/x86/vmexit.c
+++ b/x86/vmexit.c
@@ -462,6 +462,7 @@ static void wr_ibpb_msr(void)
 }

 static struct test tests[] = {
+/*
        { cpuid_test, "cpuid", .parallel = 1,  },
        { vmcall, "vmcall", .parallel = 1, },
 #ifdef __x86_64__
@@ -474,7 +475,9 @@ static struct test tests[] = {
        { outl_elcr_kernel, "outl_to_kernel", .parallel = 1 },
        { mov_dr, "mov_dr", .parallel = 1 },
        { tscdeadline_immed, "tscdeadline_immed", has_tscdeadline, .parallel = 1, },
+*/
        { tscdeadline, "tscdeadline", has_tscdeadline, .parallel = 1, },
+/*
        { self_ipi_sti_nop, "self_ipi_sti_nop", .parallel = 0, },
        { self_ipi_sti_hlt, "self_ipi_sti_hlt", .parallel = 0, },
        { self_ipi_tpr, "self_ipi_tpr", .parallel = 0, },
@@ -496,6 +499,7 @@ static struct test tests[] = {
        { rd_tsc_adjust_msr, "rd_tsc_adjust_msr", .parallel = 1 },
        { NULL, "pci-mem", .parallel = 0, .next = pci_mem_next },
        { NULL, "pci-io", .parallel = 0, .next = pci_io_next },
+*/
 };

 unsigned iterations;
@@ -534,7 +538,8 @@ static bool do_test(struct test *test)

        do {
                tsc_eoi = tsc_ipi = 0;
-               iterations *= 2;
+               //iterations *= 2;
+               iterations = 1;
                t1 = rdtsc();

                if (!test->parallel) {
@@ -544,7 +549,8 @@ static bool do_test(struct test *test)
                        on_cpus(run_test, func);
                }
                t2 = rdtsc();
-       } while ((t2 - t1) < GOAL);
+       //} while ((t2 - t1) < GOAL);
+       } while (0);
        printf("%s %d\n", test->name, (int)((t2 - t1) / iterations));
        if (tsc_ipi)
                printf("  ipi %s %d\n", test->name, (int)(tsc_ipi / iterations));
```


2. 测试有没有 preemption timer 两种情况的

```diff
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 4ce2ddd..4d769ef 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -118,9 +118,12 @@ static bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)

 bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
 {
+       return false;
+/*
        return kvm_x86_ops.set_hv_timer
               && !(kvm_mwait_in_guest(vcpu->kvm) ||
                    kvm_can_post_timer_interrupt(vcpu));
+*/
 }
 EXPORT_SYMBOL_GPL(kvm_can_use_hv_timer);
```

#### 7.1.2.1. Intel 禁用 preemption timer

```

```

#### 7.1.2.2. Intel 启用 preemption timer

```

```

#### 7.1.2.3. AMD 启用 avic

```

```

#### 7.1.2.4. AMD 禁用 avic



两种










```cpp
 65)               |        kvm_set_lapic_tscdeadline_msr [kvm]() {
 65)               |          __start_apic_timer [kvm]() {
 65)               |            restart_apic_timer [kvm]() {
 65)   0.124 us    |              kvm_can_use_hv_timer [kvm]();
 65)               |              vmx_set_hv_timer [kvm_intel]() {
 65)   0.128 us    |                kvm_read_l1_tsc [kvm]();
 65)   0.389 us    |              }
 65)               |              apic_timer_expired [kvm]() {
 65)   0.138 us    |                kvm_get_running_vcpu [kvm]();
 65)               |                kvm_apic_local_deliver [kvm]() {
 65)               |                  __apic_accept_irq [kvm]() {
 65)               |                    vmx_deliver_posted_interrupt [kvm_intel]() {
 65)   0.162 us    |                      kvm_get_running_vcpu [kvm]();
 65)   0.413 us    |                    }
 65)   0.713 us    |                  }
 65)   0.943 us    |                }
 65)   1.459 us    |              }
 65)               |              cancel_hv_timer.isra.40 [kvm]() {
 65)   0.125 us    |                vmx_cancel_hv_timer [kvm_intel]();
 65)   0.405 us    |              }
 65)   3.083 us    |            }
 65)   3.329 us    |          }
 65)   3.576 us    |        }
```

可以看到`tscdeadline_immed`是直接




http://chinaunix.net/uid-25739055-id-4092821.html

