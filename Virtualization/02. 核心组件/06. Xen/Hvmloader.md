
本页面的目的是解释 HVM 虚拟机的域构建器如何使用 tools/firmware/hvmloader 来创建必要的信息, 以便让未经修改的客户机虚拟机能够在 Xen 中运行.

# 声明

请注意, 这里提供的信息非常不稳定, 是针对 Xen 4.x 不稳定版本编写的. ROMBios 不会被解释, 因为它将在短期内消失. 最后, 我不是该主题的专家, 因此如果您有任何问题, 请随时向 xen-devel 邮件列表发送邮件.

# 概述

在 HVM 情况下,"PV 内核" 实际上是 hvmloader, 它根本不是 PV.hvmloader 的任务是加载 qemu 将用来构建必要环境的所有必要信息, 以 "欺骗" 未经修改的客户机, 使其认为它实际上是在物理机上运行. 总而言之, hvmloader 基本上只是填充以下数据结构:

- 启动信息页(不确定是否存在于 hvm 中)
- 共享信息页(不确定是否存在于 hvm 中)
- BIOS(在启动期间的实模式下是必需的), 这包括中断向量表(IVT).
- 在 qemu 术语中, "内核" 映像位于 /usr/lib/xen/boot/hvmloader.

# 详细信息

BIOS 由 hvmloader 提供, BIOS 是 hvmloader 中的一个二进制大块, 它被加载到客户机物理空间的正确地址. 它不是由 qemu 提供的, 尽管它显然需要与 qemu 协同工作. 目前, Xen 使用其独立的 BIOS(rombios, 最初来自 bochs 项目), 并且正在转向 SeaBIOS, 这恰好也是 qemu 上游和 KVM 的 BIOS. 有关与上游 qemu 和 SeaBIOS(Xen 的未来)合作的信息, 请参阅: QEMU Upstream.

当 hvmloader 完成时, 它会跳转到 BIOS 入口点. 从这一点开始, 事情看起来大多像本地机器启动. Qemu 将 hvmloader 二进制大块用作内核(因此在描述文件中有内核参数), 当构建域时, 然后它跳转到客户机内核(这是通过 qemu 提供的块设备完成的, 用于连接到客户机内核映像或使用 el torito 的 CDROM).

QEMU
QEMU 在 Xen 中非常重要, 因为它提供了运行未经修改的客户机的能力, 它通过欺骗 qemu 客户机, 使其认为它实际上是在物理机上运行, 因此 qemu 负责以下内容:

- 物理到伪物理地址转换
- 与主机硬件的模拟设备通信
- 系统调用到超调用的转换
- 更多(我仍然没有完整的画面)

 设备模型
目前, Xen 使用一个修改过的(精简的)qemu 版本, 称为 qemu-dm. 它的任务是作为一个用户空间进程运行, 并使用模拟设备与客户机和主机进行通信. 因此, 一般来说, 所有 x86 上的设备访问都是通过内存映射或 I/O 映射的读写操作完成的(包括像 PCI CFG 空间访问以及访问特定设备上的寄存器等内容). 这个过程的工作方式如下:

在 HVM 客户机中, 我们可以捕获任何这样的读写操作.
对于内存映射 I/O, 我们通过影子页 (见下文) 表或 HAP 来实现, 基本上是将这些区域标记为未映射, 并在 hypervisor 的页面错误处理程序中解决.
对于 I/O 映射 I/O,VMEXIT 条件基于 VMControlStructure(VMCS)中的标志, 这些标志会在客户机执行 I/O 操作时触发. 当调用某些特权指令时, QEMU 会捕获这些指令, 将指令更改为参数, 并调用 VMexit. 这将切换到主机 CPU 状态, 它将做出适当的决策. 如果我的最后一句话不正确或不准确, 请纠正.
因此, 我们现在处于 hypervisor 中, 我们知道客户机在一个特定指令上捕获, 试图执行某种 I/O 操作.
因此, hypervisor 模拟该指令, 并确定它是读操作还是写操作, 它的大小是多少, 地址是什么, 值是什么等等.
这被封装为一个 IOREQ, 并放置在一个共享内存环中, 该环与相关的用户空间 qemu 进程共享.
qemu-dm 如何将信息传递给 VM?
qemu 的主要功能基本上是从该共享环中读取 IOREQs, 并处理位于该地址的任何设备的仿真.
设备仿真 ("设备模型") 为各种地址注册处理程序, 核心 qemu 代码进行跟踪并调用正确的处理程序.
在 hypervisor 和 qemu 之间有一个事件通道, 以便 qemu 知道何时查看环以获取更多要处理的内容.
一旦仿真完成, qemu 就会向 hypervisor 发出信号, 后者将在捕获指令之后的点恢复 VCPU(它在整个过程中一直被阻塞).

 影子页
这是从 < Xen Hypervisor 权威指南>中提取的快速解释. 每当客户机尝试更新 CR3(CR3 是什么?), 或者修改页表时, CPU 就会陷入 hypervisor, 允许它模拟更新.

 嵌套页表
NPT. 每个客户机都被允许直接操作 CR3, 然而, 该寄存器的语义被修改了. 客户机看到一个完全虚拟化的地址空间, 并且只在 hypervisor 分配的范围内设置映射. Hypervisor 操纵 MMU 来操纵映射, 但在运行时不需要介入. 这是通过一个标记化的转换后备缓冲区 (TTLB) 实现的. 每个 TLB 条目都有一个与之关联的虚拟机标识符, 并且只在创建它的虚拟机内有效. Intel 和 AMD 芯片都包含这样的 TTLB, 但实现方式不同.

CR3
当启用虚拟寻址时, 即当 CR0 中的 PG 位被设置时, 使用的 CPU 寄存器. CR3 使处理器能够通过定位当前任务的页目录和页表, 将虚拟地址转换为物理地址. 通常, CR3 的高 20 位成为页目录基寄存器(PDBR). 更多信息请参考相关资料.

VMX 操作
处理器对虚拟化的支持由一种称为 VMX 操作的处理器操作形式提供. VMX 操作有两种类型: VMX 根操作和 VMX 非根操作. 一般来说, VMM 将在 VMX 根操作中运行, 而客户机软件将在 VMX 非根操作中运行. VMX 根操作和 VMX 非根操作之间的转换称为 VMX 转换. VMX 转换有两种类型. 进入 VMX 非根操作的转换称为 VM 入口("VMCALL"). 从 VMX 非根操作到 VMX 根操作的转换称为 VM 退出(VMEXIT). 有关详细信息, 请参阅附带的文件(没有文件名扩展名的 pdf 文件).

# reference

2016 年

https://wiki.xenproject.org/wiki/Hvmloader
