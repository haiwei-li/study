
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 折叠的方式](#1-折叠的方式)
- [2. 折叠打开与折合](#2-折叠打开与折合)
- [3. 参考](#3-参考)

<!-- /code_chunk_output -->

## 1. 折叠的方式

vim 中提供了 6 种折叠方式

```
manual       手工定义折叠
indent       更多的缩进表示更高级别的折叠(常用)
expr         用表达式来定义折叠
syntax       用语法高亮来定义折叠
diff         对没有更改的文本进行折叠
marker       对文中的标志折叠(常用)
```

可用选项 'foldmethod' 来设定折叠方式: set fdm=XX.

注意, 每一种折叠方式不兼容, 即: 你不能用 expr 又用 marker 方式.

目前我一般使用的都是 indent 比较多.

使用时, 用 `:set fdm=indent` 命令来设置成 marker 折叠方式.

```
set foldmethod=indent
```

在 `.vimrc` 文件中添加设置, 可以使得每次打开 vi 都启动折叠方式. 如添加 `:set fdm=syntax`.

## 2. 折叠打开与折合

选取了折叠方式后, 我们就可以对某些代码实施我们需要的折叠了.

如果使用了 indent 方式, vim 会自动的对大括号的中间部分进行折叠, 我们可以直接使用这些现成的折叠成果.

indent 对应的折叠代码有:

```
zc     折叠
zC     对所在范围内所有嵌套的折叠点进行折叠
zo     展开折叠
zO     对所在范围内所有嵌套的折叠点展开
[z     到当前打开的折叠的开始处.
]z     到当前打开的折叠的末尾处.
zj     向下移动. 到达下一个折叠的开始处. 关闭的折叠也被计入.
zk     向上移动到前一折叠的结束处. 关闭的折叠也被计入.
za     当光标在关闭折叠上时, 打开之. 在打开折叠上时, 关闭之.
zA     和 za 类似, 不过对当前折叠和其嵌套折叠都有效.
zv     打开当前光标所在折叠, 仅打开足够的折叠使光标所在的行不被折叠.
```

使用时在大括号中间输入以上命令.

当使用 marker 方式时, 需要用标计来标识代码的折叠, 系统默认是{{{和}}}, 最好不要改动.

可以使用下面的命令来创建和删除折叠:

```
zf   创建折叠, 比如在 marker 方式下:
    zf56G                 创建从当前行起到 56 行的代码折叠;
    10zf 或 10zf+或 zf10↓    创建从当前行起到后 10 行的代码折叠.
    10zf-或 zf10↑          创建从当前行起到之前 10 行的代码折叠.
    在括号处 zf%            创建从当前行起到对应的匹配的括号上去((), {}, [], 等).
zd       删除 (delete) 在光标下的折叠. 仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效.
zD   循环删除 (Delete) 光标下的折叠, 即嵌套删除折叠.
     仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效.
zE   除去 (Eliminate) 窗口里"所有"的折叠.
     仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效.
zR   打开所有折叠
zM   关闭所有折叠
zE   删除所有的折叠标签. 仅当 manual 和 marker 折叠方法下有效.
```

zr 和 zm  一层一层打开折叠和一层一层关闭折叠, 这两个命令会递减和递增一个叫 foldlevel 的变量. 如果你发现 zm 和 zr 不灵了, 那有可能是你连续按的 zr 或 zm 次数多了, 只要多按几次让 foldlevel 回到正常状态即可. 执行以下 zR 和 zM 也可直接让 foldlevel 回到正常状态.

zR 和 zM  打开/关闭所有折叠, 设置 foldlevel 为最高级别. 关闭所有折叠, 设置 foldlevel 为 0.

## 3. 参考

在 vim 中运行 :h Folding 命令, 查看折叠的帮助文档.