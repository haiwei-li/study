

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 如何高效地调试内核](#1-如何高效地调试内核)
- [2. kprobe 是什么](#2-kprobe-是什么)
- [3. kprobe 用来干什么](#3-kprobe-用来干什么)
- [4. kprobe 的机制和组成](#4-kprobe-的机制和组成)

<!-- /code_chunk_output -->

# 1. 如何高效地调试内核

如何高效地调试内核?

1. `printk` 是一种方法, 但是 `printk` 终归是毫无选择地全量输出, 某些场景下不实用, 于是你可以试一下`tracepoint`, **只有使能** `tracepoint` 机制的时候才输出.
2. 对于傻傻地放置 `printk` 来输出信息的方式, `tracepoint` 是个进步, `tracepoint` 只是内核在**某些特定行为**(比如进程切换)上部署的一些**静态锚点**, 有些锚点**并不一定是你需要的**, 但是你仍然需要自己部署`tracepoint`, **重新编译内核**.
3. 那么 `kprobe` 的出现就很有必要了, 它可以在运行的内核中**动态插入探测点**, 执行你**预定义的操作**.

# 2. kprobe 是什么

`kprobe` 提供了一种方法, 能够在**不修改现有代码**的基础上, 灵活的跟**踪内核函数**的执行. 它提供了一个**强行进入任何内核例程**并从中断处理器无干扰地收集信息的接口. 使用 `Kprobe` 可以收集**处理器寄存器**和**全局数据结构**等调试信息. 开发者甚至可以使用 `Kprobe` 来**修改**寄存器值和全局数据结构的值.

有了它, 开发者或调试人员**不再**需要**重编译**、**安装新内核**、**重启动**等烦人的步骤.

kprobes 出现了非常长的时间,最早是 2.6.9 版本中, 最早能够追溯到 2004 年, 距离现在 15 年, 一直没有为人所知, 但却是隐藏在诸多技术后的一个**基础组件**, 例如`ftrace`、`perf`、`SystemTap`、`LTTng`, 还有`ebpf`.

kprobe 即`kernel probe`, 是一种 debug 机制, 它是由**IBM**开发的, 最初计划用来和另外一个工具`DProbes`配套使用的, 但是只有 kprobe 被合并到 mainline 了而 Dprobe 没有被接受, 不过也成就了它现在的**trace 基础地位**.

# 3. kprobe 用来干什么

kprobe 通常被用来**查找性能瓶颈**, **记录指定的事件**, 用来 trace,它理论上能够监视任何的事件, 但是有一点: 它**实现不了 gdb 的 watch 功能**.

一般, **使用 kprobe**的**程序**实现作**一个内核模块**, 模块的**初始化**函数来负责**安装探测点**, **退出**函数**卸载**那些被安装的**探测点**. kprobe 提供了接口函数(APIs)来安装或卸载探测点. 目前 kprobe 已经支持了多种 CPU 架构.

**裸的 kprobe**使用起来有些复杂, 它需要**单独编写内核模块**, 所以为了降低使用复杂度, kprobe 不停的寻找和其他能够**配合的框架**, 目前它主要作为`ftrace`、`perf`、`LTTng`、`ebpf`, `SystemTap`等框架和工具的**后端存在**, 主要用来做**日志**了, 看起来它也混的挺憋屈的, 有强大的功能就是没人用.

# 4. kprobe 的机制和组成

它的基本工作机制是: 用户**指定一个探测点**, 并把一个用户定义的**处理函数关联**到该**探测点**, 当内核执行到该探测点时, 相应的关联函数被执行, 然后**继续执行正常的代码路径**.

`kprobe` 实现了三种类型的探测点 :

* `kprobes` 是可以被插入到内核的**任何指令位置**的探测点, 最基本的 kprobe, 能够在**指定代码执行前**、**执行后**进行探测, 但此时**不能**访问被**探测函数内**的相关变量信息;
* `jprobes` 则只能被插入到一个**内核函数的入口**, 用于探测**某一函数的入口**, 并且能够访问对应的**函数参数**; 类似于 kprobes 中的`pre_handler`, 但是有个优点, 不需要从寄存器中提取各种参数, 直接就定义它的类型和原始函数的参数一致就可以直接使用了; 而最新的内核中**jprobe**因为它的优势不明显**已经被干掉了**, 原有的使用者可以迁移到`trace-event`或`perf-probe`
* `kretprobes` 则是在指定的内核**函数返回时**才被执行; 用于完成指定**函数返回值**的探测功能.

<table>
    <tr>
        <th>类型</th>
        <th>插入位置</th>
        <th>用途</th>
    </tr>
    <tr>
        <td>kprobes</td>
        <td>
            函数的任何位置(除了黑名单函数之外)
        </td>
        <td>
            记录日志
        </td>
    </tr>
    <tr>
        <td>jprobes</td>
        <td>
            函数的开始位置
        </td>
        <td>
            查看传入参数
        </td>
    </tr>
    <tr>
        <td>kretprobes</td>
        <td>
            函数的结束位置
        </td>
        <td>
            查看返回参数
        </td>
    </tr>
</table>

其中最基本的就是 kprobes 机制, jprobes 以及 kretprobes 的实现都依赖于 kprobe, 但其代码的实现都很巧妙, 强烈建议每一个内核爱好者阅读.
