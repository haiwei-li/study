
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 物理层: 设备连接方式(星型方式)](#1-物理层-设备连接方式星型方式)
- [2. 链路层: mac 和集线器或交换机](#2-链路层-mac-和集线器或交换机)
- [3. 网络层: IP 地址](#3-网络层-ip-地址)
  - [3.1. IP 从哪里来](#31-ip-从哪里来)
  - [3.2. IP 如何路由](#32-ip-如何路由)
  - [3.3. IP 和链路层的关系](#33-ip-和链路层的关系)
  - [3.4. IP 冲突和动态分配](#34-ip-冲突和动态分配)
- [4. 传输层: 端口](#4-传输层-端口)
- [5. 应用层](#5-应用层)
- [6. 完整的通信过程](#6-完整的通信过程)

<!-- /code_chunk_output -->

https://segmentfault.com/a/1190000008741770

本文采用 TCP/IP 详解里的 5 层结构, 即物理层、链路层、网络层、传输层和应用层, 并且只讨论以太网和常见的组网方式, 不考虑特殊场合的应用.

# 1. 物理层: 设备连接方式(星型方式)

总结: **网线或者无线方式, 物理连接**, 环形网络或星型网络, 问题在于: 发送方无法知道发给谁, 接收方也无法区分谁发来的

**物理层**就是如何将**多台设备连起来**, 不管是**有线**还是**无线**的**方式**, 都是让设备之间能交换数据, 所以物理上的连通是必不可少的, 不然就没法通信了.

如果只有一台设备, 就不需要和别人通信;  两台呢?直接弄根线连上就可以通信了.

三台呢, 怎么连? 可以像下面这样, 三根网线搞定

```
               +-------+
    +--------->| Node2 |<---------+
    |          +-------+          |
    |                             |
    ↓                             ↓
+-------+                     +-------+
| Node1 |<------------------->| Node3 |
+-------+                     +-------+
```

四台呢, 这么连?

```
                +-------+
    +---------->| Node2 |<----------+
    |           +-------+           |
    |                               |
    ↓                               ↓
+-------+                       +-------+
| Node1 |                       | Node3 |
+-------+                       +-------+
    ↑                               ↑
    |                               |
    |           +-------+           |
    +---------->| Node4 |<----------+
                +-------+
```

虽然四根网线搞定, 但带来至少两个问题:

- **Node2**和**Node4**之间怎么通信? 首先肯定得经过 Node1 或者 Node3, 就算能根据网络繁忙程度进行智能的选择, **Node1**和**Node3**也需要把部分精力用在帮忙**转发数据包**上, 就算转发消耗的系统资源可以忽略不计, 但 Node1 和 Node3 之间的通信呢?由于**带宽有限**, **Node1 和 Node3**之间的**通信**肯定会受 Node1 或者 Node3 之间通信的影响. 想象一下, 寝室里面有四个人, A 和 C 之间传一个电影, 导致 B 和 D 之间打局域网游戏卡的要死, 你说 B 和 D 恼火不?

- Node2 和 Node4 关机之后, Node1 或者 Node3 之间就没法通信了, 也就是说如果这个环里面有**两台设备下线**, 那么就会变成两个单独的网络

改进成这样呢?

```
                +-------+
    +---------->| Node2 |<----------+
    |           +-------+           |
    |               ↑               |
    ↓               |               ↓
+-------+           |           +-------+
| Node1 |<----------+---------->| Node3 |
+-------+           |           +-------+
    ↑               |               ↑
    |               ↓               |
    |           +-------+           |
    +---------->| Node4 |<----------+
                +-------+
```

确实解决了上面的那两个问题, 新的问题出现了:  **一台电脑**要连**三根网线**, 总共是 3+2+1=6 根网线, 看起来还好, 但想象一下有 10 台机器, 那就是 10+9+8+7+6+5+4+3+2+1=55 根, 根本没法想象应该怎么布线.

很明显这种只靠网线的办法在局域网中就行不通, 更别说将世界上所有设备互联了.

于是人们想到引入一种新的设备, 用来负责连接各个机器, 机器只要和这个新的设备打交道就可以了, 于是有了下面这样的连接方式:

```
                +-------+
                | Node2 |
                +-------+
                    ↑
                    |
                    ↓
               +--------+
+-------+      |        |      +-------+
| Node1 |<---->| Device |<---->| Node3 |
+-------+      |        |      +-------+
               +--------+
                    ↑
                    |
                    ↓
                +-------+
                | Node4 |
                +-------+
```

这样看起来就简洁多了, 并且往这个网络中添加机器也非常简单, 牵一根线到中心的那个设备就可以了. 当然这样的组网也有缺点, 那就是**中心的那个设备挂了**后, **整个网络就不通**了, 所以**中心设备的功能**一定要**越简单越好**, 这样就能保证其稳定性.

其实上面的这**两种连接方式**就是我们常说的**环形网络**和**星形网络**, 环形网络不常见, 只在某些特殊场合使用, 而**星形网络**就是我们现在常见的组网方式.

有了星形网络后, **物理连接**上没问题了, 那么接下来的问题就是**怎么通信**

- Node1 要发数据给 Node4, 肯定要**先**发给中间的**Device**, 那么 Device**怎么知道要发**给 Node4, 而不是 Node3 呢?

- Node1 和 Node3 都给 Node4 发数据, Node4**怎么区分**数据是谁发过来的呢?

这时候**链路层**就登场了.

# 2. 链路层: mac 和集线器或交换机

总结: **以太网协议, 增加了具有 mac 地址的网卡和集线器(消息群发, 网卡处理)或交换机(网卡 mac 地址和交换机端口对应关系, 即转发表**), 主要问题在于: 设备过多导致**交换机转发表太大**(性能影响), **设备位置变化**带来的频繁的**转发表更新**(及时性保证和更新的网络请求占据带宽), 网卡的 mac 地址不变带来的隐私问题

为了解决上面物理层遇到的问题, 聪明的人们设计了一种**链路层协议**, 叫**以太网协议**.

因为机器之间要通过**网线通信**, 那么每台机器上都有一个**处理数据传输的硬件**, 这个硬件就是**网卡**, 在**以太网协议(！！！**)中, 要求**每个网卡**都要有**一个地址**, 就是我们常说的**网卡(mac)地址(！！！mac 地址指的是网卡的！！！**), 并且这个地址**必须唯一**, 不能冲突.

为了解决**网卡地址唯一**这个问题, 人们将**网卡地址**拆成**两个部分(！！！**), 第一部分是**厂商的 ID**, 另一部分由**厂商自己控制**, 由于厂商的 ID 是唯一的, 所以只要厂商自己不生产同样 mac 地址的网卡, 那么所有厂商的网卡地址都将唯一.

有了 mac 地址后, Node1 给 Node4 发的**数据包**中就可以带上**各自的 mac 地址(两个 mac 地址！！！**), 这样就能唯一的标识这个包是由**谁发给谁**的了, 这样的数据包就是**以太网数据包**, 当然以太网协议还有其它的字段, 但这两个字段是最重要的.

现在知道**数据包**是由**谁发给谁**的了, 另一个问题来了, **中心**的那个 Device 收到 Node1 发给 Node4 的包之后, 怎么知道**Node4 是连接到哪个端口**上的呢?

最开始人们采用了一种简单粗暴的方法, 那就是**群发**, 由于中心的那个 Device**不知道 Node4 连接到哪个端口**的, 那么它就会**将数据复制多份**, 向所有端口都发一份(Node1 所在的端口除外, 因为 Device 知道数据包是从这个端口发进来的), 这样 Node4 就收到了 Node1 发过来的数据, 当然其它两个 Node 也会收到相应的数据包, 但**网卡**很老实, 发现**不是发给自己的数据包**, 就不看包里面的内容, 直接把**数据包丢弃**了.

上面这种简单粗暴的设备就是我们常说的**集线器(Hub, ！！！只是进行数据群发！！！**), 从它的工作方式我们可以看出它有两个缺点:

**数据不安全(！！！**):  Node1 发给 Node4 的数据会被发送到 Node2 和 Node3 上去, 虽然网卡默认情况下会丢弃该数据包, 但是也可以**设置网卡为混杂模式(！！！**), 从而可以**接收并处理这些数据包**.

**性能差(！！！**):  Node1 跟 Node4 通信的所有数据包都要发给 Node2 和 Node3 一份, 一方面**增加 Device 的压力**, 并且还要**占用和 Node2 及 Node3 之间的带宽**

为了解决集线器的问题, 人们发明了**交换机**, 跟集线器相比, 交换机里面多了一张**转发表**, 里面包含了**mac 地址和端口的对应关系(！！！**), 大概如下:

mac 地址 | 端口
---|---
02:42:83:06:75:13 | 2
08:00:27:03:d0:e7 | 2
ee:35:41:bb:a4:60 | 3
02:42:34:8F:0E:FE | 4

上表中, **02:42:83:06:75:13**和 08:00:27:03:d0:e7 连接在**交换机的 2 号端口(！！！**), ee:35:41:bb:a4:60 连接到 3 号端口, 02:42:34:8F:0E:FE 连接到 4 号端口.

这里 02:42:83:06:75:13 和 08:00:27:03:d0:e7 都与端口 2 相连, 表示与端口 2 连接的是一个**交换机(！！！**)或者有**多个虚拟网卡的主机(！！！**).

有了这张表之后, 交换机收到数据包之后, 就知道要从哪个端口发出去了, 于是解决了集线器的那两个问题, 那么这里又有一个问题, **这张表示从哪里来**的??

交换机在**刚启动**时, 这张表是**空**的, 当收到第一个数据包的时候, 它也不知道要从**哪个端口转发**出去, 于是它采用和集线器一样的方式**广播出去**.

当交换机**每次(！！！**)从一个端口**收到数据包**时, 都会**提取数据包里面的源 mac 地址**, 然后将这个**mac 地址**和**端口**的对应关系**添加到(或者更新)转发表**, 这样很快就会将转发表构造起来, 就算有网线换了端口, 也会及时的更新转发表.

有了**交换机**后, **局域网**是搭建起来了, 但是可以通过 N 个交换机将世界上的所有机器都连起来吗?就像下面这样:

```
                                +---------+
                                |         |        +-------+
                +-------+       | Switch3 |------->| Node5 |
                | Node2 |       |         |        +-------+
                +-------+       +---------+
                    ↑                ↑
                    |                |
                    ↓                ↓
               +---------+      +---------+      +---------+      +----------+
+-------+      |         |      |         |      |         |      |          |        +--------+
| Node1 |<---->| Switch1 |<---->| Switch2 |<---->| ....... |<---->| Switch N |------->| Node N |
+-------+      |         |      |         |      |         |      |          |        +--------+
               +---------+      +---------+      +---------+      +----------+
                    ↑                ↑
                    |                |
                    ↓                ↓
                +-------+        +-------+
                | Node3 |        | Node4 |
                +-------+        +-------+
```

答案是**否定**的. 虽然**每个 Node**都有一个**唯一 mac 地址**(UUID), 但这个 UUID 里不包含任何其它信息, 这给数据的全网传输带来了很大的问题.

想象一下我们每家每户都用一个 UUID 来标识, 没有我们现在用的地址和邮编, 那么把我家的地址给你, 叫"912FAD50-07B2-4FBA-8F65-4537ABEF5670", 请问你要怎么找到我家?如果我们是一个村的人, 那还不是特别难, 村委会把所有住户的 UUID 都收集起来, 找人的话去村委会问就行了, 如果我们不在一个国家呢?这下不好办了, 要不你家村委会特别强大, 知道世界上所有住户的 UUID, 然后告诉你下一步再去哪里问, 要不村委会没这能耐, 只能告诉你去镇上问, 镇上再让你去市里问, 最终问到一个可能类似叫国家信息中心的地方, 它告诉你地址是在美国(假设目的地是美国), 于是你得去美国的国家信息中心去问, 把相关的人问了个遍终于知道了我在哪里.

上面的方法看起来最终也能找到, 那问题在哪里呢?简单的列几条

现在世界上联网的设备大概有几十亿, 并且每年还在疯狂的增长. 要有一个机制来管理所有的这些 UUID, 并且能高效的在里面找到想要的数据, 这几乎是不可能的, **交换机的转发表都会非常大(！！！**), 性能肯定跟不上

现在移动设备已经占据了很大的份额, **位置老变来变去**, 意味着由 UUID 构成的网络拓扑结构老在发生变化, 那怎么能保证及时的将地址变化情况更新到那些管理机构呢?估计光更新的请求就把网络给撑爆了

没隐私, 走到哪里都是那个 UUID, 都有人知道你在哪里, 恐怖不?

所以在实际操作中这种办法根本不可行, 就像邮局无法根据你提供的 UUID 找到你家地址一样. 这个时候就需要一种类似于"湖南省长沙市岳麓区 xxx 路 xxx 号"的东西, 于是网络层的 IP 登场了.

# 3. 网络层: IP 地址

总结: 实现数据传输到地址(IP 地址, 设备). IPV4 地址的分配是一段一段的, 也是一级一级往下分配的, 目前已经分配完了. 发送端设备根据本地路由表(本地设备上面的), 目的是为了找到最近的路由器<邮局, 作用是转发 IP 数据包>, 然后路由器根据自己的路由表再往外转发. IP 是段划分的并且 IP 范围不会变, 所有路由表会比较小以及不需要更新; IP 地址不会变化(类似于房子), 设备变化(人), IP 地址在网络拓扑中位置不变; IP 是逻辑上的, 不与设备绑定, 所以隐私性强. IP 网络需要链路层管理, 因为涉及 IP 分配问题(IP 是逻辑上的, 不存在实体, mac 地址是实体的, 存在于网卡). 链路层协议 ARP(所以是在一个局域网内！！！)可以通过网络地址(IPV4 地址)定位 MAC 地址, 用来解决 IP 冲突. DHCP(非链路层协议)用来动态分配 IP: 设备加入广播请求分配 IP(这时候没有网络层 IP, 只能依赖链路层广播协议, 不过如果局域网有其他路由设备<转发 DHCP 数据包>, 可以将请求转发出去, 从而实现跨网段 DHCP), DHCP 服务器会分配空闲 IP 给设备(同时返回子网掩码, 默认网关等).

网络层的 IP 地址就是我们想要的类似于"湖南省长沙市岳麓区 xxx 路 xxx 号"的东西.

IP 网络用来通信, 链路层网络主要用来解决局域网内部管理工作(比如动态 IP 分配, 检查 IP 冲突), 所以还是需要链路层, 但是链路层又是不知道 IP 层信息的, 所以当数据到达一个局域网的链路层后(比如交换机这一层), 需要 ARP 协议来通过 IP 查找 mac 地址. 或者局域网通信, 经过本地路由表映射, 数据会直接走到交换机, 交换机根据 ARP 协议通过 IP 查到 mac 地址, 再通过交换机的端口的 mac 地址映射(也有可能交换机互联, 一个端口多个 mac, 不过出的端口一样), 从而一层一层找到相应设备.

网络层负责将数据包发给一个 IP 地址, 有了地址(设备), 那数据包是给谁的呢(收件人, 操作系统中哪个进程?)

## 3.1. IP 从哪里来

对于生活中的地址, 比如说湖南, 为什么要叫这个名字, 为什么管理的范围是现在这样?国家层面说了算(当然不是瞎说, 根据历史情况来定), 湖南下面要分几个市呢?湖南省自己进行划分. 地址一旦规划好, 就很稳定, 很少变, 变化的时候就是合并行政村、撤县设市、设置直辖市啊之类的.

IP 地址也差不多, 一旦分配好了就不会经常变化, 比如给湖南分了那么多的 IP 段, 那么就不会频繁的变化, 一直都是湖南的; 唯一不同的是生活中的地址没有长度限制, 而 IP 地址有长度限制, IPv4 的地址范围只有 40 亿左右(当时设计的时候觉得够用了, 结果现在悲剧了...).

既然资源有限, 那么就有分配的问题, 先到先得, 由于欧美发达, 上网的人多, 所以申请比较积极, 抢去了大部分的地址空间, 像非洲这样的, 就只抢到很少的份额. 地址分配机构也是一级一级的, 比如我是**中国电信公司**, 需要大批的 IP, 那么我就去向**负责亚太地区的机构**去申请, 如果机构发现现在有多余的, 就会直接分配地址给我, 如果没有那么多, 它会向它的上级要资源, 所以这事和申请域名、通信频道是一样的, 申请一定要积极, 不然就被别人抢去了, 等**拿到分配给我的 IP 地址段**后, 就可以**一级一级的往下**再分配下去了, 内部怎么分就看自己怎么管理了.

现在再去申请 IPv4 已经没戏了, **2011 年 IPv4 地址就被分配完**了, 现在该抢 IPv6 了, 不过 IPv6 地址空间大, 没必要那么急着抢, 并且也不是谁都能申请, 想申请都少就能申请多少的, 只能按需申请, 再说也不是免费的.

## 3.2. IP 如何路由

为了简化讨论, 这里讨论的 IP 地址都是**IPv4 公网地址**, 不考虑**内网**地址, 不考虑**NAT 转换**的情况. 同时由于网段的划分和路由是个很复杂的过程, 在这里不讨论**路由表是如何构造并更新**的.

有了**IP 地址**之后, 我们就需要一个能转发 IP 数据包的设备, 那就是路由器, 有了路由器之后, 我们的网络就变成了这样:

```
                                +---------+
                                |         |        +-------+
                +-------+       | Switch2 |<------>| Node4 |
                | Node2 |       |         |        +-------+
                +-------+       +---------+
                    ↑                ↑
                    |                |
                    ↓                ↓
               +---------+      +---------+      +---------+      +----------+        +---------+
+-------+      |         |      |         |      |         |      |          |        |         |       +--------+
| Node1 |<---->| Switch1 |<---->| Router1 |<---->| ....... |<---->| Router N |<------>| SwitchN |<----->| Node N |
+-------+      |         |      |         |      |         |      |          |        |         |       +--------+
               +---------+      +---------+      +---------+      +----------+        +---------+
                    ↑                                                                      ↑
                    |                                                                      |
                    ↓                                                                      ↓
                +-------+                                                              +----------+
                | Node3 |                                                              | Node N+1 |
                +-------+                                                              +----------+
```

有了 IP 地址后就很容易路由了, 原理跟投递邮件一模一样, 想象一下投递邮件, 假设你在上海, 要写一封信给北京的朋友, 首先得找到最近的邮局, 把信投进去, 信封上会填上收件地址和发件地址, 然后会有工作人员将信件发到下一站, 下一站会有工作人员接手再发给下一站, 经过几次中转到了上海总站, 然后由上海总站再发往北京总站, 北京总站再派工作人员**一级一级**的下发, 最终将信件送到你朋友手上.

再来看看网络中的数据包, 假设**上海的 A**要给**北京的 B**发一个数据包, 首先得根据他自己的**路由表(由自己配置！！！**)和**B 的地址**, 找到**最近的路由器**(这就跟上面找邮局是一样的, **路由器就相当于邮局**), **路由器**会根据它的**路由表**将数据包再往外发, 可能是先到上海的某个**中心路由器**, 然后再由它发给**北京的路由器**, 最后由北京的路由器**一级一级**的往下发, 最终到 B 的手中.

咋一看好像也是一级一级的转发, 那跟前面被否决的链路层交换机的转发有什么不一样呢?

**路由器**里的**路由表**要小很多: IP 是一段一段的有范围的, **整个中国**的**IP 段**可能也就**几百条**, 这几百条再被各个省分成不同的**小的 IP 段**, 那么所有省一级的 IP 段总共加起来也差不多万条的级别, 跟几十亿级的设备数量来比要小多了. 并且**IP 范围**和生活中的地址是一样的, **不怎么变化**, 不需要频繁更新.

IP 地址的位置是固定的, 不需要频繁更新: 移动设备就像是城市里的流动人口一样, 人会经常租不同的房子, 但房子本身的地址不会发生变化, 就是说**移动设备**换地方后会**换 IP**地址, 但**IP 地址**所关联的**路由器是不会变化**的, 即**IP 地址**在整个网络拓扑中的位置**不会变化**, 变化的是**设备的位置**.

更好的隐私: 由于大家都用 IP 通信, 而**IP 没有和具体的设备绑定**, 给你一个 IP 地址, 你只知道它大概位置在哪里, 但你不知道用这个 IP 上网的设备是什么(当然可以通过其它的手段知道, 但根据 IP 没法知道).

## 3.3. IP 和链路层的关系

大家都**通过 IP 地址来通信**, 但**交换机只知道链路层(！！！**), **不知道 IP 层的任何信息(！！！**), 于是设备在向另一个设备通过**IP 地址**发送数据之前(通过**交换机直接相连**的两台机器), 需要知道**对方的 mac 地址**, 这个时候就用到了**ARP 协议**, 利用该协议, 可以**根据 IP 地址得到 mac 地址**, 当然, **该协议只在局域网内有效(！！！**), 网络中的**每台设备只和当前局域网**的另一台设备**直接通信**, 想要访问**其它网络中的设备**, 需要当前网络中的**其它设备代为转发**, 具备**转发 IP 数据包功能的设备**, 我们就说它具有路由功能, 一般就是我们常说的**路由器**.

IP 网络这么好, 那我们**还需要链路层的网络吗**?**直接通过 IP 进行通信**就好了, 还要 mac 地址干嘛?答案是不行, 还是**得依赖链路层**. 因为**IP 地址是逻辑上**的东西, 所以就要考虑分配问题, 一台设备加入了当前网络, 给它分配个什么 IP 好呢?机器数量少且不怎么变化的情况下, 可以人工管理, 做到地址不冲突, 但在公共场合呢?你去了机场, 连了机场的网络, IP 怎么办?机场工作人员给你找一个空闲的填上?就算机场有那闲功夫, 专门派个人或者设备显示当前网络还有哪些 IP 是空闲的, 你也烦啊, 需要找到这个人或者设备, 并且还要自己手动配置网络 IP; 再考虑一种情况, 你坐在地铁上, 从闵行区到杨浦区, 中间要经过徐汇区, 在闵行区的时候你手机是在闵行区的网络里, 等地铁经过徐汇区的时候, 你连上了徐汇区的网络, IP 地址咋办, 到哪去找一个没被人占用的 IP 地址?那么多的人, 怎么保证不冲突?到了杨浦区的时候, 又得人工切换, 估计你都要崩溃了. 所以**网络层还是离不开链路层来完成一些它的管理工作**.

## 3.4. IP 冲突和动态分配

有了**ARP**后, 系统在手工**设置自己的 IP 之前**, 可以通过**ARP 请求**来问问**当前局域网**里面有没有**同样 IP 的机器**, 这样就可以有效的**避免 IP 冲突**.

同时为了**动态的分配 IP**, 人们想出了**DHCP 协议**, 大概过程就是, 当一个机器连进网络的时候, **先广播一下**, 问当前局域网**有没有人可以分配一个 IP**给它, 当前网络中的**DHCP 服务器**收到请求后就会**分配一个空闲的 IP**给请求的机器, 应答包中还包含了**子网掩码**和**默认网关**. 有几个问题需要注意:

由于**当前机器没有 IP**, 所以**只能依靠链路层的广播机制**, 所以它的范围**局限于当前局域网**(当然局域网的**其它设备**也可以**转发该 DHCP**请求出去, 从而实现**跨网段的 DHCP**)

**当前局域网只能有一个 DHCP 服务器(！！！**), 否则两个服务器管理的地址可能冲突

在有 DHCP 服务器的网络中也可以手动的给自己配置 IP, 只要**不使用被 DHCP 服务器管理的 IP 范围(！！！不能使用！！！**), 并且不和别人冲突就可以了

**IP 层**解决了将**一个包**从**一地址**发到**另一个地址**的问题, 但这个数据包是给谁的呢?

# 4. 传输层: 端口

总结: 实现数据包传输到接收进程(地址的收件人). 端口(逻辑抽象, 非硬件端口)唯一标识设备(IP 地址)上的进程(这个地址的收件人), 传输层就是在 IP 层基础上增加了源端口和目的端口字段(UDP 协议), TCP 在其基础上增加了收包确认以及超时重发机制(保证数据包完整性)

在生活中, 一个地址可能是一个家庭住址, 或者是一个公司, 邮件中除了包含收件地址和发件地址之外, 还需要收件人和寄件人的信息, 因为只有有了收件人的名字, 才知道把邮件交到谁的手上.

网络世界中也一样, **网络(IP)层**负责将**数据包**发到**目的地址**, 但这个数据包是给谁的呢?**机器**上运行那么多的**进程**, 哪一个才是**接收者**呢?就需要一个东西来区分这些进程, 于是就有了**端口**的概念, 如果**进程需要网络通信**, 就**向操作系统申请一个端口**, 通过这个**端口来唯一标识这个进程(！！！**).

注意: 端口是个抽象的逻辑概念, 并不是说机器上有那么多的硬件端口.

这个时候**UDP**就登场了, 它在**IP 协议**的基础上增加了**源端口**和**目的端口**字段, 这样**一个 UDP 包**就能唯一的确定是从哪台设备的哪个进程发给哪台设备的哪个进程.

有了 UDP, 就能将包发送给指定设备上的进程, 目的进程也能通过收到数据包中的源地址和端口, 发送应答包回去. 那这样是不是就搞定了呢?

想想发邮件, 是不是有邮件丢失的情况, 丢失了会怎么样?丢失后造成的情况是接收方没收到邮件, 发送方也不知道邮件丢了. 为了应对这种情况, 邮局推出了**挂号信**, 就是如果邮件丢失, 会**通知发送方**.

UDP 也有这样的问题, 当线路繁忙的时候, 路由器如果处理不过来就会将收到的包丢弃, 这时目的端收不到数据包, 发送端也不知道数据包丢了, 于是造成通信故障. 这个时候 TCP 就登场了, 它在里面增加了一些收包确认及超时重传的机制, 保证数据包能完整的发送到目的地.

就如同挂号信比平邮要贵一样, TCP 要比 UDP 的开销大, 所以对于可以接受丢包的场合, UDP 还是有一席之地.

# 5. 应用层

总结: 进程接收到数据后对数据的解析

通过**传输层**, 数据包已经完整的发送到了接收进程手中, 那么数据包里面包含了什么数据呢?应该怎么解析它呢?

想想邮件, 收件人收到之后打开邮件会看到什么?可能是一封普通的问候信, 也可能是一首诗, 有可能是中文的, 也有可能是英文的. 总之要有一定的格式, 并且是收件人能看懂的格式, 否则这封信就没有任何意义.

同样的, 收到数据包的进程打开数据包之后也需要能看懂数据包的内容, 不然该数据包就没有任何意义, 数据包的数据要能被看懂, 那就得必须有固定的格式, 这种格式就是我们常说的应用层协议, 如 ftp、http、dns、snmp 等. 发送方必须发送接收方能识别的协议格式, 比如向 http 服务器只能发送 http 请求, 如果发 ftp 请求过去的话, http 服务器就不认得, 没法处理, 只能返回错误.

数据发到目的进程手上了, 目的进程也能看懂数据的内容, 于是一个成功的通信过程就完成了.

# 6. 完整的通信过程

这里以**一个 dns(应用层协议！！！)请求**为例, 描述一下**数据包的传输过程**, 因为**dns 默认是 udp 协议**, 所以比较直观.

假设**dns 服务器**的 IP 是**8.8.8.8**, 端口是 53

1. **应用层**构造一个**DNS 包**, 然后告诉**UDP 层**发到**8.8.8.8**的**53 端口**

2. **UDP 层**收到包后, **构造一个 UDP 包**, 里面的数据就是**DNS 包的内容**, **目的端口是 53**, 源端口由操作系统分配一个(或者可以通过绑定的方式自己指定一个), 然后**告诉 IP 层**让它把这个**UDP 包**发给**8.8.8.8**

3. **IP 层**收到请求后, 就去**查询路由表(！！！**), 看这个包应该怎么出去

4. 在这种情况下, 由于**8.8.8.8**跟自己**不在一个子网**, 于是会找到**默认网关的 IP**, 同时得到自己应该**用哪个 IP(！！！**)及**哪个网卡**发包出去; 这里假设我们只有一个网卡 eth0, IP 为 192.160.64.12.

5. 构造一个**IP 包**, 里面的**数据是 UDP 的内容**, **目的 IP 是 8.8.8.8**, **源 IP 为 192.160.64.12**

6. 构造**ARP 数据包**, **源地址为 eth0 的 mac 地址**, **目的地址**为**链路层广播地址**, **广播局域网**, 获得**网关 IP(！！！**)对应的**mac 地址**

7. **通知链路层**将这个**IP 包**发给**网关对应的 mac 地址**

8. **链路层**收到请求后, 构造**以太网包**, **目的地址**为**网关的 mac 地址(！！！**), **源地址**为**eth0 的 mac 地址(！！！**), **内容**为**上面构造的 IP 包**, 然后**发送给网关(！！！**)

9. **网关收到数据包**后, 一看**目的 IP 是 8.8.8.8**, 跟自己**不在一个子网**, 于是就查看自己的**路由表**, 然后**将数据包发给下一个路由器**(发给**下一个路由器**的过程和上面的 6~8 步相同). 网关收到数据, 此时的网关先在链路层工作, 然后解析到 IP 层, 才知道目的 IP 8.8.8.8, 再确定下一个网关地址, 然后再执行第 8 步, 构造以太包, 发送给下一个网关

10. 直到这个**数据包**到了**最后一个路由器**, 该**路由器**发现**8.8.8.8**跟它**其中的一块网卡在同一个子网(！！！**), 于是**通过那块网卡直接发给 8.8.8.8**(发给 8.8.8.8 的过程和上面 6~8 步中发给网关的过程相同, 只是**目的地由网关变成了 8.8.8.8**)

11. 8.8.8.8 收到数据包一看, 发给 53 端口的, 于是就转给了 DNS 服务器进程

12. DNS 服务器进程读取包的内容后, 构造应答包, 然后根据源 IP 和源端口, 跟请求包一样的流程, 将应答包发给了请求方

>系统有**ARP 表**, 会将查到的**IP 地址**同**mac 地址**的对应关系**缓存起来**, 所以上面的过程中并**不是每次都要发 ARP 包**
