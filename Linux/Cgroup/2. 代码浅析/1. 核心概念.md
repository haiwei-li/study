
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 目的](#1-目的)
- [2. 资源划分: 子系统和节点 cgroup](#2-资源划分-子系统和节点-cgroup)
- [3. 进程分组: 通过 css_set](#3-进程分组-通过-css_set)
- [4. 进程分组 css_set 和节点 cgroup 的关系: 多对多](#4-进程分组-css_set-和节点-cgroup-的关系-多对多)
- [5. 小结](#5-小结)

<!-- /code_chunk_output -->

# 1. 目的

cgroup 最初是在 2006 年由 google 的一名工程师提出的, 目的是把一些**共同目标的进程**放在**一个组**里面, 而这个组里面的进程能**共享指定数额！！！的资源**. 而后就有了 cgroup 这个概念了.

这里就涉及了两个东西
* **资源划分**
* **进程分组**

# 2. 资源划分: 子系统和节点 cgroup

我们把**每种类型资源**叫做**子系统**, 比如**CPU 子系统**, **内存子系统**. 为什么叫做子系统呢, 因为它是从**整个操作系统的资源衍生出来**的.

然后我们创建一种**虚拟的节点**, 叫做**cgroup**, 然后这个虚拟节点可以扩展, 以树形的结构, 有**root 节点**和**子节点**. 这个**父节点**和**各个子节点**就形成了**层级**(`hierarchy`).

**每个层级 hierarchy**都可以关联**一个或者多个子系统**, 就意味着, 我们把**资源**按照类型分别**分割**到**多个 hierarchy 层级系统**中, 相应**层级系统**中的**每个节点**对**这个资源**的**占比各有不同**.

> 一个 hierarchy 可以关联多个子系统; 但一个子系统只能挂载到一个 hierarchy;

* 子系统: **每个代表了系统中可以隔离的一种资源类型**
* cgroup: **某个节点**. 既是**限制额设置节点**(`css->cgroup`对应, 表明**某种类型的子系统资源限制**), 又是**使用节点**(每个 cgroup 可以有**一种或多种类型资源**的**数额使用**, 即占比)

# 3. 进程分组: 通过 css_set

下面我们想办法把进程分组, **进程分组**的逻辑叫做`css_set`. 这里的 css 是**cgroup_subsys_state(！！！**)的缩写. 所以 **css_set** 和**进程**的关系是**一对多**的关系.

* **一个 css_set** 中有**多个 task**;

* **一个 task** 只属于**某一个 css_set**

另外, 在 cgroup 眼中, 进程叫做**task**. 这个可能是为了和内核中进程的名词区分开吧.

# 4. 进程分组 css_set 和节点 cgroup 的关系: 多对多

我们的目的是将 **一组进程** 和 **一组资源**(**每种类型子系统对应其中一个资源**, 但不一定会有所有类型的限制) 对应起来.

> 一组进程只能有一种类型的一个资源实例(这是肯定的...)

**进程分组 css_set**、**不同层级 hierarchy**中的**节点 cgroup**也都有了. 那么, 就要把**节点 cgroup**和**进程分组 css_set**进行关联, 和数据库中关系表一样. 这个是一个**多对多的关系**. 为什么呢?

* 首先, **一个节点 cgroup**可以隶属于**多个 css_set**, 这就代表着**这批 css_set**中的**进程**都拥有**这个 cgroup 所代表的资源！！！**.

* 其次, **一个 css_set**需要**多个 cgroup**. 因为**一个层级 hierarchy 的一个 cgroup**只代表**一种或者几种类型的资源限制**, 而一般**进程**是需要**多种资源的集合体**.

而**一个 task 不能**存在于**同一个 hierarchy** 的**同一个 subsystem**的**不同 cgroup** 中, 但是**一个 task** 可以存在在**不同 hierarchy** 中的**多个 cgroup** 中.

至于说怎么关联起来的, 见下面详细描述.

# 5. 小结

task(任务): cgroups 的术语中, task 就表示系统的一个进程.

cgroup(控制组): cgroups 中的资源控制都以 cgroup 为单位实现. cgroup 表示按某种资源控制标准划分而成的任务组, 包含一个或多个子系统. 一个任务可以加入某个 cgroup, 也可以从某个 cgroup 迁移到另外一个 cgroup.

subsystem(子系统): cgroups 中的 subsystem 就是一个资源调度控制器(Resource Controller). 比如 CPU 子系统可以控制 CPU 时间分配, 内存子系统可以限制 cgroup 内存使用量.

hierarchy(层级树): hierarchy 由一系列 cgroup 以一个树状结构排列而成, 每个 hierarchy 通过绑定对应的 subsystem 进行资源调度. hierarchy 中的 cgroup 节点可以包含零或多个子节点, 子节点继承父节点的属性. 整个系统可以有多个 hierarchy.

css_set:一组关联 cgroup 的集合.

cgroupfs_root:代表一个 hierarchy

cgroup_subsys:代表一个 subsystem
