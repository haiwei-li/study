机器启动到 linux 初始化是一个比较复杂并且细节性较强的过程, 大部分的实现都是由于历史遗留问题以及各种协议约定而来的, 衔接性比较强, 而且比较难跟踪, 毕竟不是 C 语言那么简单, 一个函数调用一个函数, 整个脉络比较清晰明了.

这里主要是**以 linux-3.2.55 版本内核为基础**, 将整个系统的初始化流程梳理了一下.

A、自摁下电源开关后, 是由主板自动初始化处理器信息的, 将**CS、DS、ES、SS 置为 0xffff**, 而**PC 置为 0x0000**, 由于初始化时, 处理器处于实模式, 那么也就是计算机执行的第一条指令在 0xffff0 这个位置. 计算机执行的第一条指令是来自 BIOS 的, 存储在 ROM 里面, 通过 ROM 芯片译码以读取出来执行, 该指令通常都是一条**跳转指令**, 这是由于 0xffff0 距离可访问的**内存结尾**已经不远了, 该指令可以用来跳转到具体的**BIOS 操作代码**中;

B、BIOS 开始执行后, 做了不少事情, 比如 Power On Self Test(**POST**, 开机自检), 检查 CPU 寄存器、周边芯片的状态, 以及针对动态内存、主板芯片组、显卡以及相关外围的寄存器做**初始化设置**, 并检查能够正常工作, 同时记录系统的设置值, 最重要的就是将**常驻程序库**(可以理解为**BIOS 的库, 基本上就是中断**)放置在**某段内存**中, 提供给**操作系统**或者**应用程序调用**, 比如 int 0x13 等;

> B 阶段有提到"最重要的就是将常驻程序库(可以理解为 BIOS 的库)放置在某段内存中", 放置到内存中指的什么意思?BIOS 代码不放在内存里么?如果不在内存里, 第一条执行的 BIOS 代码怎么运行?
> 1、放置到内存里面是指把这个程序库从 BIOS ROM 中加载到内存中去;
> 2、BIOS 的代码一开始是不放在 RAM 里面的;
> 3、第一条指令是硬件映射到 BIOS ROM 器件的固定位置, 里面是第一条指令, 一条跳转指令;

C、BIOS 毕竟不是系统, 完成了分内工作后, 执行**int 0x19**(前面提到的**BIOS 的常驻程序库**)将存储在**磁盘 0 头 0 道 1 扇区的 MBR**读入到**内存 0x7c00**中, 然后 BIOS 通过**跳转指令**去到**0x7c00 去执行引导程序代码**;

D、**MBR 的引导程序**对不同的 linux 版本而言各有不同, 最初 0.11 版本中, linux 的/boot/bootsect.s 自己实现了这个 MBR 引导程序, 而如今 3.2.55 的 linux 内核版本自身已经不再实现 MBR 引导程序了, 都是由**GRUB 的/stage1/stage1.S 实现的**, 具体的引导程序历史可以参考 linux 内核中的/Documentation/x86/boot.txt;

E、Linux 0.11 的引导过程就不谈了, 关于这块的资料数不胜数, 那么**GRUB 实现的引导**, 主要是给用户提供了**系统引导选择**和**引导编辑**等功能, 核心的是它通过**调用 BIOS 的常驻程序库**去将 linux**内核映像加载到内存**当中;

F、GRUB 加载完了**内核映像**, 将会跳转到内核的**文件/arch/x86/boot/header.S**里面**的\_start**开始执行, 其实\_start 也**没什么**好执行的, 就跳转到**start\_of\_setup**去设置准备给**实模式**下 main 函数运行的环境;

G、开始进入 main 函数执行, 该函数的实现在**文件/arch/x86/boot/main.c**里面, 具体可以进入去分析里面的代码, 其主要的莫过于一些**参数的准备**、**堆的初始化、CPU 的检测、BIOS 的设置**以及**内存检测**等工作(**这里使用了一些 BIOS 中断, 所以这些都是在实模式下的！！！**), 然后开始转入**保护模式**;

H、进入**保护模式**后, 将会跳转去执行**arch/x86/boot/compressed/head\_32.S**里面的**startup\_32**, 其主要设置一个**基本的环境**, 如堆栈等;

I、再往下就是调用**文件/arch/x86/boot/compressed/misc.c**里面的**decompress\_kernel**, 用来**解压内核**, 当内核被解压到内存中之后, 就可以调用它了;

J、解压完内核, 还要调用一个**startup\_32**, 这个不同于前面的那个, 这个是位于**文件/arch/x86/kernel/head\_32.S**里面的, 主要工作是**对页表进行初始化**, 并启动**内存分页功能**, **初始化 0 号进程**;

K、startup\_32 执行完了之后, 最后进入内核的主题函数**start\_kernel**, 该函数位于**文件/init/main.c**, 自此完成 linux 的最后初始化.

以上就是机器启动 linux 的整个过程, 主要是梳理了初始化实现的一个线索, 暂时不深入分析.

# 参考

http://blog.chinaunix.net/uid-26859697-id-4128236.html