
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1 Linux 进程类别](#1-linux-进程类别)
  - [1.1 进程与线程](#11-进程与线程)
  - [1.2 内核线程](#12-内核线程)
- [2 linux 进程的创建流程](#2-linux-进程的创建流程)
  - [2.1 进程的复制 fork 和加载 execve](#21-进程的复制-fork-和加载-execve)
  - [2.2 写时复制技术](#22-写时复制技术)
- [3 不同操作系统线程的实现机制](#3-不同操作系统线程的实现机制)
  - [3.1 专门线程支持的系统-LWP 机制](#31-专门线程支持的系统-lwp-机制)
  - [3.2 Linux 下线程的实现机制](#32-linux-下线程的实现机制)
  - [3.3 实现机制的区别](#33-实现机制的区别)
- [4 内核线程](#4-内核线程)
  - [4.1 内核线程与普通进程的异同](#41-内核线程与普通进程的异同)
  - [4.2 内核线程创建](#42-内核线程创建)
    - [4.2.1 kernel\_thread](#421-kernel_thread)
    - [4.2.2 kthread\_create](#422-kthread_create)
    - [4.2.3 kthread\_run](#423-kthread_run)
    - [4.2.4 内核线程的退出](#424-内核线程的退出)
- [5 总结](#5-总结)

<!-- /code_chunk_output -->

> 本文中出现的, 内核线程, 轻量级进程, 用户进程, 用户线程等概念, 如果不太熟悉, 可以参见
>
> [内核线程、轻量级进程、用户线程三种线程概念解惑(线程≠轻量级进程)](http://blog.csdn.net/gatieme/article/details/51481863)

# 1 Linux 进程类别

虽然我们在区分 Linux 进程类别,但是我还是想说**Linux 下只有一种类型的进程**, 那就是**task\_struct**, 当然我也想说**linux 其实也没有线程的概念**, 只是将那些**与其他进程共享资源的进程称之为线程**.

1. 一个进程**由于其运行空间的不同**, 从而有**内核线程**和**用户进程**的区分, **内核线程运行在内核空间**, 之所以称之为**线程**是**因为它没有虚拟地址空间(唯一使用的资源是内核栈和上下文切换时保持寄存器的空间**), 只能访问**内核的代码和数据**, 而用户进程则运行在**用户空间**, 但是可以通过**中断,系统调用等方式从用户态陷入内核态**.

2. **用户进程**运行在用户空间上,而一些通过**共享资源实现的一组进程**我们称之为**线程组**,Linux 下内核其实本质上没有线程的概念,**Linux**下**线程**其实上是**与其他进程共享某些资源的进程**而已. 但是我们习惯上还是称他们为**线程**或者**轻量级进程**

因此, **Linux 上进程**分 3 种, **内核线程**(或者叫**核心进程**)、**用户进程**、**用户线程(！！！因为内核里面的进程没有虚拟地址空间！！！**), 当然如果更严谨的, 你也可以认为**用户进程和用户线程都是用户进程**.

>关于**轻量级进程**这个概念, 其实并不等价于**线程**
>
>不同的操作系统中依据其实现的不同, 轻量级进程其实是一个不一样的概念
>
>详细信息参见 [维基百科-LWP 轻量级进程](https://en.wikipedia.org/wiki/Light-weight_process#See_also)
>
>或者本人的另外一篇博客[内核线程、轻量级进程、用户线程三种线程概念解惑(线程≠轻量级进程)](http://blog.csdn.net/gatieme/article/details/51481863)
>
>In computer operating systems, a light-weight process (LWP) is a means of achieving multitasking. In the traditional meaning of the term, as used in Unix System V and Solaris, a LWP runs in user space on top of a single kernel thread and shares its address space and system resources with other LWPs within the same process. Multiple user level threads, managed by a thread library, can be placed on top of one or many LWPs - allowing multitasking to be done at the user level, which can have some performance benefits.[1]
>
>In some operating systems there is no separate LWP layer between kernel threads and user threads. This means that user threads are implemented directly on top of kernel threads. In those contexts, the term "light-weight process" typically refers to kernel threads and the term "threads" can refer to user threads.[2] On Linux, user threads are implemented by allowing certain processes to share resources, which sometimes leads to these processes to be called "light weight processes".[3][4] Similarly, in SunOS version 4 onwards (prior to Solaris) "light weight process" referred to user threads.

## 1.1 进程与线程

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动. 它可以申请和拥有系统资源, 是一个动态的概念, 是一个活动的实体. 它不只是程序的代码, 还包括当前的活动, 通过程序计数器的值和处理寄存器的内容来表示. 进程是一个"执行中的程序". 程序是一个没有生命的实体, 只有处理器赋予程序生命时, 它才能成为一个活动的实体, 我们称其为进程.

通常在**一个进程**中可以包含**若干个线程**, 它们可以**利用进程所拥有的资源**. 在**引入线程的操作系统中**, 通常都是把**进程作为分配资源的基本单位**, 而把**线程作为独立运行和独立调度的基本单位**. 由于线程比进程更小, 基本上不拥有系统资源, 故对它的调度所付出的开销就会小得多, 能更高效的提高系统内多个程序间并发执行的程度.

线程和进程的区别在于, **子进程和父进程有不同的代码和数据空间**, 而**多个线程则共享数据空间**, **每个线程有自己的执行堆栈和程序计数器为其执行上下文(这些是线程独享的！！！**). 多线程主要是为了节约 CPU 时间, 发挥利用, 根据具体情况而定. 线程的运行中需要使用计算机的内存资源和 CPU.

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. **线程**自己**基本上不拥有系统资源**,**只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈！！！**),但是它可与**同属一个进程**的其他的线程**共享进程所拥有的全部资源**.

**线程与进程的区别**归纳:

- 地址空间和其它资源: 进程间相互独立, 同一进程的各线程间共享. **某进程内**的**线程**在**其它进程不可见**.

- 通信: **进程间通信 IPC**, 线程间可以**直接读写进程数据段**(如全局变量)来进行通信——需要进程**同步和互斥**手段的辅助, 以**保证数据的一致性**.

- 调度和切换: 线程上下文切换比进程上下文切换要快得多.

- **在多线程 OS 中**, **进程不是一个可执行的实体**.

## 1.2 内核线程

**内核线程就是内核的分身(整个内核！！！**), 一个分身可以处理一件特定事情. 这在处理异步事件如异步 IO 时特别有用. 内核线程的使用是廉价的, **唯一使用的资源**就是**内核栈**和**上下文切换时保存寄存器的空间**. 支持多线程的内核叫做多线程内核(Multi-Threads kernel ).

- 内核线程**只运行在内核态**, 不受**用户态上下文**的拖累.

- 处理器竞争: 可以在**全系统范围内竞争处理器资源**;

- 使用资源: 唯一使用的资源是**内核栈**和**上下文切换时保持寄存器的空间**

- 调度: 调度的开销可能和进程自身差不多昂贵

- 同步效率: 资源的同步和数据共享比整个进程的数据同步和共享要低一些.

# 2 linux 进程的创建流程

线程机制式现代编程技术中常用的一种抽象概念. 该机制提供了同一个程序内共享内存地址空间, 打开文件和资源的一组线程.

## 2.1 进程的复制 fork 和加载 execve

我们在 Linux 下进行进行编程, 往往都是通过 fork 出来一个新的程序, fork 从化字面意义上理解就是说"分叉", 这其实就意味着我们的 fork 进程并不是真正从无到有被创建出来的.

**一个进程**, 包括**代码、数据和分配给进程的资源**, 它其实是从现有的进程(父进程)复制出的一个副本(子进程), **fork**()函数通过**系统调用**创建一个与原来进程几乎完全相同的进程, 也就是两个进程可以做完全相同的事, 然后如果我们通过**execve 为子进程加载新的应用程序**后, 那么新的进程将开始执行新的应用

简单来说, **新的进程是通过 fork 和 execve 创建的, 首先通过 fork 从父进程分叉出一个基本一致的副本, 然后通过 execve 来加载新的应用程序镜像**

- fork 生成当前进程的的一个相同副本, 该副本成为子进程

> 原进程(父进程)的所有资源都以适当的方法复制给新的进程(子进程). 因此该系统调用之后, 原来的进程就有了**两个独立的实例**, 这两个实例的联系包括: **同一组打开文件**,**同样的工作目录**,**进程虚拟空间(内存)中同样的数据**(当然两个进程各有一份副本,也就是说他们的**虚拟地址相同**,但是所对应的**物理地址不同**)等等.

- execve 从一个可执行的二进制程序镜像加载应用程序, 来代替当前运行的进程

> 换句话说, 加载了一个新的应用程序. 因此 execv 并不是创建新进程

所以我们在 linux 要创建一个应用程序的时候, 其实执行的操作就是

1. 首先使用 fork 复制一个旧的进程

2. 然后调用 execve 在为新的进程加载一个新的应用程序

## 2.2 写时复制技术

有人认为这样大批量的复制会导致执行效率过低. 其实在复制过程中, linux 采用了写时复制的策略.

写入时复制(Copy\-on\-write)是一个被使用在程式设计领域的最佳化策略. 其基础的观念是, 如果有**多个呼叫者**(callers)同时要求相同资源, 他们会共同取得**相同的指标指向相同的资源**, 直到**某个呼叫者**(caller)尝试**修改资源**时, 系统才会真正**复制一个副本(private copy)给该呼叫者**, 以避免被修改的资源被直接察觉到, 这过程对其他的呼叫只都是通透的(transparently). 此作法主要的优点是如果呼叫者并没有修改该资源, 就不会有副本(private copy)被建立.

第一代 Unix 系统实现了一种傻瓜式的进程创建: 当发出 fork()系统调用时, 内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程. 这种行为是非常耗时的, 这种创建地址空间的方法涉及许多内存访问, 消耗许多 CPU 周期, 并且完全破坏了高速缓存中的内容. 在大多数情况下, 这样做常常是毫无意义的, 因为许多子进程通过装入一个新的程序开始它们的执行, 这样就完全丢弃了所继承的地址空间.

现在的 Linux 内核采用一种更为有效的方法, 称之为写时复制(Copy On Write, COW). 这种思想相当简单: **父进程和子进程共享页帧而不是复制页帧**. 然而, **只要页帧被共享**, 它们就不能被修改, 即**页帧被保护**. 无论父进程还是子进程何时试图**写一个共享的页帧**, 就**产生一个异常**, 这时**内核就把这个页复制到一个新的页帧中并标记为可写(标志位设置只是对用户特权级即 3 特权级有效**). 原来的页帧仍然是写保护的: 当其他进程试图写入时, 内核检查写进程是否是这个页帧的唯一属主, 如果是, 就把这个页帧标记为对这个进程是可写的.

当进程 A 使用系统调用 fork 创建一个子进程 B 时,由于子进程 B 实际上是父进程 A 的一个拷贝,

因此会拥有与父进程相同的物理页面.为了节约内存和加快创建速度的目标,fork()函数会让子进程 B 以只读方式共享父进程 A 的物理页面.同时将父进程 A 对这些物理页面的访问权限也设成只读.

这样,当父进程 A 或子进程 B 任何一方对这些已共享的物理页面执行写操作时,都会产生**页面出错异常(page\_fault int14)中断**,此时 CPU 会执行系统提供的**异常处理函数 do\_wp\_page**()来解决这个异常.

**do\_wp\_page**()会对这块导致写入异常中断的**物理页面**进行**取消共享**操作,**为写进程复制一新的物理页面**,使父进程 A 和子进程 B 各自拥有一块**内容相同的物理页面**.最后,从**异常处理函数中返回**时,CPU 就会**重新执行刚才导致异常的写入操作指令**,使进程继续执行下去.

一个进程调用 fork()函数后, 系统先给**新的进程分配资源**, 例如存储数据和代码的空间. 然后把原来的进程的所有值都复制到新的新进程中, 只有**少数值**与原来的进程的值(比如**PID**)不同. 相当于克隆了一个自己.

>关于进程创建的
>
>参见 [Linux 中 fork, vfork 和 clone 详解(区别与联系)](http://blog.csdn.net/gatieme/article/details/51417488)

# 3 不同操作系统线程的实现机制

## 3.1 专门线程支持的系统-LWP 机制

**线程**更好的支持了**并发程序设计技术**,在**多处理器系统**上,他能保证真正的并行处理. Microsoft Windows 或是 Sun Solaris 等操作系统都对线程进行了支持.

这些系统中都在内核中提供了专门支持线程的机制, Unix System V 和 Sun Solaris 将**线程称作为轻量级进程**(LWP-Light-weight process),在这些系统中,相比较重量级进程,线程被抽象成一种耗费较少资源, 运行迅速的执行单元.

## 3.2 Linux 下线程的实现机制

但是**Linux 实现线程的机制非常独特**. 从**内核的角度**来说,他并**没有线程这个概念**. Linux 把**所有的线程都当做进程**来实现. 内核中并没有准备特别的调度算法或者定义特别的数据结构来表示线程. 相反,**线程仅仅被视为一个与其他进程共享某些资源的进程**. **每个线程**都拥有**唯一隶属于自己的 task\_struct**,所以在内核看来,它看起来就像**一个普通的进程**(只是线程和同组的其他进程共享某些资源)

在之前[Linux 进程描述符 task\_struct 结构体详解–Linux 进程的管理与调度(一)](http://blog.csdn.net/gatieme/article/details/51383272)和[Linux 进程 ID 号–Linux 进程的管理与调度(三)](http://blog.csdn.net/gatieme/article/details/51383377)中讲解进程的 pid 号的时候我们就提到了,进程 task\_struct 中**pid 存储的是内核对该进程的唯一标示**,即对进程则标示进程号,对线程来说就是其线程号,那么对于**线程**来说**一个线程组所有线程与领头线程具有相同的进程号, 存入 tgid 字段**

因此**getpid**()返回**当前进程的进程号**, 返回的应该是 tgid 值而不是 pid 的值,对于**用户空间**来说**同组的线程**拥有相同进程号即**tpid**, 而对于**内核**来说,某种程序上来说**不存在线程**的概念,那么 pid 就是内核唯一区分每个进程的标示.

> 正是 linux 下组管理, 写时复制等这些巧妙的实现方式
>
>- linux 下**进程或者线程的创建**开销很小
>
>- 既然不管是线程或者进程内核都是不加区分的, 一组共享地址空间或者资源的线程可以组成一个线程组,那么其他**进程即使不共享资源也可以组成进程组**,甚至来说**一组进程组也可以组成会话组**,进程组可以简化向所有组内进程发送信号的操作, 一组会话也更能适应多道程序环境

## 3.3 实现机制的区别

总而言之, **Linux 中线程**与**专门线程支持系统**是完全不同的

Unix System V 和 Sun Solaris 将**用户线程称作为轻量级进程**(LWP-Light-weight process),相比较重量级进程, 线程被抽象成一种耗费较少资源, 运行迅速的执行单元.

而对于 linux 来说, **用户线程**只是**一种进程间共享资源的手段**,相比较其他系统的进程来说,linux 系统的进程本身已经很轻量级了

举个例子来说, 假如我们有一个包括了四个线程的进程,

在提供**专门线程支持的系统**中,通常会有**一个包含指向四个不同线程的指针的进程描述符**. 该描述符复制描述像地址空间, 打开的文件这样的共享资源. **线程本身再去描述它独占的资源**.

相反, **Linux**仅仅创建了**四个进程**,并分配**四个普通的 task\_struct 结构**,然后**建立这四个进程时制定他们共享某些资源**.

# 4 内核线程

**Linux 内核**可以看作一个**服务进程**(管理软硬件资源, 响应用户进程的种种合理以及不合理的请求). 内核需要多个执行流并行, 为了防止可能的阻塞, 多线程化是必要的.

**内核线程就是内核的分身**, 一个分身可以处理一件特定事情. **Linux 内核**使用**内核线程**来**将内核分成几个功能模块**, 像 kswapd、kflushd 等, 这在处理异步事件如异步 IO 时特别有用. **内核线程的使用是廉价的**, 唯一使用的资源就是**内核栈和上下文切换时保存寄存器的空间**. 支持多线程的内核叫做**多线程内核**(Multi-Threads kernel ). 内核线程的调度由内核负责, 一个内核线程处于阻塞状态时不影响其他的内核线程, 因为其是调度的基本单位. 这与用户线程是不一样的.

内核线程只运行在内核态, 不受用户态上下文的拖累.

- 处理器竞争: 可以在全系统范围内竞争处理器资源;

- 使用资源: 唯一使用的资源是内核栈和上下文切换时保持寄存器的空间

- 调度: 调度的开销可能和进程自身差不多昂贵

- 同步效率: 资源的同步和数据共享比整个进程的数据同步和共享要低一些.

## 4.1 内核线程与普通进程的异同

1. 跟普通进程一样, **内核线程也有优先级和被调度**. 当和**用户进程**拥有**相同的 static\_prio**时, 内核线程有机会得到更多的 cpu 资源

2. **内核线程的 bug 直接影响内核**, 很容易搞死整个系统,但是用户进程处在内核的管理下, 其 bug 最严重的情况也只会把自己整崩溃

3. **内核线程没有自己的地址空间**, 所以它们的"**current\->mm**"都是**空的**;

4. **内核线程只能在内核空间操作**, 不能与用户空间交互;

内核线程不需要访问用户空间内存, 这是再好不过了. 所以内核线程的 task\_struct 的 mm 域为空

但是刚才说过, **内核线程还有核心堆栈**, 没有 mm 怎么访问它的核心堆栈呢?这个**核心堆栈跟 task\_struct 的 thread\_info 共享 8k 的空间**, 所以不用 mm 描述.

但是**内核线程**总要访问内核空间的其他内核啊, 没有 mm 域毕竟是不行的. 所以内核线程被调用时,内核会将其 task\_strcut 的**active\_mm**指向**前一个被调度出的进程的 mm 域**,在需要的时候, 内核线程可以使用前一个进程的内存描述符.

因为**内核线程不访问用户空间**, **只操作内核空间内存**, 而**所有进程的内核空间都是一样的**. 这样就省下了一个 mm 域的内存.

## 4.2 内核线程创建

在**内核**中, 有两种方法可以**生成内核线程**, 一种是使用**kernel\_thread**()接口, 另一种是用**kthread\_create**()接口

### 4.2.1 kernel\_thread

先说 kernel\_thread 接口, 使用该接口创建的线程, 必须在该线程中**调用 daemonize**()函数, 这是因为只有**当线程的父进程指向"Kthreadd**"时, 该线程**才算是内核线程(！！！**), 而恰好 daemonize()函数主要工作便是将该线程的父进程改成"kthreadd"内核线程; 默认情况下, **调用 deamonize**()后, 会**阻塞所有信号**, 如果想操作某个信号可以调用 allow\_signal()函数.

```c
int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
            // fn 为线程函数, arg 为线程函数参数, flags 为标记
void daemonize(const char * name,...); // name 为内核线程的名称
```

### 4.2.2 kthread\_create

而 kthread\_create 接口, 则是标准的内核线程创建接口, 只须调用该接口便可创建内核线程; 默认创建的线程是存于不可运行的状态, 所以需要**在父进程中**通过**调用 wake\_up\_process**()函数来启动该线程.

```c
struct task_struct *kthread_create(int (*threadfn)(void *data),void *data,
                                  const char namefmt[], ...);
 //threadfn 为线程函数;data 为线程函数参数;namefmt 为线程名称, 可被格式化的, 类似 printk 一样传入某种格式的线程名
```

线程创建后, 不会马上运行, 而是需要将 kthread\_create()返回的 task\_struct 指针传给 wake\_up\_process(), 然后通过此函数运行线程.

### 4.2.3 kthread\_run

当然, 还有一个创建并启动线程的函数: kthread\_run

```c
struct task_struct *kthread_run(int (*threadfn)(void *data),
                                    void *data,
                                    const char *namefmt, ...);
```

线程一旦启动起来后, 会一直运行, 除非该线程主动调用 do\_exit 函数, 或者其他的进程调用 kthread\_stop 函数, 结束线程的运行.
```c
int kthread_stop(struct task_struct *thread);
```

kthread\_stop() 通过发送信号给线程.

如果线程函数正在处理一个非常重要的任务, 它不会被中断的. 当然如果线程函数永远不返回并且不检查信号, 它将永远都不会停止.

```c
int wake_up_process(struct task_struct *p); //唤醒线程
struct task_struct *kthread_run(int (*threadfn)(void *data),void *data,
                                const char namefmt[], ...);//是以上两个函数的功能的总和
```

因为**线程也是进程**, 所以其结构体也是使用进程的结构体"struct task\_struct".

### 4.2.4 内核线程的退出

当**线程执行到函数末尾**时会**自动调用内核中 do\_exit**()函数来退出或其他线程调用**kthread\_stop**()来指定线程退出.

# 5 总结

Linux 使用 task\_struct 来描述进程和线程

1. 一个进程由于其运行空间的不同, 从而有**内核线程**和**用户进程**的区分, **内核线程**运行在**内核空间**,之所以称之为**线程**是因为它**没有虚拟地址空间**, **只能访问内核的代码和数据**,而**用户进程**则运行在**用户空间**,**不能直接访问内核的数据**但是可以通过**中断,系统调用**等方式**从用户态陷入内核态**, 但是内核态只是进程的一种状态,与内核线程有本质区别

2. 用户进程运行在用户空间上,而一些通过共享资源实现的一组进程我们称之为线程组, Linux 下内核其实本质上没有线程的概念,Linux 下线程其实上是与其他进程共享某些资源的进程而已. 但是我们习惯上还是称他们为**线程**或者**轻量级进程**

因此, Linux 上进程分 3 种, 内核线程(或者叫核心进程)、用户进程、用户线程, 当然如果更严谨的, 你也可以认为用户进程和用户线程都是用户进程.

- **内核线程拥有进程描述符、PID、进程正文段、核心堆栈**

- **用户进程拥有进程描述符、PID、进程正文段、核心堆栈、用户空间的数据段和堆栈**

- **用户线程拥有进程描述符、PID、进程正文段、核心堆栈, 同父进程共享用户空间的数据段和堆栈**

**用户线程**也可以通过**exec 函数族**拥有自己的**用户空间的数据段和堆栈**, 成为**用户进程**.