
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 背景](#1-背景)
- [2. 大页的优点](#2-大页的优点)
- [3. 大页的种类](#3-大页的种类)

<!-- /code_chunk_output -->

# 1. 背景

当运行内存需求量较大的应用程序时, 如果使用长度为 4KB 的页, 将会产生较多的 TLB 未命中和缺页异常, 严重影响应用程序的性能. 如果使用长度为 2MB 甚至更大的大页, 可以大幅**减少 TLB 未命中**和**缺页异常的数量**, 大幅提高应用程序的性能. 这正是内核引入大页(Huge Page)的直接原因.

# 2. 大页的优点

降低 TLB miss 的概率: 拿普通的 4KB 页面和 2MB 的大页相比, 都是使用一条页表项, 能 cover 的内存大小却差了 511 倍, 所以更多的使用大页能大大减少系统中页表项的数量, 再加上 TLB cache 大小固定且有限, 再再加上程序访问的地址的局部性原理, TLB miss 的概率就下来了.

降低 walk page table 的长度: 由于大页的页表级数(PGD PUD PMD)比普通页面级数(PGD PUD PMD PTE)小 1, 所以在走表时会高效一些. (以普通页面是四级页表为例)

综上, **外在的体现**就是访问内存的带宽会有提升.

一篇关于大页性能测评的文章: [HERE](https://alexandrnikitin.github.io/blog/transparent-hugepages-measuring-the-performance-impact/)

# 3. 大页的种类

大页首先**需要处理器支持**, 然后**需要内核支持**, 内核有如下**两种实现方式**.

(1) **静态大页**(`persistent hugepage`), 通过用户自行控制它的分配、释放、使用.  关于释放: 早期的内核在启动阶段预分配大页是不支持释放的, 当前内核(5.12)已经支持了.

使用 **hugetlbfs** **伪文件系统**实现大页.

hugetlbfs 文件系统是一个**假的文件系统**, 只是**利用了文件系统的编程接口**.

使用 hugetlbfs 文件系统实现的大页称为 **hugetblfs 大页**、**传统大页**或**标准大页**, 本书统一称为**标准大页**.

(2) **透明大页**(`transparent hugepage`), 由系统自己控制透明大页的分配、释放、使用. 若用户开启透明大页功能, 系统会在后台运行一个 khugepaged 的内核线程扫描系统内存, 将合适的内存合并成为大页, 用户无感.

**标准大页**的**优点**是**预先分配大页到大页池**, 进程申请大页的时候从大页池取, 成功的概率很高, **缺点**是应用程序需要**使用文件系统的编程接口**(目前已经不依赖).

透明大页的优点是**对应用程序透明**, 缺点是**动态分配**, 在**内存碎片化**的时候**分配成功的概率很低**.