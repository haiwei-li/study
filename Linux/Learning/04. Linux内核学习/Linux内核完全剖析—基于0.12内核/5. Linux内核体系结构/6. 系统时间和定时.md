## 1. 系统时间

PC/AT 系统中提供了**用电池供电的实时钟(Real Time, RT)电路支持**. 通常, **这部分电路与保存系统信息的 CMOS RAM 集成在一个芯片上, 因此这部分电路被称为 RT/CMOS RAM 电路**. PC/AT 微机或其兼容机使用了 Motorala 的 MC146818 芯片.

初始化时, Linux 0.12 通过 init/main.c 的 time\_init()函数读取这块芯片中保存的当前时间和日期信息, 并通过 kernel/mktime.c 中的 kernel\_mktime()函数转换成从 1970 年 1 月 1 日午夜 0 时开始到当前的以秒为单位的时间, 称为 UNIX 日历时间. 该时间确定了系统开始运行的日历时间, 被保存在全局变量 startup\_time 中供内核所有代码使用. 用户程序可以通过系统调用 time()来读取 startup\_time 的值, 而超级用户可以通过系统调用 stime()来修改这个系统时间值.

另外, 再通过下面介绍的从系统启动开始计数的系统滴答值 jiffies, 程序就可以唯一地确定运行时刻的当前时间值. 由于每个滴答定时值是 10ms, 因此内核代码定义了一个宏来方便代码对当前时间的访问. 这个宏定义在 include/linux/sched.h 文件在 192 行, 形式如下:

```
#define CURRENT_TIME (startup_time + jiffies/HZ)
```

其中, HZ=100, 是内核系统时钟频率. 当前时间宏 CURRENT\_TIME 被定义为系统开机时间 startup_time 加上开机后系统运行的时间 jiffies/100. 在修改一个文件的被访问时间或其 i 节点的被修改时间时均使用了这个宏.

## 2. 系统定时

在 Linux 0.12 内核初始化过程中, **PC 的可编程定时芯片 Intel 8253(8254)的计数器通道 0 被设置为运行在方式 3 下**(方波发生器方式), 并且初始计数值 LATCH 被设置为每隔 10ms 在通道 0 输出端 OUT 发一个方波上升沿. 由于 8254 芯片的时钟输入频率时 1.193180MHZ, 因此初始计数值 LATCH=1193180/100, 约为 11931. **由于 OUT 引脚被连接到 PIC 的 0 级上(也就是说连接在中断控制器上)**, 因此每隔 10ms 会发出一个时钟中断请求(IRQ0)信号. 这个时间节拍就是操作系统运行的脉搏, 称为 1 个系统滴答或一个系统时钟周期. 因此, 每隔 1 个滴答时间, 系统就会调用一次时钟中断处理程序.

时钟中断处理程序 timer\_interrupt 主要用来通过 jiffies 变量来累计自系统启动以来经过的时钟滴答数. 一次时钟中断 jiffies 就加 1. 然后调用 C 函数 do\_timer()进一步处理. 调用时的参数 CPL 是从被中断程序的段选择符(保存在堆栈中的 CS 段寄存器值)中取得当前代码特权级 CPL.

do\_timer()函数则根据特权级对当前进程运行时间作累计. 若 CPL=0, 表示进程运行在内核态时被中断, 因此内核就会把进程的内核态运行时间统计数 stime 加 1, 否则把进程用户态运行时间统计数加 1.

如果软盘处理程序 floppy.c 在操作过程中添加定时器, 则对定时器链表进行处理. 若某个定时器时间到(递减后等于 0), 则调用该定时器的处理函数. 然后对当前进程运行时间进行处理, 把当前进程运行时间减 1. 时间片是一个进程在被切换掉之前所能持续运行的 CPU 时间, 其单位是上面定义的滴答数. 如果时间片值递减后还大于 0, 表示其时间片还没用完, 于是退出 do\_timer()继续运行当前进程. 若此时进程时间片已经递减为 0, 表示进程用完了此次时间片, 于是程序就会根据被中断程序的级别来确定进一步处理的方法. 若被中断的当前进程是工作在用户态的(特权级别大于 0), 则 do\_timer()就会调用调度程序 schedule()切换到其他进程去运行. 内核态, 即在内核程序中运行时被中断, 则 do\_timer()会立即退出. 因此这样的处理方式决定了 Linux 系统的进程在内核态运行时不会被调度程序切换. 即进程在内核态程序中运行时是不可抢占的(nonpreemptive), 但当处于用户态程序中运行时则是可以被抢占的(preemptive).

