本章思考题:

1. 发生硬件中断后, ARM 处理器做了哪些事情?
2. 硬件中断号和 Linux 内核的 IRQ 中断号是如何映射的?
3. 一个硬件中断发生后, Linux 内核如何响应并处理该中断?
4. 为什么说中断上下文不能执行睡眠操作?
5. 软中断的回调函数执行过程中是否允许响应本地中断?
6. 同一类型的软中断是否允许多个 CPU 并行执行?
7. 软中断上下文包括哪几种情况?
8. 软中断上下文和进程上下文哪个优先级高?为什么?
9. 是否允许同一个 Tasklet 在多个 CPU 上并行执行?
10. workqueue 是运行在中断上下文, 还是进程上下文?其回调函数允许睡眠吗?
11. 旧版本(Linux 2.6.25)的 workqueue 机制在实际过程中遇到了哪些问题和挑战?
12. C M W Q 机制如何动态管理工作线程池的线程呢?
13.  如果有多个 work 挂入一个工作线程中执行, 当某个 work 的回调函数执行了阻塞操作, 那么剩下的 work 该怎么办?

操作系统还有一个很重要的功能就是**管理众多的外设**, 例如键盘鼠标、显示器、无线网卡、声卡等. **处理器和外设**之间的**运算能力**和**处理速度**通常不在一个数量级上. 假设现在**处理器**需要去**获取一个键盘的事件**, 如果**处理器**发出一个**请求信号**之后一直在**轮询(polling) 键盘的响应**, 由于键盘响应速度比处理器慢得多并且等待用户输入, 那么处理器是**很浪费 CPU 资源**的. 与其这样, 不如**键盘有事件发生时发送一个信号给处理器**, 让处理器暂停当前的工作来处理这个响应, 比处理器一直在轮询效率要高, 这就是中断机制产生的背景.

凡事都不是绝对的, 轮询机制也不完全比中断机制差. 例如, 在**网络吞吐量大**的应用场景下, **网卡驱动**采用**轮询机制比中断机制效率要高**, 比如现在很火的一个开源组件 DPDK(Data Plane Development Kit).

本章介绍 ARM 架构下中断是如何管理的, Linux 内核中的**中断管理机制**是如何设计与实现的, 以及常用的**下半部机制**, 例如**软中断**、**tasklet**、**workqueue**等.