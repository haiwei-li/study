第 1 章  ARM 体系结构

第 2 章 内存管理

本章思考题

- 2.1 物理内存初始化

    - 2.1.1 内存管理概述

    - 2.1.2 内存大小

    - 2.1.3 物理内存映射

    - 2.1.4 zone 初始化

    - 2.1.5 空间划分

    - 2.1.6 物理内存初始化

- 2.2 页表的映射过程

    - 2.2.1 ARM32 页表映射

    - 2.2.2 ARM64 页表映射

- 2.3 内核内存的布局图

    - 2.3.1 ARM32 内核内存布局图

    - 2.3.2 ARM64 内核内存布局图

- 2.4 分配物理页面

    - 2.4.1 伙伴系统分配内存

    - 2.4.2 释放页面

    - 2.4.3 小结

- 2.5 slab 分配器

    - 2.5.1 创建 slab 描述符

    - 2.5.2 分配 slab 对象

    - 2.5.3 释放 slab 缓冲对象

    - 2.5.4kmalloc 分配函数

    - 2.5.5 小结

- 2.6 vmalloc

- 2.7 VMA 操作

    - 2.7.1 查找 VMA

    - 2.7.2 插入 VMA

    - 2.7.3 合并 VMA

    - 2.7.4 红黑树例子

    - 2.7.5 小结

- 2.8 malloc

    - 2.8.1 brk 实现

    - 2.8.2 VM_LOCK 情况

    - 2.8.4 小结

- 2.9 mmap

    - 2.9.1 mmap 概述

    - 2.9.2 mmap 小节

- 2.10 缺页中断处理

    - 2.10.1 do\_page\_fault()

    - 2.10.2 匿名页面缺页中断

    - 2.10.3 文件映射缺页中断

    - 2.10.4 写时复制

    - 2.10.5 小结

- 2.11 page 引用计数

    - 2.11.1 struct page 数据结构

    - 2.11.2 \_count 和\_mapcount 的区别

    - 2.11.3 页面锁 PG\_Locked

    - 2.11.4 小结

- 2.12 反向映射 RMAP

    - 2.12.1 父进程分配匿名页面

    - 2.12.2 父进程创建子进程

    - 2.12.3 子进程发生 COW

    - 2.12.4 RMAP 应用

    - 2.12.5 小结

- 2.13 回收页面

    - 2.13.1 LRU 链表

    - 2.13.2 kswapd 内核线程

    - 2.13.3 balance\_pgdat 函数

    - 2.13.4 shrink\_zone 函数

    - 2.13.5 shrink\_active\_list 函数

    - 2.13.6 shrink\_inactive\_list 函数

    - 2.13.7 跟踪 LRU 活动情况

    - 2.13.8 Refault Distance 算法

    - 2.13.9 小结

- 2.14 匿名页面生命周期

    - 2.14.1 匿名页面的诞生

    - 2.14.2 匿名页面的使用

    - 2.14.3 匿名页面的换出

    - 2.14.4 匿名页面的换入

    - 2.14.5 匿名页面销毁

- 2.15 页面迁移

    - 2.15.1 migrate\_pages()函数

    - 2.15.2 页迁移的应用

- 2.16 内存规整(memory compaction)

    - 2.16.1 内存规整实现

    - 2.16.2 小结

- 2.17 KSM

    - 2.17.1 KSM 实现

    - 2.17.2 匿名页面和 KSM 页面的区别

    - 2.17.3 小结

2.18 2016 年最火的内存漏

- 2.19 内存管理数据结构和 API

    - 2.19.1 内存管理数据结构的关系图

    - 2.19.2 内存管理中常用 API

- 2.20 最新更新和展望

    - 2.20.1 页面回收策略从 zone 迁移到 node

    - 2.20.2 OOMKiller 改进

    - 2.20.3 swap 优化

    - 2.20.4 展望

第 3 章 进程管理

本章思考题

- 3.1 进程的诞生

    - 3.1.1 init 进程

    - 3.1.2 fork

    - 3.1.3 小结

- 3.2 CFS 调度器

    - 3.2.1 权重计算

    - 3.2.2 进程创建

    - 3.2.3 进程调度

    - 3.2.4 scheduler tick

    - 3.2.5 组调度

    - 3.2.6 PELT 算法改进

    - 3.2.7 小结

- 3.3 SMP 负载均衡

    - 3.3.1 CPU 域初始化

    - 3.3.2 SMP 负载均衡

    - 3.3.3 唤醒进程

    - 3.3.4 调试

    - 3.3.5 小结

- 3.4 HMP 调度器

    - 3.4.1 初始化

    - 3.4.1 HMP 负载调度

    - 3.4.3 新创建的进程

    - 3.4.4 小结

- 3.5 NUMA 调度器

    - 3.5.1 node 和 page 的关系

    - 3.5.2 扫描进程

    - 3.5.3 NUMA 缺页中断

    - 3.5.4 进程迁移

    - 3.5.3 总结

- 3.6 EAS 绿色节能调度器

    - 3.6.1 能效模型

    - 3.6.2 WALT 算法

    - 3.6.3 唤醒进程

    - 3.6.4 CPU 动态调频

    - 3.6.5 小结

- 3.7 实时调度

    - 3.7.1 低延迟例子

- 3.8 最新更新与展望

    - 3.8.1 进程管理最新更新

    - 3.8.2 展望

第 4 章 并发与同步

本章思考题

- 4.1 原子操作与内存屏障

    - 4.1.1 原子操作

    - 4.1.2 内存屏障

- 4.2 spinlock

    - 4.2.1 spinlock 实现

    - 4.2.2 spinlock 变种

    - 4.2.3 spinlock 和 raw\_spin\_lock

- 4.3 信号量

    - 4.3.1 信号量

    - 4.3.2 小结

- 4.4 Mutex 互斥体

    - 4.4.1 MCS 锁机制

    - 4.4.2 Mutex 锁的实现

    - 4.4.3 小结

- 4.5 读写锁

    - 4.5.1 读者信号量

    - 4.5.2 写者锁

    - 4.5.3 小结

- 4.6 RCU

    - 4.6.1 经典 RCU 和 Tree RCU

    - 4.6.2 TreeRCU 设计

    - 4.6.3 小结

- 4.7 内存管理中的锁

- 4.8 最新更新与展望

    - 4.8.1 QueuedSpinlock

    - 4.8.2 读写信号量优化

    - 4.8.3 展望

    - 4.8.4 推荐书籍

第 5 章 中断管理

本章思考题

5.1 Linux 中断管理机制... 623

5.1.1 ARM 中断控制器... 623

5.1.2 硬件中断号和 Linux 中断号的映射... 627

5.1.3 注册中断... 638

5.1.4 ARM 底层中断处理... 646

5.1.5 高层中断处理... 654

5.1.6 小结... 663

5.2 软中断和 Tasklet

5.2.1SoftIRQ 软中断...665

5.2.2 Tasklet

5.2.3 local\_bh\_disable/local\_bh\_enable

5.2.4 小结...676

5.3Workqueue 工作队列...679

5.3.1 初始化工作队列... 680

5.3.2 创建工作队列...686

5.3.3 调度一个 work.692

5.3.4 取消一个 work. 703

5.3.5 和调度器的交互... 707

5.3.6 小结... 709

第 6 章  调试... 712

6.1 QEMU 调试 Linux 内核... 712

6.1.1 QEMU 运行 ARM Linux 内核... 712

6.1.2 QEMU 调试 ARM-Linux 内核... 715

6.1.3 QEMU 运行 ARMv8 开发平台... 716

6.1.4 文件系统支持... 718

6.1.5 图形化调试...719

6.1.6 实验进阶... 722

6.2 Ftrace. 723

6.3SystemTap.740

6.3.1 ARM 上运行 SystemTap. 740

6.4 内存检测... 744

6.4.1slub_debug.744

6.4.2 内存泄漏检测 kmemleak.748

6.4.3 Kasan 内存检测... 750

6.5 死锁检测... 753

6.6 内核调试秘籍... 759

6.6.1 printk

6.6.2 动态打印

6.6.3 RAMConsole

6.6.4 OOPS 分析

6.6.5 BUG\_ON()和 WARN\_ON()