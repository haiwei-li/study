
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [0 概述](#0-概述)
- [1 do\_page\_fault()函数](#1-do_page_fault函数)

<!-- /code_chunk_output -->

# 0 概述

在之前介绍 malloc()和 mmap()两个用户态 API 函数的内核实现时, 我们发现它们只建了进程地址空间, 在用户空间里可以看到虚拟内存, 但没有建立虚拟内存和物理内存之的映射 关系. 当进程访问这些还没有建立映射关系的虚拟内存时, 处理器自动触发一个缺页异常(也称为"缺页中断"), Linux 内核必须处理此异常. 缺页异常是内存管理当中最杂和重要的一部分, 需要考虑很多的细节, 包括匿名页面、KSM 页面、page cache 页面、写时复制、私有映和共享映射等.

缺页异常处理依赖于处理器的体系结构, 因此缺页异常底层的处理流程在内核代码中定体系结构的部分. 下面以 A R M v 7 为例来介绍底层缺页异常处理的过程.

# 1 do\_page\_fault()函数

缺页中断处理的核心函数是 do\_page\_fault(),该函数的实现和具体的体系结构相关.

