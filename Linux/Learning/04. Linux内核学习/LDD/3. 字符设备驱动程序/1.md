## scull 的设计

- 编写驱动程序的第一步就是定义驱动程序为用户程序提供的能力(机制).
- scull 的源代码实现了下列设备, 我们将由模块实现的每种设备称作一种"类型":

*scull0 ~ scull3*

这四个设备分别由一个全局且持久的内存区域组成. "全局"是指: 如果设备被多次打开, 则打开它的所有文件描述符可共享该设备所包含的数据. "持久"是指: 如果设备关闭后再打开, 则其中的数据不会丢失.

*scullpipe0 ~ scullpipe3*

这四个 FIFO(先进先出)设备与管道类似. 一个进程读取由另一个进程写入的数据. 如果多个进程读取同一个设备, 它们就会为数据发生竞争. scullpipe 的内部实现将说明在不借助于中断的情况下如何实现阻塞式和非阻塞式读/写操作. 虽然实现的驱动程序使用硬件中断与它们的设备保持同步, 但阻塞式和非阻塞式操作是一个重要内容,   并且有别于中断处理.

*scullsingle*
*scullpriv*
*sculluid*
*scullwuid*

这些设备与 scull0 相似, 但在何时允许 open 操作方面有一些限制. 第一个(scullsingle)一次只允许一个进程使用该驱动程序, 而 scullpriv 对每个虚拟控制台(或 X 终端会话)是私有的, 这是因为每个控制台/终端上的进程将获取不同的内存区. sculluid 和 scullwuid 可被多次打开, 但每次只能由一个用户打开; 如果另一个用户锁定了该设备, sculluid 将返回"Device Busy"的错误, 而 scullwuid 则实现了阻塞式 open. 这些 scull 设备的变种混淆了"机制"和"策略", 但这类处理是值得去了解的, 因为某些真正的设备需要类似的管理方式.

## 主设备号和次设备号

对字符设备的访问是通过文件系统内的设备名称进行的. 那些名称被称为特殊文件、设备文件、或简单称之为文件系统树的节点, 他们通常位于/dev 目录. 字符设备驱动程序的设备文件通过"c"标识. 块设备通过"b"标识. 本章主要集中在字符设备, 但下面很多信息也适用于块设备.

ls -l 命令, 可以看到设备文件项中有两个数, 这里通常是文件长度出现的地方. 这些数字是给特殊设备的主次设备编号. 下面的列表显示了几个设备. 它们主编号是 1, 4, 7 和 10, 而次编号是 1, 3, 5, 64, 65 和 129.


```
 crw-rw-rw- 1 root  root  1,  3 Apr 11  2002 null
 crw------- 1 root  root  10, 1 Apr 11  2002 psaux
 crw------- 1 root  root  4,  1 Oct 28 03:04 tty1
 crw-rw-rw- 1 root  tty   4, 64 Apr 11  2002 ttys0
 crw-rw---- 1 root  uucp  4, 65 Apr 11  2002 ttyS1
 crw--w---- 1 vcsa  tty   7,  1 Apr 11  2002 vcs1
 crw--w---- 1 vcsa  tty   7,129 Apr 11  2002 vcsa1
 crw-rw-rw- 1 root  root  1,  5 Apr 11  2002 zero
```

通常而言, 主设备号标识设备对应的驱动程序. 例如/dev/null 和/dev/zero 由驱动程序 1 管理, 而虚拟控制台和串口终端由驱动程序 4 管理. 现代的 Linux 内核允许多个驱动程序共享设备号, 但我们看到多数设备仍按照"一个主设备号对应一个驱动程序"的原则组织.

次设备号由内核使用, 用于正确确定设备文件所指的设备. 依赖于驱动程序的编写方式(下面阐述), 我们可以通过次设备号获取一个指向内核设备的直接指针, 也可将次设备号当作设备本地数组的索引. 无论哪种方式, 内核自己几乎不知道次编号的任何事情, 除了它们指向你的驱动实现的设备.

主设备号: 对应驱动程序. 一个主设备号对应多个驱动程序.

次设备号: 驱动程序实现的设备.

## 设备编号的内部表达


