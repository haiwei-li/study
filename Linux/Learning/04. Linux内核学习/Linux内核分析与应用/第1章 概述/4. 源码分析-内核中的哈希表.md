
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [什么是哈希表](#什么是哈希表)
- [2 如何解决哈希表冲突](#2-如何解决哈希表冲突)
- [内核中的哈希表](#内核中的哈希表)

<!-- /code_chunk_output -->

Linux 内核中还有一个专门用于哈希表的链表结构 hlist

# 什么是哈希表

哈希表是数据结构中一种非常重要的用于查找的数据结构, 它的基本思想是将**关键字**和其**存储位置！！！** 之间建立起一种**映射关系**, 称为哈希函数, 通过哈希函数可以实现在时间复杂度 O(1)下查找数据.

![2019-09-17-20-12-34.png](./images/2019-09-17-20-12-34.png)

实际应用过程中常常有一种现象, 对于**两个不同的关键字**, 经过**哈希函数运算**以后, 它们具有**同样的哈希地址**, 如果我们对这种情况不特殊处理的话, 也就意味着这两个不同的关键字将被存储在同一个位置上, 这就是冲突现象.

# 2 如何解决哈希表冲突

在哈希表中解决冲突是一个重要的问题, 常见的方法有几种: **开放寻址法**、**再散列法**和**链地址法**.

这里重点说明是**链地址法**. 基本思想是将具有**相同哈希地址的记录链成一个链表**, m 个哈希地址就有 m 个链表(每个哈希地址对应一个链表), 然后用一个数组, 将这 M 个链表的头结点存储起来, 形成一个动态的结构.

![2019-10-05-18-30-53.png](./images/2019-10-05-18-30-53.png)

这部分内容, 有助于学习 hlist. hlist 是内核为我们提供了一个用于实现哈希表链地址法的一个数据结构.

# 内核中的哈希表

可通过 2.6 版本来学习, 哈希表源码在 include/linux/list.h 文件中, 前面的以 list 开头的都是双循环链表的, hlist 开头的都是哈希表相关的源码.

首先看看内核中用于实现哈希表的两个数据结构, 一个是 hlist_head, 是链表的头结点, 它有一个指向第一个链表体结构的的头结点指针 first; 另一个是 hlist_node, 是链表体结构, 它包含指向后一个节点的 next 指针, 特别的是, 它还包含一个二级指针 pprev, 这个二级指针分析很关键, 而这个需要从其他代码中获取线索.

```c
struct hlist_head{
    struct hlist_node *first;
};

struct hlist_node{
    struct hlist_node *next, **pprev;
}
```

首先查看前面的几个定义

```c
#define HLIST_HEAD_INIT { .first = NULL }
#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
#define INIT_HLIST_NODE(ptr) ((ptr)->next = NULL, (ptr)->pprev = NULL)
```

从名字看, 前三个是对于头结点初始化的宏, 最后一个是对于 node 节点初始化的宏.


```c
static inline int hlist_unhashed(const struct hlist_node *h)
{
	return !h->pprev;
}
```

`hlist_unhashed`用来判断是一个 hlist_node 节点是否经过哈希的, 如果该节点没有哈希, name 指针域 pprev 应该是初始化时候的 NULL, 返回值也就是 true.

```c
static inline int hlist_empty(const struct hlist_head *h)
{
	return !h->first;
}
```

传入参数是 hlist_head, 判断该链表是否为空.

上面两个操作都没有提到对二级指针 pprev 的操作, 所以还需要往下看

```c
static inline void __hlist_del(struct hlist_node *n)
{
	struct hlist_node *next = n->next;
	struct hlist_node **pprev = n->pprev;
	*pprev = next;
	if (next)
		next->pprev = pprev;
}
```

从名字看, 是对于哈希链表的节点进行删除操作.

分析之前, 插入一下对于二级指针的介绍.

![2019-10-05-19-11-54.png](./images/2019-10-05-19-11-54.png)

一级指针见的都比较多也比较熟悉, 它指向的是某个变量, 也就是说一级指针中存储的是某个变量的地址, 而二级指针, 简单来说就是一个指向指针的指针, 二级指针中存储的是某个一级指针的地址.

如上图, A 是二级指针, B 是一级指针, C 是一个变量.

先来看 B, 它是一个指向变量 C 的一级指针, 它通过存储变量 C 的地址来达到指向变量 C 的目的. 而 A, 是一个指向指针 B 的二级指针, 它通过存储指针 B 的地址来达到指向指针 B 的目的.

接着是关于指向操作, 我们知道对于一个一级指针进行一次指向操作, 就相当于间接的引用这个指针指向的一个变量; 同理, 对于一个二级指针进行一次指向操作, 就相当于间接的引用. 它指向了那个一级指针了, 而对于一个二级指针进行两次指向操作, 就相当于对它指向的一级指针所指向的那个变量的间接引用.


现在就分析下执行过程, 传入的参数是 hlist_node 的指针 n.

* 先保存当前节点的 next 指针域
* 用一个二级指针 pprev 保存了当前节点的 pprev 指针域
* \*pprev 就是对二级指针 pprev 的一次指向操作, 也就是对于 pprev 二级指针所指向的那个一级指针的间接引用, 该语句将 next 指针赋值给了该一级指针.
* 接着是一个判断, 当 next 指针不为空的情况下, 也就是当前节点的后续节点存在的情况下, 将 pprev 指针赋值给了当前节点后继节点的 pprev 指针域

![2019-10-05-19-05-16.png](./images/2019-10-05-19-05-16.png)

![2019-10-06-18-55-14.png](./images/2019-10-06-18-55-14.png)

这里回忆下, 对于一个双链表节点删除过程, 上面是一个双链表的结构, 删除中间这个节点, 是修改其前驱节点的 next 指针域让其指向其后继节点, 修改其后继节点的 pre 指针域让其指向当前节点的前驱节点.

hlist 也是个链表, 也要遵循这样的原则, 下面图是 hlist 的结构, 先让 pprev 指向一个未知的 x 指针, 删除中间的节点, 首先就是修改其前驱节点的 next 指针域, 让指向当前节点的后继节点.

回过头看代码, `*pprev`就是对 pprev 的一次指向操作