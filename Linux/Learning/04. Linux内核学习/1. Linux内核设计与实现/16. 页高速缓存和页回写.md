
# 缓存原理

页高速缓存(cache) 是 Linux 内核实现的磁盘缓存. 通过将磁盘中的数据缓存到物理内存中, 将对磁盘的访问变成了对物理内存的访问, 从而减少对磁盘的 I/O 操作.

页回写就是将页高速缓存中变更数据刷新回磁盘的操作.

两个因素:

1. 访存速度更快, L1 和 L2 高速缓存更快;

2. 局部性原理(`temporal locality`): 数据一旦被访问, 很可能短期内再次被访问.

# 缓存策略

## 读写缓存

读缓存: 缓存未命中的话, 从磁盘中读取数据并放入页缓存中.

写缓存: 三种策略.

1. 不缓存(nowrite). 跳过缓存, **直接写到磁盘**, **同时**使缓存中的**数据失效**.

2. 写透缓存(write-through cache). 写操作将自动更新内存缓存, 同时也更新磁盘文件. 有利于保持缓存一致性且实现简单.

3. 回写缓存(write-back cache). Linux 采用的. 程序的写操作直接写到缓存中, 不立即更新后端存储, 而是将页高速缓存中被写入的页面标记为 "脏", 并被加入到脏页链表中; 然后由一个进程(回写进程)周期性将脏页链表中的页写回到磁盘, 最后清理 "脏" 页标识.

<table>
 <caption><b><br>3 种缓存策略</br></b></caption>
    <tr>
        <th>策略</th>
        <th>复杂度</th>
	<th>性能</th>
    </tr>
    <tr>
        <td>不缓存(nowrite)</td>
        <td>简单</td>
        <td>
	缓存只用于读, 对于写操作比较多的 I/O, 性能反而会下降
        </td>
    </tr>
    <tr>
        <td>写透(write-through)</td>
        <td>简单</td>
        <td>
	提升了读性能, 写性能反而下降(除了写磁盘, 还要写缓存)
        </td>
    </tr>
    <tr>
        <td>回写(write-back)</td>
        <td>复杂</td>
        <td>
	读写性能都提高
        </td>
    </tr>
</table>

## 缓存回收

缓存回收: Linux 的缓存回收是通过选择干净页进行简单替换. 如果没有足够的干净页, 强制进行回写操作.

最难的在于决定什么页应该回收. 理想的策略是回收那些以后最不可能使用的页面. 理想的回收策略被称为预测算法.

两种策略:

1. 最近最少使用(Least Recently Used, LRU). 每个缓存数据都有个时间戳, 保存最近被访问的时间. 回收缓存时首先回收时间戳较旧的数据. 对于许多只访问一次的情景, 将这些页面放在 LRU 链的顶端显然不合适.

2. 双链策略. 基于 LRU 的改善策略. 它通过 2 个链表(活跃链表和非活跃链表)来模拟 LRU 的过程, 目的是为了提高页面回收的性能.

页面回收动作发生时, 从**非活跃链表**的**尾部**开始回收页面.

双链策略的关键就是页面如何在 2 个链表之间移动的.

双链策略中, **每个页面**都有 2 个标志位, 分别为

* PG_active - 标志页面是否活跃, 也就是表示此页面是否要移动到活跃链表

* PG_referenced - 表示页面是否被进程访问到

页面移动的流程如下:

1. 当页面第一次被被访问时, PG_active 置为 1, 加入到活动链表

2. 当页面再次被访问时, PG_referenced 置为 1, 此时如果页面在非活动链表, 则将其移动到活动链表, 并将 PG_active 置为 1, PG_referenced 置为 0

3. 系统中 daemon 会定时扫描活动链表, 定时将页面的 PG_referenced 位置为 0

4. 系统中 daemon 定时检查页面的 PG_referenced, 如果 PG_referenced=0, 那么将此页面的 PG_active 置为 0, 同时将页面移动到非活动链表

# Linux 页高速缓存

页高速缓存中的**页**可能包含**多个不连续的物理磁盘块**. 所以在页面高速缓存中检查特定数据是否已经被缓存是件困难的事情.

> 比如, x86 中一个物理页是 4KB, 而多数文件系统的块大小仅仅 512KB, 所以 8 个块才能填满一个页; 另外, 文件本身可能在磁盘的各个位置, 所以页面中的映射的块也不需要连续.

另外, Linux 页高速缓存对被缓存的页面范围定义非常广泛. 目标是缓存**任何基于页的对象**, 包含**各种类型的文件**和**各种类型的内存映射**.

为维持页高速缓存的普遍性(不应该绑定到物理文件或 inode 结构体), Linux 页高速缓存使用了一个新对象管理缓存项和页 I/O 操作. address_space 结构体.

> 如果通过扩展 inode 结构体支持页 I/O 操作, 就仅仅只用作缓存文件.



