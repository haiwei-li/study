从用户程序的角度来看, 内核是一个透明的系统层.

进程不知道内核是否在运行中. 进程同样不知道虚拟内存的哪些内容在物理内存中, 哪些已经换出或尚未读入.

但进程一直忙于与内核的交互:请求系统资源、访问外设、与其他进程通信、读取文件等. 为了达到上述目的, **进程**使用**标准库例程**, 库例程接下来**调用内核函数**, 最终, 由**内核负责**在各个请求进程之间公平而且流畅地共享资源和服务.

因而, **应用程序**看到的**内核**是负责执行**多种系统功能的一个大的例程集合**. 标准库是一个中间层, 用于在不同的体系结构和系统之间, 标准化并简化内核例程的管理.

从内核的视角来看, 情况当然有一点复杂, 因为用户态和核心态之间有几个重大的不同, 有一些不同已经在本书前几章中讨论过. 要特别注意两种模式下不同的虚拟地址空间和利用各种处理器特性的不同方式. 另外, 我们还比较感兴趣的一点是, **控制权**如何在**应用程序**和**内核**之间来回**传递**, **参数**和**返回值**如何**传递**. 本章将讨论这些问题.

本章首先简要地看一下**系统程序设计**, 把**标准库的库例程**和**对应的系统调用**区分清楚.

接下来仔细考察内核源代码, 以描述用于从用户空间切换到内核空间的机制.

我们将描述用于实现系统调用的基础设施, 并讨论特别的实现方面的特性.