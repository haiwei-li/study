先参考阮一峰的文章《计算机是如何启动的》(该文章也有转载)

首先, 内核使用 32 位的地址总线来寻址, 所以能编址出 2 的 32 次方, 也就是 4G 的地址空间. 那么第一个问题是, 这 4G 的空间指向哪里?我想大多数读者的第一反应都是内存吧?我们知道在主板上除了内存还有 BIOS、显卡、声卡、网卡 3 等外部设备, CPU 需要和这些外设进行通信. 那么实现通信自然就得有地址, 不然怎么表示数据的去向呢?比如显卡内部就有自己的一些存储单元 4. 在 x86 下, 当需要访问这些存储单元的时候, 就需要给予不同的访问地址来区分每一个读写单元.

说到这里, 我们需要引出两个专业名词: 端口统一编址和端口独立编址. 还记得我们刚说的 4G 地址空间吗?所谓的端口统一编址就是把所有和外设存储单元对应的端口直接编址在这 4G 的地址空间里, 当我们对某一个地址进行访问的时候实际上是在访问某个外设的存储单元. 而端口独立编址就是说这些端口没有编址在地址空间里, 而是另行独立编址. 而 x86 架构部分的采用了端口独立编址, 又部分的采用了端口统一编址. 部分外设的部分存储单元直接可以通过某个内存地址访问, 而其他部分在一个独立的端口地址空间中, 需要使用 in/out 指令去访问, 我们用到的时候再来细说.

上文简单的介绍了一下地址空间的概念, 接下来我们详细分析 CPU 在加电后的启动过程. 这里可能比较枯燥和难以理解, 但是没关系, 这里的流程是固化的, 程序员们能做的很有限. 5 我增加这一章只是为了读者们能够充分理解我们之后内容的原理, 并没有和编程相关的东西, 所以大家只要大致理解就好.

我们从按下电源开始. 首先是 CPU 重置. 主板加电之后在电压尚未稳定之前, 主板上的北桥控制芯片会向 CPU 发出重置信号(Reset), 此时 CPU 进行初始化. 当电压稳定后, 控制芯片会撤销 Reset 信号, CPU 便开始了模式化的工作. 此时形成的第一条指令的地址是 0xFFFFFFF06, 从这里开始, CPU 就进入了一个"取指令-翻译指令-执行"的循环了. 所以我们需要做的就是在各个阶段提供给 CPU 相关的数据, 以完成这个"接力赛". 这个接力过程中任何一个环节如果出现致命问题, 其导致的直接后果就是宕机. 死机是最好的结果, 最坏的结果是程序在"默默的"破坏我们的数据, 所以一定要谨慎对待.

那么, 这个地址指向哪呢?大家一定想到了, 它指向 BIOS 芯片里. 我们刚刚说过, 在 4G 的地址空间里, 有一些地址是分给外设的, 这个地址便是映射到 BIOS 的. 我们知道, 计算机刚加电的时候内存等芯片尚未初始化, 所以也只能是指向 BIOS 芯片里已经被"固化"的指令了.

紧接着就是 BIOS 的 POST(Power On Self Test, 上电自检)过程了, BIOS 对计算机各个部件开始初始化, 如果有错误会给出报警音. 当 BIOS 完成这些工作之后, 它的任务就是在外部存储设备中寻找操作系统, 而我们最常用的外存自然就是硬盘了. 自己安装过操作系统的读者应该都设置过 BIOS 选项吧?BIOS 里面就有一张启动设备表 7, BIOS 会按照这个表里面列出的顺序查找可启动设备. 那么怎么知道该设备是否可以启动呢?规则其实很简单: 如果这个存储设备的第一个扇区中 512 个字节 8 的最后两个字节是 0x55 和 0xAA, 那么该存储设备就是可启动的. 这是一个约定, 所以 BIOS 会对这个列表中的设备逐一检测, 只要有一个设备满足要求, 后续的设备将不再测试.

当 BIOS 找到可启动的设备后, 便将该设备的第一个扇区加载到内存的 0x7C00 地址处, 并且跳转过去执行. 而我们要做的事情, 便是从构造这个可启动的扇区开始.

因为一个扇区只有 512 字节, 放不下太多的代码, 所以常规的做法便是在这里写下载入操作系统内核的代码 9, 这段代码就是所谓的 bootloader 程序. 一般意义上的 bootloader 负责将软硬件的环境设置到一个合适的状态, 然后加载操作系统内核并且移交执行权限. 而 GRUB 是一个来自 GNU 项目的多操作系统启动程序. 它是多启动规范的实现, 允许用户可以在计算机内同时拥有多个操作系统, 并在计算机启动时选择希望运行的操作系统.

引出 GRUB 的原因很简单: 我不准备自己实现 bootloader 程序. 理由有二: 其一, 实现 bootloader 牵扯太多在后期才要讲述的知识. 与其前期简陋的实现这个 bootloader, 还不如就用现成的优秀实现, 以后有机会自己再学着改进; 第二, 我想在后面把这个小内核安装到物理机器上去, 而读者们想必在自己的机器上已经有了多个操作系统了. 这样的话如果非得实现自己的 bootloader 的话, 势必会造成和已有操作系统的不兼容. 所以, 我干脆决定直接使用 GRUB 来加载内核. 以后就能让它很简单的安装在物理机器上, 这样的话我们能拥有一个 Linux 系统和自己的小内核共存的计算机了. 如果你愿意的话, 也可以再加上一个 Windows 系统.

听起来很不错吧?那么问题是怎么能让 GRUB 加载这个小内核呢? 答案是 GRUB 提供的 multiboot 规范. 这份规范是描述如何构造出一个能够被 GRUB 识别, 并且按照我们定义的规则去加载的操作系统内核. 目的很明确吧?具体的协议在网上很容易检索到, 也有不少中文版本的翻译, 所以我不再详细解释这个协议. 希望对这个协议陌生的读者们先去网上得到一份具体的说明, 仔细的阅读一遍后再阅读下一章节. 在下一章节中, 我们将自己动手构建出一个可以运行的"Hello, kernel OS"程序, 拭目以待吧.