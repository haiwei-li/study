
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 物理和虚拟内存](#1-物理和虚拟内存)
  - [1.1. 虚拟内存寻址布局](#11-虚拟内存寻址布局)
- [2. 虚拟内存管理器](#2-虚拟内存管理器)
  - [2.1. 页帧分配](#21-页帧分配)
  - [2.2. 伙伴系统 (Buddy system)](#22-伙伴系统-buddy-system)

<!-- /code_chunk_output -->

# 1. 物理和虚拟内存

现实中, 我们经常会面临 32 位还是 64 位操作系统的选择, 对用户来说, 它们间最大的差别是能否支持 4GB 以上的虚拟内存空间. 站在性能的角度来理解 32 位和 64 位的系统上, Linux 映射物理内存到虚拟内存的区别是十分有趣的. 如下图所示, 可以明显看出内存映射方式在 32 位和 64 位系统上的区别.

![config](./images/9.png)

**32 位**架构的机器上, Linux 内核**只能直接映射第一个 GB 的的物理内存**(896M, 因为还要考虑到保留的空间). 在此上的内存被称作**ZONE_NORMAL**, 这部分空间必须映射到最下面的 1GB. 这种映射对应用程序是完全透明的, 但是分配内存页到 ZONE_HIGHMEM 会造成一点点性能损耗.

另一方面, 在 64 位系统上, 例如在 IA\-64 上面, ZONE_NORMAL 一直延伸到 64GB 或者 128GB. 如你所见, 把内存页从 ZONE_HIGHMEM 映射到 ZONE_NORMAL 这种损耗在 64 位系统上是不存在的.

## 1.1. 虚拟内存寻址布局

下图展示了 32 位和 64 位架构 Linux 系统的虚拟寻址布局.

![config](./images/9.png)

32 位架构上, 单个进程可以利用的最大地址空间是 4GB, 这是受到了 32 位虚拟内存映射的限制. 在标准的 32 位环境中, 虚拟地址被划分为 3GB 的用户空间和 1GB 的内存空间, 现实中也存在一些 4GB/4GB 地址布局.

再说 64 位架构, 因为没有内存限制存在, 每个进程能够都有可能使用巨大的地址空间.

# 2. 虚拟内存管理器

由于操作系统把**所有内存**都**映射成虚拟内存**, 所以, **操作系统的物理内存架构**对**用户和应用程序**通常都是**不可见(！！！**)的.

如果我们要**掌握 Linux 内存调优**的办法, 就必须先**理解 Linux 如何处理虚拟内存**. 如上面所说的那样, **应用程序不使用物理内存(！！！**), 而是**向 Linux 内核**请求一个**特定大小的内存映射**, 并且收到一个**虚拟内存的映射**. 如下图所示, **虚拟内存不必要一定是物理内存的映射(！！！**), 如果某个应用程序使用了一块超大的虚拟内存, 这虚拟内存其中**某一部分**可能是由磁盘上的**swap 空间映射**来的.

![config](./images/10.png)

从图中可以看出来, **应用程序**经常**不是直接写入磁盘子系统(！！！**), 而是首先写入**cache 或者 buffer(！！！**), 然后, 在**pdflush 空闲！！！**的时候、或者**某个文件大小超出 buffer 和 cache**的时候, 由**pdflush 内核线程！！！**把**buffer**或**cache**中的数据**写入磁盘**. 参考后面的**写入脏 buffer**部分.

Linux 内核**管理磁盘缓存的方式！！！**, 和内核**写数据到文件系统的方式有紧密联系(！！！**). 和其它操作系统都只分配特定的部分内存作为磁盘缓存的方式相比, Linux 处理内存资源更加高效. **虚拟内存管理器**默认配置把**所有的可用空闲内存空间(！！！**)作为**磁盘缓存**, 所以, 经常可以见到 Linux 系统明明拥有**数 GB 级的内存**, 却**只有 20M 处于空闲状态**.

Linux 同样高效利用**swap 空间**, 当**操作系统**开始使用**swap 空间**的时候, 并**不表示系统出现了内存瓶颈(！！！**), 而是证明了 Linux 如何有效的使用系统资源. 参考**页帧回收(page frame reclaiming**).

## 2.1. 页帧分配

页是物理内存或虚拟内存中一组**连续的线性地址**, Linux 内核以页为单位处理内存, 页的大小通常是 4KB. 当一个进程请求**一定量的页面**时, 如果有**可用的页面**, 内核会直接把这些页面分配给这个进程, 否则, 内核会从其它进程或者页缓存中拿来一部分给这个进程用. 内核知道有多少页可用, 也知道它们的位置.

## 2.2. 伙伴系统 (Buddy system)

Linux 内核使用名为伙伴系统(Buddy system)的机制维护空闲页, 伙伴系统维护空闲页面, 并且尝试给发来页面申请的进程分配页面, 它还努力保持内存区域是连续的. 如果不考虑到零散的小页面可能会导致内存碎片, 而且在要分配一个连续的大内存页时将变得很困难, 这就可能导致内存使用效率降低和性能下降. 下图说明了伙伴系统如何分配内存页.