历次实验目录

linux 实验一,计算机是如何工作的?

http://blog.sina.com.cn/s/blog_c068e9970102xrec.html

本次实验主要讲了计算机的工作方式以及 x86 汇编基础,包括冯诺依曼体系结构, 从硬件角度, 逻辑上可以抽象为: CPU 中存在一个寄存器 IP(instruction pointer), IP 总是指向内存中的某一块区域(代码段), CPU 从 IP 中取得指令地址执行, 然后 IP+1, CPU 继续取得指令执行, 然后反复上述步骤.
从程序员的角度: 可以抽象为一个 for 循环, CPU 总是解释执行 next instruction().
CPU 在实际取指令时根据 cs: eip 来准确定位一个指令.

linux 实验二,操作系统是如何工作的?

http://blog.sina.com.cn/s/blog_c068e9970102xro1.html

本次实验主要讲了计算机工作的三个法宝:
存储程序计算机工作模型, 计算机系统最最基础性的逻辑结构, 通过不断执行 eip 指向地址的指令来使计算机进行工作.
函数调用堆栈, 高级语言得以运行的基础, 有了调用堆栈, 计算机就可以调用带参数的程序, 以及保存和恢复现场.
中断, 多道程序操作系统的基点, 没有中断机制程序只能从头一直运行结束才有可能开始运行其他程序.

linux 实验三,构造一个简单的 Linux 系统 MenuOS

http://www.jianshu.com/p/d741b90a8834

本次实验主要讲了 linux 内核源代码简介,以及如何构造一个简单的 Linux 系统 MenuOS,并且还学会了如何使用 gdb 跟踪调试程序.

linux 实验四,扒开系统调用的三层皮(上)

http://www.jianshu.com/p/63dbd7986617

本次实验主要讲了系统调用的三层皮: xyz、system_call 和 sys_xyz,以及用户态、内核态和中断处理过程.
以及为什么会有这种级别划分?因为没有访问权限划分容易使得系统混乱(毕竟普通程序员写的函数可能会有明显的疏漏).

linux 实验五,扒开系统调用的三层皮(下)

http://www.jianshu.com/p/d8be683bbea7

本次实验主要分析了 system_call 到 iret 的过程
首先保护现场, 然后根据 sys_call_table 系统调用表调用系统调度处理函数(eax 中存放系统调用号), 调用完后看是否还有其他工作, 如果有的话根据工作类型, 决定是调用 work_pend 和 work_notifysig 处理限号, 还是进行重新调度. 最后 restore all, 恢复现场, 返回(iret).

linux 实验六,进程的描述和进程的创建

http://www.jianshu.com/p/53c906a54423

本次实验主要讲了 task_struct 数据结构,即进程的描述,以及进程是如何创建得的.
fork、vfork 和 clone 三个系统调用都可以创建一个新进程, 而且都是通过调用 do_fork 来实现进程的创建,通过本次实验的内容,可以帮助我们区分这三个系统调用的异同.

linux 实验七,可执行程序的装载

http://www.jianshu.com/p/fc5892e96539

本次实验主要讲了可执行程序的装载,包括可执行程序是怎么得来的,目标文件的格式 ELF,静态链接的 ELF 可执行文件和进程的地址空间,可执行程序、共享库和动态加载等内容.

linux 实验八,进程的切换和系统的一般执行过程

http://www.jianshu.com/p/715a3de43510

本次实验主要讲了进程的调度时机与进程的切换,以及 Linux 系统的一般执行过程(最一般的情况: 正在运行的用户态进程 X 切换到运行用户态进程 Y 的过程),以及一些操作系统的基本知识.并且通过 switch_to 的代码详细了解了任务切换的具体过程,包括保存恢复等过程.