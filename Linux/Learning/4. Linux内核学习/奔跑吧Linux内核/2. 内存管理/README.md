第 2 章 内存管理

本章思考题

- 2.1 物理内存初始化

    - 2.1.1 内存管理概述

    - 2.1.2 内存大小

    - 2.1.3 物理内存映射

    - 2.1.4 zone 初始化

    - 2.1.5 空间划分

    - 2.1.6 物理内存初始化

- 2.2 页表的映射过程

    - 2.2.1 ARM32 页表映射

    - 2.2.2 ARM64 页表映射

- 2.3 内核内存的布局图

    - 2.3.1 ARM32 内核内存布局图

    - 2.3.2 ARM64 内核内存布局图

- 2.4 分配物理页面

    - 2.4.1 伙伴系统分配内存

    - 2.4.2 释放页面

    - 2.4.3 小结

- 2.5 slab 分配器

    - 2.5.1 创建 slab 描述符

    - 2.5.2 分配 slab 对象

    - 2.5.3 释放 slab 缓冲对象

    - 2.5.4kmalloc 分配函数

    - 2.5.5 小结

- 2.6 vmalloc

- 2.7 VMA 操作

    - 2.7.1 查找 VMA

    - 2.7.2 插入 VMA

    - 2.7.3 合并 VMA

    - 2.7.4 红黑树例子

    - 2.7.5 小结

- 2.8 malloc

    - 2.8.1 brk 实现

    - 2.8.2 VM_LOCK 情况

    - 2.8.4 小结

- 2.9 mmap

    - 2.9.1 mmap 概述

    - 2.9.2 mmap 小节

- 2.10 缺页中断处理

    - 2.10.1 do\_page\_fault()

    - 2.10.2 匿名页面缺页中断

    - 2.10.3 文件映射缺页中断

    - 2.10.4 写时复制

    - 2.10.5 小结

- 2.11 page 引用计数

    - 2.11.1 struct page 数据结构

    - 2.11.2 \_count 和\_mapcount 的区别

    - 2.11.3 页面锁 PG\_Locked

    - 2.11.4 小结

- 2.12 反向映射 RMAP

    - 2.12.1 父进程分配匿名页面

    - 2.12.2 父进程创建子进程

    - 2.12.3 子进程发生 COW

    - 2.12.4 RMAP 应用

    - 2.12.5 小结

- 2.13 回收页面

    - 2.13.1 LRU 链表

    - 2.13.2 kswapd 内核线程

    - 2.13.3 balance\_pgdat 函数

    - 2.13.4 shrink\_zone 函数

    - 2.13.5 shrink\_active\_list 函数

    - 2.13.6 shrink\_inactive\_list 函数

    - 2.13.7 跟踪 LRU 活动情况

    - 2.13.8 Refault Distance 算法

    - 2.13.9 小结

- 2.14 匿名页面生命周期

    - 2.14.1 匿名页面的诞生

    - 2.14.2 匿名页面的使用

    - 2.14.3 匿名页面的换出

    - 2.14.4 匿名页面的换入

    - 2.14.5 匿名页面销毁

- 2.15 页面迁移

    - 2.15.1 migrate\_pages()函数

    - 2.15.2 页迁移的应用

- 2.16 内存规整(memory compaction)

    - 2.16.1 内存规整实现

    - 2.16.2 小结

- 2.17 KSM

    - 2.17.1 KSM 实现

    - 2.17.2 匿名页面和 KSM 页面的区别

    - 2.17.3 小结

- 2.18 2016 年最火的内存漏洞

- 2.19 内存管理数据结构和 API

    - 2.19.1 内存管理数据结构的关系图

    - 2.19.2 内存管理中常用 API

- 2.20 最新更新和展望

    - 2.20.1 页面回收策略从 zone 迁移到 node

    - 2.20.2 OOMKiller 改进

    - 2.20.3 swap 优化

    - 2.20.4 展望