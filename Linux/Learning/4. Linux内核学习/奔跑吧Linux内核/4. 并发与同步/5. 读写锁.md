
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [0 概述](#0-概述)
- [1 读者信号量](#1-读者信号量)
- [3 小结](#3-小结)

<!-- /code_chunk_output -->


# 0 概述

在阅读本节前请思考如下小问题.

- 什么时候使用**读者信号量**, 什么时候使用**写者信号量**, 由什么来判断?
- **读写信号量**使用的**自旋等待机制(optimistic spinning**) 是如何实现的?

上述介绍的信号量有一个明显的缺点 — **没有区分临界区的读写属性**. **读写锁**通常允许**多个线程并发地读(！！！)访问临界区**, 但是**写访问**只限制于**一个线程**. 读写锁能有效地提高并发性, 在多处理器系统中允许同时有多个读者访问共享资源, 但写者是排他性的.

读写锁具有如下特性

- 允许**多个读者**同时进入临界区, 但**同一时刻写者不能进入**.
- **同一时刻**只允许**一个写者**进入临界区.
- **读者和写者不能同时进入临界区**.

读写锁有**两种**, 分别是**spinlock 类型**和**信号量类型**.

**spinlock 类型**的读写锁数据结构定义在**include/linux/rwlock\_types.h**头文件中.

```c
[include/linux/rwlock_types.h]
typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

[arch/arm/include/asm/spinlock_types.h]
typedef struct {
	u32 lock;
} arch_rwlock_t;
```

常用的函数如下:

```c
[include/linux/rwlock.h]

```

和**spinlock 锁**一样, **读写锁**有**关闭中断**和**下半部的版本**. **spinlock 类型的读写锁**实现比较简单, 本章重点关注**信号量类型读写锁**的实现.

# 1 读者信号量

读写信号量的定义如下:

```c
[include/linux/rwsem.h]

```

- wait\_lock 是一个 spinlock 变量, 用于实现对读写信号量数据结构中 count 成员的
原子操作和保护.
- count 用于表示读写信号量的计数. 以前读写信号量的实现用 activity 来表示, activity=0 表示没有读者和写者, activity=\-l 表示有写者, activity>0 表示有读者. 现在 count 的计数方法己经发生了变化.
- wait\_list 链表用于管理所有在该信号量上睡眠的进程, 没有成功获取锁的进程会睡眠在这个链表上.
- osq: MCS 锁, 在第 4.4 节中己详细介绍.
- owner: 当写者成功获取锁时, owner 指向锁持有者的 task\_struct 数据结构.

count 成员的语义定义如下:

```c
[]

```

上述的宏定义看起来比较复杂, 翻译成十进制数值会清晰一些, 本章以 ARM32 体系架构为例介绍读写信号量的实现.

```c

```


# 3 小结

**信号量缺点**: 没有区分临界区的**读写属性**

读写锁特点:

- 允许**多个读者**同时进入临界区, 但**同一时刻写者不能进入**.
- **同一时刻**只允许**一个写者**进入临界区.
- **读者和写者不能同时进入临界区**.

读写锁有**两种**, 分别是**spinlock 类型**和**信号量类型**. 分别对应 typedef struct rwlock\_t 和 struct rw\_semaphore.

**读写锁**在内核中应用广泛, 特别是在**内存管理**中, 全局的**mm\->mmap\_sem 读写信号量**用于保护进程地址空间的一个读写信号量, 还有**反向映射 RMAP 系统中的 anon\_vma\->rwsem**, 地址空间**address\_space**数据结构中**i\_mmap\_rwsem**等.

再次总结**读写锁的重要特性**.

- **down\_read**(): 如果一个进程持有了**读者锁**, 那么允许继续申请**多个读者锁**, 申请**写者锁**则要**睡眠等待**.
- **down\_write**(): 如果一个进程持有了**写者锁**, 那么第二个进程申请该**写者锁**要**自旋等待(配置了 CONFIG\_RWSEM\_SPIN\_ON\_OWNER 选项不睡眠**), 申请**读者锁**则要**睡眠等待**.
- up\_write()/up\_read():如果**等待队列**中**第一个成员是写者**, 那么**唤醒该写者**, 否则**唤醒排在等待队列**中**最前面连续的几个读者**.