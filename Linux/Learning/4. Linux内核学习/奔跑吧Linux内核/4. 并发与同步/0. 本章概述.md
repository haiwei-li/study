本章思考题

1. 在 ARM 处理器中, 如何实现独占访问内存?
2. atomic\_cmpxchg()和 atomic\_xchg()分别表示什么含义?
3. 为什么 spinlock 的临界区不能睡眠(不考虑 RT\-Linux 的情况)?
4. Linux 内核中经典 spinlock 的实现有什么缺点?
5. 为什么 spinlock 临界区不允许发生抢占?
6. Ticket-based 的 spinlock 机制是如何实现的?
7. 如果在 spin\_lock()和 spin\_unlock()的临界区中发全了中断, 并且中断处理程序也恰巧修改了该临界资源, 那么会发生什么后果?该如何避免呢?
8. 与 spinlock 相比, 信号量有哪些特点?
9. 请简述信号量是如何实现的.
10. 什么时候使用读者信号量, 什么时候使用写者信号量, 由什么来判断?
11. 读写信号量使用的自旋等待机制(optimistic spinning)是如何实现的?
12. Linux 内核已经实现了信号量机制, 为何要单独设置一个 Mutex 机制呢?
13. 请简述 MCS 锁机制的实现原理.
14. 在编写内核代码时, 该如何选择信号量和 Mutex?
15. RCU 相比读写锁有哪些优势?
16. 请解释 Quiescent State 和 Grace Period.
17. 请简述 RCU 实现的基本原理.
18. 在大型系统中, 经典 RCU 遇到了什么问题? Tree RCU 又是如何解决该问题的?
19. 在 RCU 实现中, 为什么要使用 ULONG\_CMP\_GE()和 ULONG\_CMP\_LT()宏来比较两个数的大小, 而不直接使用大于号或者小于号来比较?
20. 请简述一个 Grace Period 的生命周期及其状态机的变化.
21. 请总结原子操作、spinlock、信号量、读写信号量、Mutex 和 RCU 等 Linux 内核常用锁的特点和使用规则.
22. 在 KSM 中扫描某个 VMA 寻找有效的匿名页面, 假设此 VMA 恰巧被其他 CPU 销毁了, 会不会有问题呢?
23. 请简述页锁 PG locked 的常用使用方法.
24. 在 mm/rmap.c 文件中的 page\_get\_anon\_vma()函数中, 为什么要使用 rcu\_read\_lock()? 什么时候注册 RCU 回调函数呢?
25. 在 mm/oom\_kill.c 的 select\_bad\_process()函数中, 为什么要使用 rcu\_read\_lock()? 什么时候注册 RCU 回调函数呢?

编写**内核代码**或**驱动代码**时需要留意**共享资源的保护**, 防止共享资源被**并发访问**. 所谓并发访问, 是指多个内核路径**同时访问和操作数据**, 就有可能发生**相互覆盖共享数据**的情况, 造成**被访问数据的不一致**. **内核路径**可以是一个**内核执行路径**、**中断处理程序**或者**内核线程**等. 并发访问可能会造成系统不稳定或产生错误, 且很难跟踪和调试.

在早期**不支持 SMP 对称多处理器**的 Linux 内核中, 导致并发访问的因素是**中断服务程序**, 只有中断发生时, 或者**内核代码路径**显式地要求**重新调度**并且执行另外一个进程时, 才有可能发生并发访问. 在**支持 SMP**对称多处理器的 Linux 内核里, 并发运行在**不同 CPU**中的**内核线程**完全有可能同一时刻并发访问共享数据, 并发访问随时都可能发生. 特别是现在的 Linux 内核早己经支持**内核抢占**, 调度器可以抢占正在运行的进程, 重新调度其他进程来执行.

在计算机术语中, **临界区(critical region**)是指**访问和操作共享数据**的**代码段**, 这些**资源**无法同时被**多个执行线程访问**, 访问临界区的**执行线程**或**代码路径**称为**并发源**. 为了避免临界区中的并发访问, 开发者必须保证访问**临界区的原子性**, 也就是说在临界区内不能有多个并发源同时执行, 整个临界区就像一个不可分割的整体.

内核中产生**并发访问**的**并发源**主要有 4 种:

- **中断和异常**: 中断发生后, **中断处理程序**和**被中断的进程**之间有可能产生**并发访问**.
- **软中断**和**tasklet**: 软中断或者 tasklet 随时可能会**被调度执行**, 从而**打断**当前正在执行的**进程上下文**.
- **内核抢占**: 调度器支持可抢占特性, 会导致**进程和进程之间的并发访问**.
- **多处理器**并发执行: 多处理器上可以同时运行多个进程.

上述情况需要针对**单核**和**多核系统**进行区别对待. 对于**单处理器**的系统(uniprocessor), 主要有如下并发源.

- **中断处理程序**可以打断**软中断**、**tasklet**和**进程上下文**的**执行**.
- 软中断和 tasklet 之间不会并发, 但是可以打断进程上下文的执行.
- 在支持抢占的内核中, 进程上下文之间会并发.
- 在不支持抢占的内核中, 进程上下文之间不会产生并发.

对于 SMP 系统, 情况会更为复杂.

- 同一类型的中断处理程序不会并发, 但是不同类型的中断有可能送达到不同的 CPU 上, 因此不同类型的中断处理程序可能会存在并发执行.
- 同一类型的软中断会在不同的 CPU 上并发执行.
- 同一类型的 tasklet 是串行执行的, 不会在多个 CPU 上并发.
- 不同 CPU 上的进程上下文会并发.

例如**进程上下文**在操作某个**临界资源**时发生了**中断**, 恰巧某个**中断处理程序**中也**访问了这个资源**, 如果不使用内核同步机制来保护, 那么会发生并发访问的 bug.

如果**进程上下文**正在访问和修改**临界区资源**时发生了**抢占调度**, 可能会发生并发访问的 bug.

如果在**spinlock 临界区**中主动睡眠让出**CPU**, 那也可能是一个并发访问的 bug.

如果**两个 CPU**同时修改一个**临界区资源**, 那也可能是一个 bug. 在**实际工程**中, 真正困难的是**如何发现**内核代码存在**并发访问**的可能性并采取有效的保护措施. 因此在编写代码时, 应该考虑哪些资源是临界区, 应该采取哪些保护机制. 如果在代码设计完成之后再回溯查找哪些资源需要保护, 会非常困难.

在复杂的内核代码中找出需要被保护的地方是一件不容易的事情. 任何可能被并发访问的数据都需要被保护. 那究竟**什么样的数据需要被保护**呢?如果有**多个内核代码路径**可能访问到该**数据**, 那就应该给此数据加以保护. 有一个原则要记住: 是**保护资源或者数据, 而不是保护代码**, 包括静态局部变量、全局变量、共享的数据结构、Buffer 缓存、链表、红黑树等各种形式所隐含的资源数据. 在实际内核代码以及驱动编写过程中, 对资源数据需要做如下一些思考.

- 除了当前内核代码路径外, 是否还有其他内核代码路径会访问它?例如中断处理程序、工作者(worker)处理程序、tasklet 处理程序、软中断处理程序等.
-  当前内核代码路径访问该资源数据时发生被抢占, 被调度执行的进程会不会访问该数据?
- 进程会不会睡眠阻塞等待该资源?

Linux 内核提供了**多种并发访问的保护机制**, 例如**原子操作**、**自旋锁**、**信号量**、**互斥体**、**读写锁**、**RCU**等, 本章将详细分析这些锁机制的实现. 了解 Linux 内核中各种锁的实现机制只是第一步, 重要的是要思考清楚哪些地方是临界区, 该用什么机制来保护这些临界区. 在第 4.7 节中, 将以内存管理为例来探讨锁的运用.