### 操作系统基本概念

操作系统启动时, 内核被装入到 RAM 中.

操作系统必须完成两个主要目标:

- 与硬件部分交互, 为包含在硬件平台上所有底层可编程部件提供服务.
- 为运行在计算机系统上的应用程序(即用户程序)提供执行环境

一些操作系统允许所有用户程序都直接与硬件部分进行交互(MS-DOS). 相反, 类 Unix 系统把与计算机物理组织相关的所有底层细节都对用户运行的程序隐藏起来. 当程序想使用硬件资源, 必须向操作系统发一个请求, 内核对这个请求进行评估, 如果允许使用这个资源, 那么, 内核代表应用程序与相关的硬件部分进行交互.

为实施这种机制, 现代操作系统依靠特殊的硬件特性来禁止用户程序直接与底层硬件进行交互, 或禁止直接访问任意的物理地址. 特别是, 硬件为 CPU 引入了至少两种不同的执行模式: 用户程序的非特权模式和内核的特权模式. Unix 把他们称为用户态(User Mode)和内核态(Kernel Mode).

#### 多用户系统(multiuser system)

能够并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机. "并发"(concurrently)意味着几个应用程序能同时处于活动状态并竞争各种资源, 如 CPU、内存、硬盘等等. "独立"(independently)意味着每个应用程序能执行自己的任务, 而无需考虑其他用户的应用程序在干些什么.

多用户操作系统必须包含以下几个特点:

- 核实用户身份的认证机制.
- 防止有错误的用户程序妨碍其他应用程序在系统中运行的保护机制.
- 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制.
- 限制分配给每个用户的资源数的记账限制.

为确保能实现这些安全保护机制, 操作系统必须利用与 CPU 特权模式相关的硬件保护机制, 否则, 用户程序将能直接访问系统电路并克服强加于它的限制. Unix 是实施系统资源硬件保护的多用户系统.

#### 用户和组

在多用户系统中, 每个用户在机器上都有私用空间. 操作系统必须保证用户空间的私有部分仅仅对其拥有者是可见的. 特别是, 要能保证没有用户能开发一个用于侵犯其他用户私有空间的系统应用程序.

所有的用户都由一个唯一的数字来标识, 这个数字叫用户标识符(User ID, UID). 组由唯一的用户组标识符(user group ID)标识.

任何类 Unix 系统都有一个特殊的用户, 叫 root, 即超级管理员(superuser).

#### 进程

一个进程在地址空间(adress space)中执行一个单独的指令序列. 地址空间是允许进程引用的内存地址集合. 现代操作系统允许具有多个执行流的进程, 也就是说, 在相同的地址空间可执行多个指令序列.

对于多道程序系统(multiprogramming)或多处理系统(multiprocessing). CPU 的个数是有限的, 操作系统中叫做调度程序(scheduler)的部分决定哪个进程能执行. 一些操作系统只允许有非抢占式(nonpreemptable)进程, 意味着, 只有当进程自愿放弃 CPU 时候, 调度程序才会被调用. 但多用户系统中的进程必须是抢占式的(preemptable); 操作系统记录下来每个进程占有的 CPU 时间, 并周期性地激活调度程序.

Unix 是具有抢占式进程的多处理操作系统. 即使没有用户登录, 没有程序运行, 也是有几个系统进程在监视外围设备. 尤其, 有几个进程在监听系统终端等待用户登录, 当用户输入一个登录名, 监听进程就运行一个程序来验证用户的口令. 对于每个用户命令, shell 进程都创建执行相应程序的另一个进程.

类 Unix 操作系统采用进程/内核模式. 每个进程都自以为它是系统中唯一的进程, 可以独占操作系统所提供的服务. 只要进程发出系统调用(即对内核提出请求), 硬件就会把特权模式由用户态变成内核态, 然后进程开始一个内核过程的执行. 这样, 操作系统在进程的执行上下文中起作用, 以满足进程的请求. 一旦请求得到满足, 内核过程将被迫使硬件返回到用户态, 然后进程从系统调用的下一条指令继续执行.

#### 内核体系结构
