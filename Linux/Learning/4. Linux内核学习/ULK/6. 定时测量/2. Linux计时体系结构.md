Linux 必定执行与定时相关的操作.

Linux 的计时体系结构(timekeeping architecture)是一组与时间流相关的内核数据结构和函数. 实际上, 80x86 多处理器机器所具有的计时体系结构与单处理器有所不同.

- 单处理器系统, 所有计时活动由全局定时器(可编程间隔定时器或高精度事件定时器)产生的中断触发.

- 多处理器系统, 所有普通活动(像软定时器的处理)都是由全局定时器产生的中断触发, 而具体的 CPU 活动(监控当前运行进程的执行时间)由本地 APIC 定时器产生的中断触发.

Linux 的计时体系结构还依赖于时间戳计数器(TSC)、ACPI 电源管理定时器、高精度事件定时器(HPET)的可用性. 内核使用两个基本的计时函数: 一个保持当前最新的时间, 一个计算在当前秒内走过的纳秒数.

## 计时体系结构的数据结构

### 定时器对象

为使用一种统一的方法来处理可能存在的定时器资源, 内核使用了"定时器对象", 它是 timer_opts 类型的一个描述符.

### jiffies 变量

jiffies 变量是一个计数器, 用来记录自系统启动以来产生的节拍总数. 每次时钟中断发生(每个节拍)便加 1.

### xtime 变量

存放当前时间和日期, 是一个 timespace 类型的数据结构.

xtime 变量通常每个节拍更新一次. 用户程序从 xtime 变量获得当前时间和日期. 内核也经常引用它.

## 单处理系统上的计时体系结构

单处理器系统上, 所有与定时器有关的活动都是由 IRQ 线 0 上的可编程间隔定时器产生的中断出发. 同样, Linux 中, 某些活动尽可能在中断产生后立即执行, 而其余的活动延迟.

### 初始化阶段

内核初始化期间, time_init()来建立计时体系结构, 通常操作:

(1) 初始化 xtime 变量

(2) 初始化 wall_to_monotonic 变量

(3) 如果内核支持 HPET, 它将调用 hpet_enable()函数来确认 ACPI 固件是否探测到了该芯片并将它的寄存器映射到内存地址空间中. 若是, hpet_enable()将对 HPET 芯片的第一个定时器编程使其以每秒 1000 次频率引发 IRQ 0 处的中断. 否则, 内核使用 PIT: 该芯片已经被 init_IRQ()函数编程, 使得以每秒 1000 次的频率引发 IRQ 0 处的中断.

(4) 调用 select_timer()来挑选系统中可利用的最好的定时器资源, 并设置 cur_timer 变量指向该定时器资源对应的定时器对象的地址

(5) 调用 setup_irq(0, &irq0)来创建于 IRQ0 相应的中断门, IRQ0 引脚连接着系统时钟中断源(PIT 或 HPET). irq0 变量被静态定义如下:

```
struct irqaction irq0 = {
    timer_interrupt,
    SA_INTERRUPT,
    0,
    "timer",
    NULL,
    NULL
}
```

从现在起, timer_interrupt()函数将会在每个节拍到来时被调用, 而中断被禁止, 因为 IRQ0 主描述符的状态字段中的 SA_INTERRUPT 标志被置位.

### 时钟中断处理程序

