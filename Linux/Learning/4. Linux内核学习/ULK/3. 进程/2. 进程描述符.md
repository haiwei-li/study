## 1. 进程描述符

进程描述符都是 task_struct 类型结构, 包含了与一个进程相关的所有信息.

![进程描述符](images/1.png)

图中的六个数据结构涉及进程所拥有的特殊资源, 后续讲到, 本章集中讨论两种字段: 进程的状态和进程的父/子间关系.

### 1.1 进程状态

state 字段(volatile long 类型)描述了进程当前所处的状态. 它由一组标志组成, 其中每个标志描述一种可能的状态. 如下:

- 可运行状态(TASK_RUNNING)

    正在 CPU 上运行或准备执行

- 可中断的等待状态(TASK_INTERRUPTIBLE)

    进程被挂起(睡眠), 产生硬件中断、收到信号等被唤醒进入 TASK_RUNNING 状态

- 不可中断的等待状态(TASK_UNINTERRUPTIBLE)

    特定情况(必须等待, 直到一个不能被中断的事件发生). 比如进程在打开一个设备, 相应的设备驱动开始探测相应的硬件设备时候

- 暂停状态(TASK_STOPPED)

    执行被暂停. 进程收到 SIGSTOP, SIGTSTP, SIGTTIN 或 SIGTTOUT 信号后

- 跟踪状态(TASK_TRACED)

    执行由 debugger 程序暂停. 当一个进程被另一个进程监控时(例如 debugger 执行 ptrace()系统调用), 任何信号可以将这个进程置于跟踪态

两个状态可以在进程描述符的 state 字段中, 也可以存放在 exit_state 字段中. 只有当进程的执行被终止, 进程状态才会变成这两种状态中的一种.

- 僵死状态(EXIT_ZOMBIE)

    进程的执行被终止, 但父进程还没发 wait4()或 waitpid()系统调用返回有关死亡进程的信息. 发布 wait()前, 内核不能丢弃包含在死进程描述符中的数据, 因为父进程可能还需要(参照本章"进程删除")

- 僵死撤销状态(EXIT_DEAD)

    最终态: 父进程发出 wait()或 waitpid()系统调用后被系统删除. 为防止其他执行线程在同一进程上执行 wait()类系统调用(这是一种竞争条件)(参见第五章).

注: 还有其他 wait()类的库函数, 但 Linux 依靠 wait4()和 waitpid()系统调用实现.
