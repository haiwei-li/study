
在取指令或数据的时候, 处理器的内存管理单元需要把虚拟地址转换成物理地址. 如果虚拟页没有映射到物理页, 或者没有访问权限, 处理器将生成页错误异常.

虚拟页没有映射到物理页, 这种情况通常称为缺页异常, 有以下几种情况.

(1) 访问用户栈的时候, 超出了当前用户栈的范围, 需要扩大用户栈.

(2) 当进程申请虚拟内存区域的时候, 通常没有分配物理页, 进程第一次访问的时候触发页错误异常.

(3) 内存不足的时候, 内核把进程的匿名页换出到交换区.

(4) 一个文件页被映射到进程的虚拟地址空间, 内存不足的时候, 内核回收这个文件页, 在进程的页表中删除这个文件页的映射.

(5) 程序错误, 访问没有分配给进程的虚拟内存区域.

前面四种情况, 如果页错误异常处理程序成功地把虚拟页映射到物理页, 处理程序返回后, 处理器重新执行触发异常的指令.

第五种情况, 页错误异常处理程序将会发送段违法(SIGSEGV) 信号以杀死进程.

没有访问权限, 有以下两种情况.

(1) 可能是软件有意造成的, 典型的例子是写时复制(Copy on Write, CoW): 进程分叉生成子进程的时候, 为了避免复制物理页, 子进程和父进程以只读方式共享所有私有的匿名页和文件页. 当其中一个进程试图写只读页时, 触发页错误异常, 页错误异常处理程序分配新的物理页, 把旧的物理页的数据复制到新的物理页, 然后把虚拟页映射到新的物理页.

(2) 程序错误, 例如试图写只读的代码段所在的物理页.

第一种情况, 如果页错误异常处理程序成功地把虚拟页映射到物理页, 处理程序返回后, 处理器重新执行触发异常的指令.

第二种情况, 页错误异常处理程序将会发送段违法(SIGSEGV) 信号以杀死进程.

不同处理器架构实现的页错误异常不同, 页错误异常处理程序的前面一部分是各种处理器架构自定义的部分, 后面从函数 `handle_mm_fault` 开始的部分是所有处理器架构共用的部分.