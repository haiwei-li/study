
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [背景知识](#背景知识)
  - [什么是调度器](#什么是调度器)
  - [1.2 调度策略](#12-调度策略)
  - [1.3 进程饥饿](#13-进程饥饿)
- [2 linux 进程的分类](#2-linux-进程的分类)
  - [2.1 进程的分类](#21-进程的分类)
  - [2.2 实时进程与普通进程](#22-实时进程与普通进程)
- [3 linux 调度器的演变](#3-linux-调度器的演变)
- [4 Linux 的调度器设计](#4-linux-的调度器设计)
  - [4.1 linux 进程调度器的框架](#41-linux-进程调度器的框架)
    - [4.1.1 2 个调度器](#411-2-个调度器)
    - [4.1.2 6 种调度策略](#412-6-种调度策略)
    - [4.1.3 5 个调度器类](#413-5-个调度器类)
    - [4.1.4 3 个调度实体](#414-3-个调度实体)
    - [4.1.5 调度器类的就绪队列](#415-调度器类的就绪队列)
    - [4.1.6 调度器整体框架](#416-调度器整体框架)
  - [4.2 进程的调度](#42-进程的调度)
  - [4.3 抢占标识 TIF\_NEED\_RESCHED](#43-抢占标识-tif_need_resched)
  - [4.4 内核抢占和用户抢占](#44-内核抢占和用户抢占)
  - [4.5 周期性调度器 scheduler\_tick](#45-周期性调度器-scheduler_tick)
  - [主调度器 schedule](#主调度器-schedule)
    - [主调度器](#主调度器)
    - [__schedule 完成抢占](#__schedule-完成抢占)
  - [进程上下文切换 context_switch](#进程上下文切换-context_switch)
    - [context_switch 流程](#context_switch-流程)
    - [4.7.2 为什么 switch\_to 需要 3 个参数](#472-为什么-switch_to-需要-3-个参数)
  - [处理进程优先级](#处理进程优先级)
  - [唤醒抢占](#唤醒抢占)

<!-- /code_chunk_output -->

内存中保存了对**每个进程的唯一描述**, 并通过若干结构**与其他进程连接起来**.

**调度器**面对的情形就是这样,其任务是在**程序之间共享 CPU 时间**,创造并行执行的错觉,该任务分为两个不同的部分,其中一个涉及**调度策略**, 另外一个涉及**上下文切换**.

# 背景知识

## 什么是调度器

通常来说, 操作系统是应用程序和可用资源之间的媒介.

典型的**资源**有**内存和物理设备**. 但是**CPU 也可以认为是一个资源**, 调度器可以**临时分配一个任务在上面执行(单位是时间片**). 调度器使得我们同时执行多个程序成为可能, 因此可以与具有各种需求的用户共享 CPU.

内核必须提供一种方法,在各个进程之间**尽可能公平地共享 CPU 时间**,而同时又要考虑**不同的任务优先级**.

调度器的一个重要目标是有效地分配 CPU 时间片, 同时提供很好的用户体验. 调度器还需要面对一些互相冲突的目标, 例如既要为关键实时任务最小化响应时间, 又要最大限度地提高 CPU 的总体利用率.

调度器的**一般原理**是, 按所需分配的计算能力,向系统中每个进程提供最大的公正性,或者从另外一个角度上说, 他**试图确保没有进程被亏待**.

## 1.2 调度策略

传统的 Unix 操作系统的**都奥杜算法**必须实现几个互相冲突的目标:

- 进程响应时间尽可能快

- 后台作业的吞吐量尽可能高

- 尽可能避免进程的饥饿现象

- 低优先级和高优先级进程的需要尽可能调和等等

调度策略(scheduling policy)的任务就是决定什么时候以怎么样的方式选择一个新进程占用 CPU 运行.

**传统操作系统**的调度基于**分时(time sharing**)技术: **多个进程**以"**时间多路复用**"方式运行,因为**CPU 的时间被分成"片(slice**)",给每个可运行进程分配一片 CPU 时间片,当然**单处理器**在**任何给定的时刻**只能运行**一个进程**.

如果当前可运行进程的时限(quantum)到期时(即**时间片用尽**), 而该进程还没有运行完毕, **进程切换**就可以发生.

**分时**依赖于**定时中断**, 因此**对进程是透明的**, **不需要**在承租中插入额外的代码来保证 CPU 分时.

**调度策略**也是根据进程的**优先级**对他们进行分类.有时用复杂的算法求出进程当前的优先级,但最后的结果是相同的: **每个进程**都与一个值(**优先级)相关联**, 这个值表示把进程如何适当地分配给 CPU.

**在 linux 中, 进程的优先级是动态的**.调度程序**跟踪进程正在做什么**,并**周期性的调整他们的优先级**. 在这种方式下, 在较长的时间间隔内没有任何使用 CPU 的进程,通过动态地增加他们的优先级来提升他们.相应地,对于已经在 CPU 上运行了较长时间的进程, 通过减少他们的优先级来处罚他们.

## 1.3 进程饥饿

进程饥饿, 即为**Starvation**, 指当**等待时间**给**进程推进和响应**带来**明显影响**称为**进程饥饿**. 当**饥饿到一定程度**的进程在等待到即使完成也无实际意义的时候称为**饥饿死亡**.

**产生饥饿的主要原因是**

在一个**动态系统**中, 对于**每类系统资源**, 操作系统需要**确定一个分配策略**, 当**多个进程同时申请某类资源**时, 由**分配策略**确定**资源分配给进程的次序**.

有时**资源分配策略可能是不公平**的, 即**不能保证等待时间上界的存在**. 在这种情况下, 即使**系统没有发生死锁**, 某些进程也可能会长时间等待. 当等待时间给进程推进和响应带来明显影响时, 称发生了进程饥饿, 当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该**进程被饿死**.

举个例子, 当有**多个进程需要打印文件**时, 如果系统分配打印机的策略是**最短文件优先**, 那么**长文件的打印任务**将由于短文件的**源源不断到来**而**被无限期推迟**, 导致最终的**饥饿甚至饿死**.

# 2 linux 进程的分类

## 2.1 进程的分类

当涉及**有关调度**的问题时, 传统上把进程分类为"**I/O 受限(I/O-dound**)"或"**CPU 受限(CPU-bound**)".

| 类型 | 别称 | 描述 | 示例 |
| ------- |:-------|:-------|:-------|
| I/O 受限型 | I/O 密集型 | **频繁的使用 I/O 设备**, 并花费很多时间**等待 I/O 操作的完成** | 数据库服务器, 文本编辑器 |
| CPU 受限型 | 计算密集型 | 花费大量 CPU 时间进行数值计算 | 图形绘制程序 |

另外一种分类法把进程区分为三类:

| 类型 | 描述 | 示例 |
| ------- |:-------|:-------|
| **交互式进程**(interactive process) | 此类进程经常与用户进行交互,因此需要花费**很多时间等待键盘和鼠标操作**. 当**接受了用户的输入**后, 进程**必须很快被唤醒**, 否则用户会感觉系统反应迟钝 | **shell**, **文本编辑程序**和**图形应用程序** |
| **批处理进程**(batch process) | 此类进程不必与用户交互, 因此经常**在后台运行**. 因为这样的进程**不必很快响应**, 因此常受到调度程序的怠慢 | 程序语言的**编译程序**, **数据库搜索引擎**以及科学计算 |
| **实时进程**(real-time process) | 这些进程有**很强的调度需要**,这样的进程绝不会被低优先级的进程阻塞.并且他们的**响应时间要尽可能的短** | **视频音频**应用程序,机器人控制程序以及从物理传感器上收集数据的程序|

>**注意**
>
>前面的**两类分类方法**在一定程序上**相互独立**
>
>例如, 一个**批处理进程**很有可能是**I/O 受限**的(如数据库服务器),也可能是**CPU 受限**的(比如图形绘制程序)

## 2.2 实时进程与普通进程

在 linux 中, 调度算法可以明确的**确认**所有**实时进程**的身份,但是**没办法**区分**交互式程序**和**批处理程序(统称为普通进程**),**linux2.6**的调度程序实现了**基于进程过去行为**的**启发式算法**,以确定进程应该被当做**交互式进程**还是**批处理进程**. 当然与批处理进程相比,调度程序有偏爱交互式进程的倾向

根据**进程的不同分类**Linux 采用**不同的调度策略(！！！**).

对于**实时进程**, 采用**FIFO**或者**Round Robin**的**调度策略**.

对于**普通进程**, 则需要区分**交互式**和**批处理式**的不同. **传统 Linux**调度器**提高交互式应用的优先级**, 使得它们能**更快地被调度**. 而**CFS 和 RSDL 等新的调度器**的核心思想是"**完全公平**". 这个设计理念不仅大大简化了调度器的代码复杂度, 还对各种调度需求的提供了更完美的支持.

注意**Linux**通过**将进程和线程调度视为一个**, 同时包含二者. **进程**可以看做是**单个线程**, 但是进程可以包含共享一定资源(代码和/或数据)的多个线程. 因此进程调度也包含了线程调度的功能.

**linux 进程的调度算法**其实经过了**很多次的演变**,但是其演变**主要是针对与普通进程**的, 因为前面我们提到过**根据进程的不同分类 Linux 采用不同的调度策略**.**实时进程**和**普通进程**采用了**不同的调度策略**,更一般的**普通进程**还需要**启发式的识别批处理进程和交互式进程**.

目前**实时进程**的**调度策略比较简单**,因为实时进程**只要求尽可能快的被响应**, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级, **调度器**在每次调度时, 总选择**优先级最高的进程开始执行**.**低优先级不可能抢占高优先级**, 因此**FIFO**或者**Round Robin**的**调度策略**即可满足实时进程调度的需求.

但是**普通进程的调度策略**就比较麻烦了,因为普通进程**不能简单的只看优先级**,必须**公平的占有 CPU**,否则**很容易出现进程饥饿**,这种情况下用户会感觉操作系统很卡,响应总是很慢.因此在 linux 调度器的发展历程中经过了多次重大变动,linux 总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.

此外系统中进程**如果存在实时进程**, 则**实时进程总是在普通进程之前被调度**

# 3 linux 调度器的演变

一开始的调度器是复杂度为**O(n)的始调度算法**(实际上**每次会遍历所有任务**, 所以复杂度为 O(n)),这个算法的缺点是当**内核中有很多任务**时, 调度器本身就会**耗费不少时间**, 所以, 从 linux2.5 开始引入赫赫有名的**O(1)调度器**

然而, linux 是集全球很多程序员的聪明才智而发展起来的超级内核, 没有最好, 只有更好, 在$O(1)$调度器风光了没几天就又被另一个更优秀的调度器取代了, 它就是**CFS 调度器 Completely Fair Scheduler**.这个也是在**2.6 内核中引入**的, 具体为 2.6.23, 即从此版本开始, 内核使用**CFS 作为它的默认调度器**, $O(1)$调度器被抛弃了,其实**CFS 的发展**也是经历了很多阶段, 最早期的**楼梯算法(SD**),后来逐步对 SD 算法进行改进出**RSDL(Rotating Staircase Deadline Scheduler**),这个算法已经是"完全公平"的雏形了, **直至 CFS**是最终被内核采纳的调度器,它从 RSDL/SD 中吸取了完全公平的思想, **不再跟踪进程的睡眠时间**, 也**不再企图区分交互式进程**. 它将**所有的进程都统一对待**, 这就是公平的含义. CFS 的算法和实现都相当简单, 众多的测试表明其性能也非常优越

>更多 CFS 的信息, 请参照
>
>http://www.ibm.com/developerworks/cn/linux/l-completely-fair-scheduler/index.html?ca=drs-cn-0125
>
>另外内核文档 sched-design-CFS.txt 中也有介绍

| 字段 | 版本 |
| ------------- |:-------------:|
| O(n)的始调度算法 | linux-0.11~2.4 |
| O(1)调度器 | linux-2.5 |
| CFS 调度器 | linux-2.6~至今 |

关于调度器发展的详细内容, 可以阅读[Linux 进程调度策略的发展和演变--Linux 进程的管理与调度(十六)](http://blog.csdn.net/gatieme/article/details/51701149)

# 4 Linux 的调度器设计

## 4.1 linux 进程调度器的框架

### 4.1.1 2 个调度器

可以用**两种方法来激活调度**

- 一种是**直接的**, 比如**进程打算睡眠**或出于**其他原因放弃 CPU**

- 另一种是通过**周期性的机制**, 以**固定的频率运行**, 不时的检测是否有必要

因此当前**linux 的调度程序**由**两个调度器组成**:

- **主调度器**

- **周期性调度器**

两者又统称为**通用调度器(generic scheduler)**或**核心调度器(core scheduler)**

并且**每个调度器**包括两个内容: **调度框架**(其实质就是**两个函数框架**)及**调度器类**

### 4.1.2 6 种调度策略

linux 内核目前实现了**6 种调度策略**(即**调度算法**),用于**对不同类型的进程**进行调度,或者**支持某些特殊的功能**

比如**SCHED\_NORMAL**和**SCHED\_BATCH**调度普通的**非实时进程**,**SCHED\_FIFO**和**SCHED\_RR**和**SCHED\_DEADLINE**则采用不同的调度策略调度**实时进程**,**SCHED\_IDLE**则在系统**空闲时调用 idle 进程**.

>idle 的运行时机
>
>idle 进程优先级为**MAX\_PRIO**, 即**最低优先级**.
>
>**早先版本**中, **idle 是参与调度**的, 所以将其**优先级设为最低**, 当**没有其他进程可以运行**时, 才会**调度执行 idle**
>
>而目前的版本中**idle 并不在运行队列中参与调度**, 而是在**cpu 全局运行队列 rq 中含 idle 指针**, 指向 idle 进程, 在调度器发现**运行队列为空**的时候运行, 调入运行

| 字段 | 描述 | 所在调度器类 |
| ------------- |:-------------|:-------------|
| SCHED\_NORMAL | (也叫**SCHED\_OTHER**)用于**普通进程**, 通过**CFS 调度器**实现. **SCHED\_BATCH**用于**非交互的处理器消耗型进程**. **SCHED\_IDLE**是在**系统负载很低**时使用 | CFS |
| **SCHED\_BATCH** |  SCHED\_NORMAL 普通进程策略的分化版本. 采用分时策略, 根据动态优先级(可用 nice()API 设置), 分配 CPU 运算资源. 注意: 这类进程比上述两类实时进程优先级低, 换言之, 在有实时进程存在时, 实时进程优先调度. 但针对吞吐量优化,**除了不能抢占外与常规任务一样**, 允许任务运行更长时间, 更好地使用高速缓存, 适合于成批处理的工作 | CFS |
| **SCHED\_IDLE** | **优先级最低**, 在系统空闲时才跑这类进程(如利用闲散计算机资源跑地外文明搜索, 蛋白质结构分析等任务, 是此调度策略的适用者)| **CFS\-IDLE** |
| **SCHED\_FIFO** | **先入先出**调度算法(**实时调度策略**), **相同优先级**的任务**先到先服务**, **高优先级**的任务可以**抢占低优先级**的任务 | RT |
| **SCHED\_RR** | **轮流调度**算法(实时调度策略), 后者提供 Round\-Robin 语义, 采用**时间片**, **相同优先级**的任务当**用完时间片**会被放到**队列尾部**, 以保证公平性, 同样, **高优先级**的任务可以**抢占低优先级**的任务. 不同要求的实时任务可以根据需要用 sched\_setscheduler() API 设置策略 | RT |
| **SCHED\_DEADLINE** | 新支持的**实时进程调度策略**, 针对**突发型计算**, 且**对延迟和完成时间高度敏感**的任务适用. 基于**Earliest Deadline First (EDF**) 调度算法| **DL** |

linux 内核实现的**6 种调度策略**,前面**三种策略**使用的是**cfs 调度器类**, 后面**两种**使用**rt 调度器类**,最后**一个**使用**DL 调度器类**

### 4.1.3 5 个调度器类

而依据其**调度策略的不同**实现了**5 个调度器类**,**一个调度器类**可以用**一种**或者**多种调度策略**调度某一类进程, 也可以用于**特殊情况**或者**调度特殊功能**的进程.

| 调度器类 | 描述 | 对应调度策略 |
| ------- |:-------|:-------:|
| **stop\_sched\_class** | **优先级最高**的线程, 会**中断所有**其他线程, 且**不会被其他任务打断**<br>作用:<br>1.发生在**cpu\_stop\_cpu\_callback** 进行**cpu 之间任务 migration**<br>2.**HOTPLUG\_CPU**的情况下关闭任务 | 无, 不需要调度普通进程 |
| dl\_sched\_class | 采用 EDF**最早截至时间优先算法**调度实时进程 | SCHED\_DEADLINE |
| rt\_sched\_class | 采用提供**Roound\-Robin 算法**或者**FIFO 算法**调度实时进程<br>具体**调度策略**由进程的**task\_struct\->policy 指定** | SCHED\_FIFO, SCHED\_RR |
| fair\_sched\_clas  | 采用**CFS 算法调度普通的非实时进程** | SCHED\_NORMAL, SCHED\_BATCH |
| idle\_sched\_class | 采用**CFS 算法调度 idle 进程**,每个 cup 的第一个 pid=0 线程: swapper, 是一个静态线程. 调度类属于: idel\_sched\_class, 所以在**ps 里面是看不到**的. 一般运行在开机过程和 cpu 异常的时候做 dump | SCHED\_IDLE |

其所属进程的优先级顺序为

```c
stop_sched_class -> dl_sched_class -> rt_sched_class -> fair_sched_class -> idle_sched_class
```

### 4.1.4 3 个调度实体

**调度器不限于调度进程**,还可以**调度更大的实体**,比如实现**组调度**:可用的 CPU 时间首先在一半的进程组(比如, 所有进程按照所有者分组)之间分配, 接下来分配的时间再在组内进行二次分配.

这种一般性要求**调度器不直接操作进程**,而是**处理可调度实体**,因此需要一个通用的数据结构描述这个调度实体,即**seched\_entity 结构**,其实际上就**代表了一个调度对象**, 可以为**一个进程**, 也可以为**一个进程组**.

linux 中针对当前**可调度的实时和非实时进程**, 定义了类型为 seched\_entity 的 3 个调度实体

| 调度实体 | 名称 | 描述 | 对应调度器类 |
| ------- |:-------|:-------|:-------|
| sched\_dl\_entity | **DEADLINE 调度实体** | 采用**EDF 算法**调度的**实时调度实体** | dl\_sched\_class |
| sched\_rt\_entity |  **RT 调度实体** | 采用**Roound-Robin 或者 FIFO 算法**调度的**实时调度实体** | rt\_sched\_class |
| sched\_entity | **CFS 调度实体** | 采用**CFS**算法调度的**普通非实时进程的调度实体** | fair\_sched\_class |

### 4.1.5 调度器类的就绪队列

另外, 对于**调度框架**及**调度器类**, 它们都有自己管理的**运行队列**, **调度框架只识别 rq**(其实它也**不能算是运行队列**), 而对于**cfs 调度器类**它的运行队列则是**cfs\_rq**(内部使用**红黑树组织调度实体！！！**), **实时 rt**的运行队列则为**rt\_rq**(内部使用**优先级 bitmap\+双向链表组织调度实体！！！**),此外内核对**新增的 dl 实时调度策略**也提供了运行队列**dl\_rq**

### 4.1.6 调度器整体框架

本质上, **通用调度器(核心调度器**)是一个**分配器**,与其他**两个组件**交互.

- 调度器用于判断**接下来运行哪个进程**.

内核支持不同的调度策略(完全公平调度,实时调度,在无事可做的时候调度空闲进程<即 0 号进程也叫 swapper 进程>,idle 进程), **调度类**使得能够以**模块化**的方法**实现这些策略**,即**一个类的代码不需要与其他类的代码交互**

当**调度器被调用**时, 他会**查询调度器类**, 得知接下来运行哪个进程

- 在选中将要运行的进程之后, 必须执行**底层的任务切换**.

这需要与 CPU 的紧密交互. **每个进程**刚好**属于某一调度类**,各个调度类负责管理所属的进程.**通用调度器**自身**不涉及进程管理**, 其工作都委托给调度器类.

**每个进程**都属于**某个调度器类**(由字段**task\_struct\->sched\_class**标识),由**调度器类(！！！**)采用进程对应的**调度策略调度**(由**task\_struct\->policy**)进行调度,**task\_struct**也存储了其对应的**调度实体标识**

linux 实现了**6 种调度策略**,依据其**调度策略的不同**实现了**5 个调度器类**,**一个调度器类**可以用**一种或者多种调度策略**调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.

| 调度器类 | 调度策略 |  调度策略对应的调度算法 | 调度实体 | 调度实体对应的调度对象 |
| ------- |:-------:|:-------:|:-------:|:-------:|
| stop\_sched\_class | 无 | 无 | 无 | 特殊情况,发生在 cpu\_stop\_cpu\_callback 进行 cpu 之间任务迁移 migration 或者 HOTPLUG\_CPU 的情况下关闭任务 |
| dl\_sched\_class | SCHED\_DEADLINE | Earliest\-Deadline\-First 最早截至时间有限算法 | sched\_dl\_entity | 采用 DEF 最早截至时间有限算法调度实时进程 |
| rt\_sched\_class | SCHED\_RR<br><br>SCHED\_FIFO | Roound\-Robin 时间片轮转算法<br><br>FIFO 先进先出算法 | sched\_rt\_entity | 采用 Roound\-Robin 或者 FIFO 算法调度的实时调度实体 |
| fair\_sched\_class | SCHED\_NORMAL<br><br>SCHED\_BATCH | CFS 完全公平懂调度算法 |sched\_entity | 采用 CFS 算法普通非实时进程 |
| idle\_sched\_class | SCHED\_IDLE | **无** | **无** | **特殊进程**, 用于 cpu 空闲时调度空闲进程 idle |

**调度器组成**的关系如下图

![调度器的组成](./images/level.jpg)

**5 种调度器类为什么只有 3 种调度实体**

正常来说一个调度器类应该对应一类调度实体, 但是 5 种调度器类却只有了 3 种调度实体?

这是因为**调度实体**本质是一个**可以被调度的对象**, 要么是一个**进程**(linux 中线程本质上也是进程), 要么是一个**进程组**, 只有**dl\_sched\_class**,**rt\_sched\_class**调度的**实时进程(组**)以及**fair\_sched\_class**调度的**非实时进程(组**)是**可以被调度的实体对象**,而 stop\_sched\_class 和 idle\_sched\_class 没有调度实体

**为什么采用 EDF 实时调度需要单独的调度器类, 调度策略和调度实体**

linux 针对**实时进程**实现了**Roound\-Robin**, **FIFO**和**Earliest-Deadline\-First(EDF)算法**, 但是为什么**SCHED\_RR**和**SCHED\_FIFO**两种调度算法都用**rt\_sched\_class 调度类**和**sched\_rt\_entity 调度实体**描述, 而**EDF 算法**却需要单独用**rt\_sched\_class 调度类**和**sched\_dl\_entity 调度实体**描述

为什么采用 EDF 实时调度不用 rt\_sched\_class 调度类调度, 而是单独实现调度类和调度实体?

## 4.2 进程的调度

首先, 我们需要清楚, 什么样的进程会**进入调度器**进行选择, 就是处于**TASK\_RUNNING 状态的进程**, 而其他状态下的进程都不会进入调度器进行调度.

**系统发生调度的时机**如下

- **调用 cond\_resched**()时

- **显式调用 schedule**()时

- 从**系统调用**或者**异常中断返回用户空间**时

- 从**中断上下文**返回**用户空间**时

当开启**内核抢占**(**默认开启**)时, 会**多出几个调度时机**, 如下

- 在**系统调用**或者**异常中断上下文**中调用**preempt\_enable**()时(**多次调用**preempt\_enable()时, 系统只会在**最后一次调用时会调度**)

- 在**中断上下文**中, 从**中断处理函数返回到可抢占的上下文**时(这里是**中断下半部**, **中断上半部实际上会关中断**, 而**新的中断只会被登记**, 由于上半部处理很快, **上半部处理完成后**才会**执行新的中断信号**, 这样就形成了**中断可重入**)

而在**系统启动调度器初始化**时会**初始化一个调度定时器(！！！**), 调度定时器**每隔一定时间执行一个中断**, 在**中断中**会对**当前运行进程运行时间进行更新**, 如果**进程需要被调度**, 在**调度定时器中断中**会设置一个**调度标志位**, 之后**从定时器中断返回**, 因为上面已经提到从中断上下文返回时是有调度时机的, 在内核源码的汇编代码中**所有中断返回处理(！！！**)都必须去判断调度标志位是否设置, 如**设置则执行 schedule()进行调度**.

而我们知道**实时进程和普通进程是共存的**, 调度器是**怎么协调它们之间的调度**的呢, 其实很简单, **每次调度**时, 会**先在实时进程运行队列**中查看是否有可运行的实时进程, 如果**没有**, 再去**普通进程运行队列**找下一个可运行的普通进程, 如果**也没有**, 则调度器会**使用 idle 进程进行运行**.

之后的章节会放上代码进行详细说明.

系统**并不是每时每刻都允许调度的发生**, 当处于**硬中断期间**的时候, **调度是被系统禁止**的, 之后硬中断过后才重新允许调度. 而**对于异常**, 系统并**不会禁止调度**, 也就是在**异常上下文**中, 系统是**有可能发生调度**的.

## 4.3 抢占标识 TIF\_NEED\_RESCHED

内核在检查**need\_resched 标识 TIF\_NEED\_RESCHED 的值**判断**是否需要抢占当前进程**,内核在**thread\_info**的**flag**中设置了**一个标识来标志进程是否需要重新调度**,即重新调度 need\_resched 标识 TIF\_NEED\_RESCHED,内核**在即将返回用户空间时**会检查标识 TIF\_NEED\_RESCHED 标志进程是否需要重新调度

系统中**每个进程**都有一个特定于体系结构的 struct thread\_info 结构,**用户层程序**被调度的时候会检查 struct thread\_info 中的 need\_resched 标识 TLF\_NEED\_RESCHED 标识来检查自己**是否需要被重新调度**.

如果**内核检查进程的抢占标识被设置**, 则会**在一个关键的时刻**, 调用调度器来完成调度和抢占的工作

## 4.4 内核抢占和用户抢占

而根据进程抢占发生的时机,抢占可以分为**内核抢占**和**用户抢占**.

**内核抢占**就是指一个在**内核态运行的进程**, 可能在**执行内核函数期间被另一个进程取代**

一般来说, **用户抢占**发生几下情况:

- 从**系统调用返回用户空间**;

- 从**中断(异常)处理程序返回用户空间**

**内核抢占**发生的时机, 一般发生在:

- 当从**中断处理程序正在执行**, 且**返回内核空间之前**. 当一个**中断处理例程退出**, 在返回到内核态时(kernel-space). 这是**隐式的调用 schedule()函数**, 当前任务**没有主动放弃 CPU 使用权**, 而是**被剥夺了 CPU 使用权**.

- 当**内核代码**再一次具有可抢占性的时候, 如解锁(spin\_unlock\_bh)及使能软中断(local\_bh\_enable)等, 此时当 kernel code**从不可抢占状态变为可抢占状态时(preemptible again**). 也就是**preempt\_count 从正整数变为 0**时. 这也是**隐式的调用 schedule()函数**

- 如果**内核中的任务显式的调用 schedule**(), 任务**主动放弃 CPU 使用权**

- 如果**内核中的任务阻塞**(这同样也会导致调用 schedule()),导致**需要调用 schedule()函数**. 任务**主动放弃 CPU 使用权**

内核抢占采用同抢占标识的类似方法被实现,linux 内核在 thread\_info 结构中添加了一个**自旋锁标识 preempt\_count**, 称为**抢占计数器(preemption counter)**.

```c
struct thread_info
{
 /*  ......  */
 int preempt_count;  /* 0 => preemptable, <0 => BUG */
    /*  ......  */
}
```

| preempt_count 值 | 描述 |
| ------- |:-------|
| \>0 | **禁止内核抢占**, 其值标记了**使用 preempt\_count 的临界区的数目** |
| 0 | 开启内核抢占 |
| \<0 | 锁为负值, **内核出现错误** |

内核自然也提供了一些函数或者宏,用来**开启,关闭以及检测抢占计数器 preempt\_coun 的值**,这些通用的函数定义在[include/asm-generic/preempt.h](http://lxr.free-electrons.com/source/include/asm-generic/preempt.h?v=4.6#L8), 而某些架构也定义了自己的接口, 比如 x86 架构[/arch/x86/include/asm/preempt.h](http://lxr.free-electrons.com/source/arch/x86/include/asm/preempt.h?v=4.6)

>详细内容请参见 [Linux 用户抢占和内核抢占详解(概念, 实现和触发时机)--Linux 进程的管理与调度(二十)](http://blog.csdn.net/gatieme/article/details/51872618)

## 4.5 周期性调度器 scheduler\_tick

**周期性调度器 scheduler\_tick**由**内核时钟中断周期性的触发**,周期性调度器以**固定的频率**激活**负责当前进程调度类的周期性调度方法**,以保证**系统的并发性**,周期性调度器通过**调用进程所属调度器类的 task\_tick 操作**完成周期性调度的**通知和配置工作**,通过**resched\_curr 函数**(早期的 resched\_task 函数)设置**抢占标识 TIF\_NEED\_RESCHED(！！！**)来通知内核在**必要的时间**由**主调度函数(！！！)完成真正的调度工作**,此种做法称之为延迟调度策略

>关于周期性调度器的详细信息, 参见[Linux 核心调度器之周期性调度器 scheduler\_tick--Linux 进程的管理与调度(十八)](http://blog.csdn.net/gatieme/article/details/51872561)

## 主调度器 schedule

### 主调度器

**schedule**就是**主调度器的工作函数**, 在内核中的许多地方, 如果要**将 CPU 分配给**与当前活动进程不同的**另一个进程**, 都会**直接调用主调度器函数** `schedule()` 或者其**子函数** `__schedule`.

### __schedule 完成抢占

- 完成一些**必要的检查**, 并**设置进程状态**, 处理**进程所在的就绪队列**

- 调度全局的 `pick_next_task` 选择**抢占的进程**

    - 如果**当前 cpu**上**所有的进程**都是**cfs 调度的普通非实时进程**,则**直接用 cfs 调度**,如果**无程序可调度则调度 idle 进程**

    - 否则**从优先级最高的调度器类 sched\_class\_highest(目前是 stop\_sched\_class**)开始**依次遍历所有调度器类的 pick\_next\_task 函数**, 选择**最优的那个进程**执行

- context\_switch 完成**进程上下文切换**

    - 调用**switch\_mm**(), 把**虚拟内存**从一个进程映射**切换到新进程**中

    - 调用 switch\_to(),从上一个进程的**处理器状态**切换到新进程的处理器状态. 这包括**保存、恢复栈信息和寄存器信息**

>主调度器的详细信息, 可以参考 [Linux 进程核心调度器之主调度器--Linux 进程的管理与调度(十九)](http://blog.csdn.net/gatieme/article/details/51872594)

## 进程上下文切换 context_switch

### context_switch 流程

**context\_switch**其实是一个**分配器**, 他会调用所需的**特定体系结构的方法**

- 调用 switch\_mm(), 把虚拟内存从一个进程映射切换到新进程中

    - switch\_mm 更换**通过 task\_struct->mm 描述的内存管理上下文**,该工作的细节取决于处理器,要包括加载页表, 刷出地址转换后备缓冲器(部分或者全部), 向内存管理单元(MMU)提供新的信息

- 调用 switch\_to(),从上一个进程的处理器状态切换到新进程的**处理器状态**. 这包括保存、恢复栈信息和寄存器信息

 - switch\_to 切换**处理器寄存器的内容**和**内核栈**(虚拟地址空间的**用户部分**已经通过**switch\_mm 变更**, 其中**也包括了用户状态下的栈**, 因此**switch\_to 不需要变更用户栈**, 只需**变更内核栈**), 此段代码**严重依赖于体系结构**, 且代码通常都是用**汇编语言编写**.

### 4.7.2 为什么 switch\_to 需要 3 个参数

在**新进程被选中执行**时,内核恢复到**进程被切换出去的点继续执行**,此时内核**只知道谁之前将新进程抢占**了, 但是却不知道**新进程再次执行是抢占了谁**,因此底层的进程切换机制必须将**此前执行的进程**(即**新进程抢占的那个进程**)提供给**context\_switch**.由于**控制流会回到函数的该中间**,因此**无法通过普通函数的返回值**来完成.因此使用了一个**3 个参数**,但是逻辑效果是相同的,仿佛是 switch\_to 是带有两个参数的函数, 而且返回了一个**指向此前运行的进程的指针**.

```c
switch_to(prev, next, last);

即

prev = last = switch_to(prev, next);
```
其中**返回的 prev 值**并**不是做参数的 prev 值**, 而是 prev 被再次调度的时候**抢占掉的那个进程 last**.

详情请参见, [Linux 进程上下文切换过程 context_switch 详解--Linux 进程的管理与调度(二十一)](http://blog.csdn.net/gatieme/article/details/51872659)

## 处理进程优先级

内核使用一些简单的数值范围**0\~139 表示内部优先级**, **数值越低, 优先级越高**.

- 从**0\~99**的范围专供**实时进程**使用,

- nice 的值[\-20,19]则映射到范围**100\~139**

![config](images/priority.jpg)

动态优先级 静态优先级 实时优先级

其中**task\_struct**采用了三个成员表示进程的优先级:**prio 和 normal\_prio 表示动态优先级**,**static\_prio 表示进程的静态优先级**.

此外还用了一个字段 rt\_priority 保存了**实时进程的优先级**

|字段 | 描述 |
|:-------|:-------|
| static\_prio | 用于保存**静态优先级**, 是**进程启动时分配的优先级**, , 可以通过**nice**和**sched\_setscheduler 系统调用**来进行修改, 否则在进程运行期间会一直保持恒定 |
| prio | 保存进程的**动态优先级** |
| normal\_prio | 表示**基于进程的静态优先级 static\_prio 和调度策略**计算出的优先级. 因此即使**普通进程**和**实时进程**具有**相同的静态优先级**, 其**普通优先级也是不同**的, **进程分叉(fork**)时, **子进程会继承父进程的普通优先级** |
| rt\_priority | 用于保存实时优先级, **实时进程的优先级**用实时优先级 rt\_priority 来表示 |

**静态优先级 static\_prio**(**普通进程**)和**实时优先级 rt\_priority**(**实时进程**)是**计算的起点**

因此他们也是**进程创建的时候设定好的**,我们通过**nice 修改**的就是**普通进程的静态优先级 static\_prio**

首先通过**静态优先级 static\_prio**计算出**普通优先级 normal\_prio**,该工作可以由 normal\_prio 来完成, 该函数定义在[kernel/sched/core.c#L861](http://lxr.free-electrons.com/source/kernel/sched/core.c?v=4.6#L861)

内核通过**effective\_prio**设置**动态优先级 prio**, 计算动态优先级的流程如下

```c
static int effective_prio(struct task_struct *p)
{
 p->normal_prio = normal_prio(p);
 /*
  * If we are RT tasks or we were boosted to RT priority,
  * keep the priority unchanged. Otherwise, update priority
  * to the normal priority:
  */
 if (!rt_prio(p->prio))
  return p->normal_prio;
 return p->prio;
}
```

- 设置进程的**普通优先级 normal\_prio**(**实时进程 99 \- rt\_priority**,**普通进程为 static\_priority**)

- 计算进程的**动态优先级**(**实时进程**则维持**动态优先级的 prio 不变**,**普通进程**的**动态优先级**即为其**普通优先级**)

最后, 我们综述一下在针对**不同类型进程**的计算结果

| 进程类型  | 实时优先级 rt\_priority | 静态优先级 static\_prio | 普通优先级 normal\_prio | 动态优先级 prio |
| ------- |:-------|:-------|:-------|:--------|
| **EDF 调度**的**实时进程** | rt\_priority | 不使用 | MAX\_DL\_PRIO\-1 | 维持原 prio 不变 |
| **RT 算法**调度的**实时进程** | rt\_priority | 不使用 | MAX\_RT\_PRIO\-1\-rt\_priority | 维持原 prio 不变 |
| **普通进程** | 不使用 | static\_prio | static\_prio | static\_prio |
| **优先级提高的普通进程** | 不使用 | static\_prio(改变) | static\_prio | 维持原 prio 不变 |

>关于进程优先级的详细信息请参见[Linux 进程优先级的处理--Linux 进程的管理与调度(二十二)](http://blog.csdn.net/gatieme/article/details/51719208)

## 唤醒抢占

当在**try\_to\_wake\_up/wake\_up\_process 和 wake\_up\_new\_task**中**唤醒进程**时,内核使用**全局 check\_preempt\_curr**看看**是否进程可以抢占当前运行的进程**.

**每个调度器类**都因此应该实现一个**check\_preempt\_curr 函数**,在全局 check\_preempt\_curr 中会调用**进程其所属调度器类 check\_preempt\_curr**进行抢占检查,对于完全公平调度器 CFS 处理的进程,则对应由 check\_preempt\_wakeup 函数执行该策略.

**新唤醒的进程**不必一定由完全公平调度器处理, 如果新进程是一个**实时进程**, 则会立即**请求调度**, 因为实时进程优先极高, 实时进程总会抢占 CFS 进程

参见[Linux 唤醒抢占----Linux 进程的管理与调度(二十三)](http://blog.csdn.net/gatieme/article/details/51872831)

内核为了**实现完全公平**,对**一些交互式进程有补偿机制**,这些**交互式进程**多数情况下属于**睡眠状态**, 只有在**接收到信号以后被唤醒**, 比如 vim 在接收了键盘录入的信号后被唤醒, 完成工作后又进入睡眠态, 因此我们需要对唤醒的进程做一些补偿, 关于补偿的内容我们会在各个调度器类的设计中讲解.