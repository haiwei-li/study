https://blog.csdn.net/ace_an/article/details/53813242

## Linux 中最重要最常用如下四种:

### LIST: 链表 <linux/list.h>

- Linux 内核的标准链表就是采用"环形、双向"链表形式实现
- 沿着链表移动只能是线性移动
- **需要随机访问的数据, 一般不使用链表**
- 链表存放数据的理想情况是: 需要遍历所有数据、或者需要动态加入/删除数据
- 有时首元素会用一个特殊的指针表示, 称为"头指针", 可以方便的找到链表的"起始端"
- Linux 内核实现特殊性: 不是将数据结构塞入链表, 而是**将链表结点塞入数据结构**
- Linux 内核链表操作函数的复杂度都是 O(1), 而不管链表中元素数目的多少

    - list\_add\_\_list\_add
    - list\_add\_tail\_\_list\_add\_tail
    - list\_del\_\_list\_del
    - list\_del\_init\_\_list\_del\_init
    - list\_move\_\_list\_move
    - list\_move\_tail\_\_list\_move\_tail
    - list\_empty\_\_list\_empty
    - list\_entry\_\_list\_entry
    - list\_splice\_\_list\_splice
    - list\_splice\_init\_\_list\_splice\_init

- Linux 内核遍历链表的复杂度是 O(n), n 是链表元素数目

    - list\_for\_each
    - list\_for\_each\_entry
    - list\_for\_each\_entry\_reverse 反向遍历链表, 有二原因: 1)当反向遍历性能好时; 2)当遍历顺序很重要时;
    - list\_for\_each\_entry\_safe 该函数允许在遍历链表循环体中删除元素, 普通遍历函数不允许这样做
    - list\_for\_each\_entry\_safe\_reverse

链表操作函数分为外部函数、内部函数, 函数同名, 只差双下划线\_\_, 内部函数用 prev、next 参数

### FIFO: 队列 <linux/kfifo.h>

- Linux 内核通用队列实现称为 kfifo, 实现在文件 kernel/kfifo.c 中
- 维护两个偏移量:
    - 入口偏移(下一次入队时位置)>=出口偏移(下一次出队时位置);
    - 入口偏移==出口偏移, 说明队列空了;
    - 入口偏移==队列长度, 说明队列重置前不能再有入队操作;
- 提供两个主要操作:
    - 入队 enqueue(copy 数据到队列入口偏移位置)
    - 出队 dequeue(从队列出口偏移 copy 数据)
- 队列操作:
    - kfifo\_alloc 动态创建、初始化 (size 需是 2 的 n 次幂)
    - kfifo\_init 动态创建、初始化, 但使用已分配内存 (size 同上)
    - DECLARE\_KFIFO/INIT\_KFIFO 静态声明, 不常用(size 同上)
    - kfifo\_in   入队
    - kfifo\_out   出队
    - kfifo\_out\_peek   不出队, 只返回数据
    - kfifo\_size   队列总体空间(长度)
    - kfifo\_len   队列已用空间
    - kfifo\_avail   队列剩余空间
    - kfifo\_is\_empty   判定队列空
    - kfifo\_is\_full   判定队列满
    - kfifo\_reset   重置队列(抛弃所有元素)
    - kfifo\_free   释放 kfifo\_alloc 创建的队列

### 映射:

- 称为关联数组, 由"键<==>值"对儿组成的集合;
- "键"是唯一的, "值"关联到键;
- 映射操作:
    - Add (key, value)   增加
    - Remove (key)   删除
    - Value = Lookup (key)   查找
    - Allocate   插入键值对, 产生 UID
- Linux 内核提供了简单、有效的映射数据结构. 但是它并非一个通用的映射;
- Linux 内核提供它的目标是: 映射一个唯一的标识数(UID)到一个指针;  (因此并不适合其它场景)
- idr 数据结构: 用于映射用户空间的 UID
    - idr_init   初始化静态/动态分配的 idr
- ...

### 二叉树:
- 树, 是一个能提供分层的"树"型数据结构的特定数据结构;
- 树, 是一个无环、连接的有向图;
- 树, 任何一个节点具有 0~n 个出边, 1 个入边;
- 节点深度, 是从根节点起到达该节点止一共需要经过的父节点数目;
- 树的高度, 是叶子节点的深度;
- 二叉树, 任何一个节点最多有 2 个出边的树, 即只能有 0、1、2 个出边;
- BST: 二叉搜索树
    - 规则 1: 根左分支节点值 < 根节点值
    - 规则 2: 根右分支节点值 > 根节点值
    - 规则 3: 所有子树都是二叉搜索树
    - 前序遍历: 根节点->左子树->右子树
    - 中序遍历: 左子树->根节点->右子树
    - 后序遍历: 左子树->右子树->根节点
    - 在树中搜索给定值、按序遍历都相当快捷; 中序遍历二叉搜索树时会按照节点值从小到大的顺序排序;
- 自平衡二叉搜索树
    - 平衡二叉搜索树: 所有叶子节点深度差值都不超过 1 的二叉搜索树
    - 自平衡二叉搜索树: 操作都试图维持平衡(半平衡)的二叉搜索树
- 红黑树
    - 是一种"自平衡二叉搜索树"
    - 是 Linux 主要的平衡二叉搜索树
    - 具有特殊的着色属性(或红色、或黑色)
    - 能维持半平衡结构, 其 6 属性:
        - 属性 1: 所有节点要么着红色、要么着黑色
        - 属性 2: 叶子节点都是黑色
        - 属性 3: 叶子节点不包含数据
        - 属性 4: 非叶子节点都有 2 个子节点
        - 属性 5: 如果节点是红色, 则它子节点都是黑色
        - 属性 6: 一个节点到该节点的叶子节点的所有路径中, 总是包含相同数目的黑色节点;
    - 上述属性确保:
        - 一个红色节点不能是其它红色节点的子节点(或者父节点), 即两个红色节点不能相连;
        - 从树的任何一个节点到其叶子节点的路径都具有相同数目的黑色节点; 即最长路径是红黑交替路径, 最短路径是全黑路径;
        - 所以, 最深叶子节点深度, 不会大于 2 倍最浅叶子节点深度;  红黑树总是半平衡的;
    - rbtree:  <linux/rbtree.h>
        - Linux 实现的红黑树
        - 实现在 lib/rbtree.c 中
        - 插入效率和树中节点数目呈现对数关系; (即: 时间复杂度与节点数目是对数关系)
        - 根节点由数据结构 rb\_root 描述, 创建新红黑树, 需要分配新的 rb\_root 结构并初始化为 RB\_ROOT
        - 其它节点由数据结构 rb\_node 描述
        - 未提供搜索和插入操作函数, 需要由用户自己实现(可以使用 rbtree 提供的辅助函数, 但要实现比较操作算子)

### 其它较少用的:

radixtree: 基数树

### 数据结构的选择:

- 原则一: 遍历操作为主时, 优先考虑链表; (没有数据结构能提供比线性算法复杂度更好的算法去遍历元素)
- 原则二: 排除性能因素, 当需要相对较少数据项时, 优先考虑链表;
- 原则三: 当需要与其它选择链表的代码交互时, 优先考虑链表;
- 原则四: 需要大小不明的数据集合, 优先选择链表;
- 原则五: 代码架构复合"生产者/消费者"模式, 优先选择队列;
- 原则六: 当需要一个定长的缓冲, 选择队列;
- 原则七: 如果需要映射一个 UID 到一个对象, 选择映射;
- 原则八: 如果需要存储大量数据, 并且快速检索, 选择红黑树;