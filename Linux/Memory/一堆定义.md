
# PAGE_OFFSET

Linux 简化了分段机制, 使得**虚拟地址**与**线性地址**总是**一致**, 因此, Linux 的虚拟地址空间也为 `0~4G`. Linux 内核将这 4G 字节的空间分为两部分.

* 将最高的 **1G 字节**(从**虚拟地址** `0xC0000000` 到 `0xFFFFFFFF`), 供内核使用, 称为"内核空间".
* 将较低的**3G 字节**(从虚拟地址 `0x00000000` 到 `0xBFFFFFFF`), 供各个进程使用, 称为"用户空间").

因为**每个进程**可以通过**系统调用**进入**内核**, 因此, Linux **内核**由系统内的**所有进程共享**. 于是, 从具体进程的角度来看, 每个进程可以拥有 4G 字节的虚拟空间.

Linux 使用两级保护机制: 0 级供内核使用, 3 级供用户程序使用. 每个进程有各自的私有用户空间(0~3G), 这个空间对系统中的其他进程是不可见的. 最高的 1GB 字节虚拟内核空间则为所有进程以及内核所共享.

内核空间中存放的是内核代码和数据, 而进程的用户空间中存放的是用户程序的代码和数据.

不管是内核空间还是用户空间, 它们都处于**虚拟空间**中.

虽然内核空间占据了每个虚拟空间中的最高 1GB 字节, 但映射到物理内存却总是从最低地址(0x00000000)开始. 对内核空间来说, 其地址映射是很简单的线性映射.

0xC0000000 就是物理地址与线性地址之间的位移量, 在 Linux 代码中就叫做`PAGE_OFFSET`.




在嵌入式系统中, PAGE_OFFSET 也是可配置的, 比如修改为

CONFIG_PAGE_OFFSET=0x80000000, 那么在压缩内核的工具中就需要做相应的修改, 比如是

vmlinux, 使用 mkimage 工具压缩#./mkimage -A ARM-O linux -T kernel -C gzip -a 0x80800000 -e

0x80801000 -n "Linux 2.6" -d vmlinux.bin.gz vmlinux.ub. PAGE_OFFSET 后偏移 8M 是留做其他用途, 根据具体芯片设计的要求来改就可以了.




PAGE_OFFSET 代表的是内核空间和用户空间在虚拟地址空间的分界, 不同的体系结构定义和值都不同. 比如在 32 位系统中 3G-4G 属于内核使用的内存空间, 所以 PAGE_OFFSET =0xC0000000. 在 X86-64 架构下是 ffff880000000000. 可以看到内核程序可以可以访问从 PAGE_OFFSET 之后的内存.




page_to_pfn 、virt_to_page、 virt_to_phys、page、页帧 pfn、内核虚拟地址、物理内存地址 linux 内核源码详解: https://blog.csdn.net/hu1610552336/article/details/113083454
