
# 大页内存

在页式虚拟存储器中, 会在虚拟存储空间和物理主存空间都分割为一个个固定大小的页, 为线程分配内存是也是以页为单位. 比如: 页的大小为 4K, 那么 4GB 存储空间就需要 4GB/4KB=1M 条记录, 即有 100 多万个 4KB 的页. 我们可以相待, 如果页太小了, 那么就会产生大量的页表条目, 降低了查询速度的同时还浪费了存放页面的主存空间; 但如果页太大了, 又会容易造成浪费, 原因就跟段式存储管理方式一般.

所以 Linux 操作系统默认的页大小就是 4KB, 可以通过指令查看:

```
# getconf PAGE_SIZE
4096
```

但在某些对性能要求非常苛刻的场景中, 页面会被设置得非常的大, 比如: 1GB、甚至几十 GB, 这些页被称之为 "大页"(Huge Page). 大页能够提升性能的主要原因有以下几点:

* 减少页表条目, 加快检索速度.
* 提升 TLB 快表的命中率, TLB 一般拥有 16 ~ 128 个条目之间, 也就是说当大页为 1GB 的时候, TLB 能够对应 16GB ~ 128GB 之间的存储空间.

值得注意的是, 首先使用大页的同时**一般**会**禁止主存-辅存页面交换**(Swap), 原因跟段式存储管理方式一样, 大容量交换会让辅存读写成为 CPU 处理的瓶颈.  虽然现今在数据中心闪存化的环境中, 这个问题得到了缓解, 但代价就是昂贵的 SSD 存储设备. 再一个就是大页也会使得页内地址检索的速度变慢, 所以并非是页面的容量越大越好, 而是需要对应用程序进行大量的测试取得页面容量与性能的曲线峰值才对.

启用 HugePage 的优点:

* 无需交换, 不存在页面由于内存空间不足而换入换出的问题.
* 减轻 TLB Cache 的压力, 也就是降低了 CPU Cache 可缓存的地址映射压力.
* 降低 Page Table 的负载.
* 消除 Page Table 地查找负载.
* 提高内存的整体性能.

启用 HugePage 的缺点:

* HugePages 会在系统启动时, 直接分配并保留对应大小的内存区域
* HugePages 在开机之后, 如果没有管理员的介入, 是不会释放和改变的.

# Linux 的大页内存

在 Linux 中, 物理内存是以页为单位来管理的. 默认的, 页的大小为 4KB.  1MB 的内存能划分为 256 页;  1GB 则等同于 256000 页.  CPU 中有一个内置的内存管理单元(MMU), 用于存储这些页的列表(页表), 每页都有一个对应的入口地址. 4KB 大小的页面在 "分页机制" 提出的时候是合理的, 因为当时的内存大小不过几十兆字节. 然而, 当前计算机的物理内存容量已经增长到 GB 甚至 TB 级别了, 操作系统仍然以 4KB 大小为页面的基本单位的话, 会导致 CPU 中 MMU 的页面空间不足以存放所有的地址条目, 则会造成内存的浪费.

同时, 在 Linux 操作系统上运行内存需求量较大的应用程序时, 采用的默认的 4KB 页面, 将会产生较多 TLB Miss 和缺页中断, 从而大大影响应用程序的性能. 当操作系统以 2MB 甚至更大作为分页的单位时, 将会大大减少 TLB Miss 和缺页中断的数量, 显著提高应用程序的性能.

为了解决上述问题, 自 Linux Kernel 2.6 起, 引入了 Huge pages(巨型页)的概念, 目的是通过使用大页内存来取代传统的 4KB 内存页面,  以适应越来越大的内存空间. Huge pages 有 2MB 和 1GB 两种规格, 2MB 大小(默认)适合用于 GB 级别的内存, 而 1GB 大小适合用于 TB 级别的内存.

## 大页的实现原理

为了能以最小的代价实现大页面支持, Linux 采用了 **hugetlb** 和 **hugetlbfs** 两个概念. 其中, hugetlb 是记录在 TLB 中的条目并指向 hugepages, 而 hugetlbfs 则是一个特殊文件系统(本质是内存文件系统). hugetlbfs 主要的作用是使得应用程序可以根据需要灵活地选择虚拟存储器页面的大小, 而不会全局性的强制使用某个大小的页面. 在 TLB 中通过 hugetlb 来指向 hugepages, 可以通过 hugetlb entries 来调用 hugepages, 这些被分配的 hugepages 再以 hugetlbfs 内存文件系统的形式提供给进程使用.

* Regular Page 的分配: 当一个进程请求内存时, 它需要访问 PageTable 去调用一个实际的物理内存地址, 继而获得内存空间.



* Huge Page 的分配: 当系统配置 Huge pages 后, 进程依然通过普通的 PageTable 来获取到实际的物理内存地址. 但不同的是, 在 Process PageTable 和 System PageTable 第增加了 Hugepage(HPage)属性.