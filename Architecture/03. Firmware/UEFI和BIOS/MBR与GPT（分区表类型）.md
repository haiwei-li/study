
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 机械硬盘原理](#1-机械硬盘原理)
- [2. MBR 原理](#2-mbr-原理)
  - [2.1 主引导记录的结构](#21-主引导记录的结构)
  - [2.2 分区表](#22-分区表)
- [3. GPT 原理](#3-gpt-原理)
- [4. 其他](#4-其他)
- [5. 后记](#5-后记)

<!-- /code_chunk_output -->


https://zhuanlan.zhihu.com/p/26098509

http://www.newskj.org/kjxx/2017062994604.html

http://www.ruanyifeng.com/blog/2013/02/booting.html

参照 Linux/Init/

多亏了 Microsoft 的强横, 预装 WIN8 的电脑指定需要 GPT 分区.

对 GPT 进行了解以后, 进一步发现了我们的幕后功臣: UEFI. 本期文章我们就来说说, 硬盘和硬盘分区这点事.

简单地说, 硬盘分区是就使用分区编辑器(partition editor)将一个硬盘上划分几个独立的逻辑部分, 盘片一旦划分成数个分区, 不同类的目录与文件可以存储进不同的分区. 越多分区, 也就有更多不同的地方, 可以将文件的性质区分得更细, 按照更为细分的性质, 存储在不同的地方以管理文件; 但太多分区就成了麻烦.

硬盘分区就像给一间空荡的房子划分出卧室, 厨房, 客厅等相互隔离的空间一样. 主要是为了方面用户的使用. 另一方面, 通过合理的硬盘分区, 有效保护系统盘空间, 确实能够提高系统运行速度, 再者, 硬盘分区也可以有效地对数据进行保护. 你当然可以不分区, 只不过, 当你面对越来越多的子目录, 或者是越来越慢的 Windows, 不得不费功夫去管理你的文件, 或者重装 Windows 的时候, 恐怕会悔不当初. "不要把所有的鸡蛋放在同一个篮子里"这句至理名言在经济学以外的其他领域也同样是句警世恒言.

在讲解 MBR 之前, 有必要讲讲机械硬盘的一些相关概念, 毕竟 MBR 的磁盘管理方式与机械硬盘可是联系紧密的.

## 1. 机械硬盘原理

机械硬盘由坚硬金属材料制成的涂以磁性介质的盘片, 盘片两面称为盘面或扇面, 都可以记录信息, 由磁头对盘面进行操作, 一般用磁头号区分. 结构特性决定了机械硬盘如果受到剧烈冲击(摔在地上或是勤奋的你想拆开学习), 磁头与盘面可能产生的哪怕是轻微撞击都有可能报废.

假设磁头不动, 硬盘旋转, 那么磁头就会在磁盘表面画出一个圆形轨迹并将之磁化, 数据就保存在这些磁化区中, 称之为磁道, 将每个磁道分段, 一个弧段就是一个扇区. 一个硬盘可以包含多个扇面, 扇面同轴重叠放置, 每个盘面磁道数相同, 具有相同周长的磁道所形成的圆柱称之为柱面, 柱面数与磁道数相等. 如下图

![config](images/1.jpg)

最初的硬盘地址管理方式作一个原理层面的了解:

最初的寻址方式称为 CHS, 在 LBA(Logical Block Address)概念诞生之前, 由他负责管理磁盘地址. 所谓 CHS 即柱面(cylinder), 磁头(header), 扇区(sector), 通过这三个变量描述磁盘地址, 需要明白的是, 这里表示的已不是物理地址而是逻辑地址了. 这种方法也称作是**LARGE 寻址方式**. 该方法下:

硬盘容量=磁头数×柱面数×扇区数×扇区大小(一般为 512byte).

后来, 人们通过为**每个扇区分配逻辑地址, 以扇区为单位进行寻址**, 也就有了**LBA 寻址方式**. 但是为了保持与 CHS 模式的兼容, 通过逻辑变换算法, 可以转换为磁头/柱面/扇区三种参数来表示, 和 LARGE 寻址模式一样, 这里的地址也是逻辑地址了. (固态硬盘的存储原理虽然与机械硬盘不同, 采用的是 flash 存储, 但仍然使用 LBA 进行管理, 此处不再详述. )

科普到这里, 我们可以试图去理解 MBR 分区了. 现在我们来看看 MBR 分区的技术原理.

## 2. MBR 原理

BIOS 按照"启动顺序", 把控制权转交给排在第一位的储存设备.

这时, 计算机读取该设备的第一个扇区, 也就是读取最前面的 512 个字节. 如果这 512 个字节的最后两个字节是 0x55 和 0xAA, 表明这个设备可以用于启动; 如果不是, 表明设备不能用于启动, 控制权于是被转交给"启动顺序"中的下一个设备.

这最前面的 512 个字节, 就叫做"[主引导记录](http://en.wikipedia.org/wiki/Master_boot_record)"(Master boot record, 缩写为 MBR). 最早在 1983 年在 IBM PC DOS 2.0 中提出. 前面说过, **每个扇区/区块都被分配了一个逻辑块地址**, 即 LBA, 而**引导扇区则是每个分区的第一扇区(逻辑地址恒为 1)**, 而主引导扇区则是整个硬盘的第一扇区(主分区的第一个扇区). MBR 就保存在主引导扇区中.

### 2.1 主引导记录的结构

"主引导记录"只有 512 个字节, 包含了硬盘分区表 DPT(Disk Partition Table), 和结束标志字(Magic number). 扇区总计 512 字节, MBR 占 446 字节(0000H - 01BDH), DPT 占据 64 个字节(01BEH - 01FDH), 最后的 magic number 占 2 字节(01FEH – 01FFH).

它的主要作用是, **告诉计算机到硬盘的哪一个位置去找操作系统**.

主引导记录由三个部分组成:

(1) 第 1-446 字节: 调用操作系统的机器码.

(2) 第 447-510 字节: 分区表(Partition table).

(3) 第 511-512 字节: 主引导记录签名(0x55 和 0xAA).

其中, 第二部分"分区表"的作用, 是将硬盘分成若干个区.

![config](images/2.jpg)

### 2.2 分区表

硬盘分区有很多[好处](http://en.wikipedia.org/wiki/Disk_partitioning#Benefits_of_multiple_partitions). 考虑到**每个区可以安装不同的操作系统**, "主引导记录"因此必须知道将控制权转交给哪个区.

分区表的长度只有 64 个字节, 里面又分成四项, 每项 16 个字节. 所以, 一个硬盘最多只能分四个一级分区, 又叫做"主分区".

每个主分区的 16 个字节, 由 6 个部分组成:

(1) 第 1 个字节: 如果为 0x80, 就表示该主分区是激活分区, 控制权要转交给这个分区. 四个主分区里面只能有一个是激活的.

(2) 第 2-4 个字节: 主分区第一个扇区的物理位置(柱面、磁头、扇区号等等).

(3) 第 5 个字节: [主分区类型](http://en.wikipedia.org/wiki/Partition_type).

(4) 第 6-8 个字节: 主分区最后一个扇区的物理位置.

(5) 第 9-12 字节: 该主分区第一个扇区的逻辑地址.

(6) 第 13-16 字节: **主分区的扇区总数**.

最后的四个字节("主分区的扇区总数"), 决定了这个主分区的长度. 也就是说, 一个主分区的扇区总数最多不超过 2 的 32 次方.

如果每个扇区为 512 个字节, 就意味着**单个分区最大不超过 2TB**. 再考虑到扇区的逻辑地址也是 32 位, 所以单个硬盘可利用的空间最大也不超过 2TB. 如果想使用更大的硬盘, 只有 2 个方法: 一是提高每个扇区的字节数, 二是[增加扇区总数](http://en.wikipedia.org/wiki/GUID_Partition_Table).

现在, 我们来看**一个 MBR 记录的一个主分区实例**:

**80 01 01 00, 0B FE BF FC, 3F 00 00 00, 7E 86 BB 00**

其中, "**80"是一个分区的激活标志**, 表示**系统可引导**; "01 01 00"表示分区开始的磁头号为 01, 开始的扇区号为 01, 开始的柱面号为 00; "**0B**"表示**该分区的系统类型是 FAT32**, 其他比较常用的有**04(FAT16)、07(NTFS**); "FE BF FC"表示分区结束的**磁头号为 254**, 分区结束的**扇区号为 63**、分区结束的**柱面号为 764**; "3F 00 00 00"表示首个扇区的**相对扇区号为 63**; "7E 86 BB 00"表示**总扇区数为 12289622**.

可以看到, 在只分配 64 字节给 DPT 的情况下, 每个分区项分别占用 16 个字节, 因此只能记录四个分区信息, 尽管后来为了支持更多的分区, 引入了扩展分区及逻辑分区的概念. 但每个分区项仍然用 16 个字节存储. 能表示的最大扇区数为 FF FF,FF FFH, 因此**每个分区可管理的最大空间**=总扇区数(2\^32)\*扇区大小(512byte, 2\^9), **也就是 2TB**(由于硬盘制造商采用 1:1000 进行单位换算, 因此也有 2.2TB 一说, 别怪他们, 他们不是程序员). 超过 2TB 以后的空间, 不能分配地址, 自然也就无法管理了.

MBR 的诸多缺点使其应用大大受限. 硬盘技术日新月异, 硬盘容量突飞猛进(希捷将于今年开卖 60TB 固态硬盘), 多出来的硬盘空间总不能晾着吧, 于是, 在刚诞生的 UEFI 规范下一起研发了新技术.

## 3. GPT 原理

**GPT 分区**: 全称为 Globally Unique Identifier Partition Table, 也叫做 GUID 分区表, 它是 UEFI 规范的一部分. 由于硬盘容量的急速增长, **MBR 的 2.2T 容量难以满足要求**, 而 UEFI BIOS 的推广也为 GPT 的实现打下了坚实的技术基础, GPT 应运而生,

我们来看看 GPT 的结构图:

![config](images/19.png)

![config](images/3.jpg)

这里的 P 意为 protective, **PMBR**存在的意义就是, 当**不支持 GPT 的分区工具(！！！)试图对硬盘进行操作时(例如 MS-DOS 和 Linux 的 fdisk 程序！！！), 它可以根据这份 PMBR 以传统方式启动, 过程和 MBR+BIOS 完全一致, 极大地提高了兼容性**. 而**支持 GPT 的系统在检测 PMBR 后(！！！**)会**直接跳到 GPT 表头**读取分区表. 在这个 MBR 中, **只有一个分区类型标识(！！！)为 0xEE 的分区(四个分区只能有一个是 0xEE**), 以此来表示**这块硬盘使用 GPT 分区表, 这个分区类型是 PMBR！！！**. 和 MBR 类似, 分区表中存储了某个分区的起始和结束位置及其文件系统属性信息, 而分区才是实际存在的物理磁盘的一部分.

**GPT HDR**: GPT 表头, 如下图, 主要定义了**分区表中项目数及每项大小**, 还包含硬盘的容量信息. 在**64 位的 Windows Server 2003**的机器上, 最多可以创建**128 个分区**, 即分区表中保留了 128(2\^7)个项, 其中每个都是 128(2\^7)字节. (也是**EFI 标准中的最低要求: 分区表最小要有 16, 384(2\^14)字节**)分区表头还记录了这块**硬盘的 GUID**, 分区表头位置(总是 LBA1)和大小, 也包含了**备份分区表头**和**分区表**的**位置和大小信息(LBA\-1~LBA\-34**). 同时还储存着它本身和分区表的 CRC32 校验. 固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错, 如果出错, 可以使用软件从硬盘最后的备份 GPT 中恢复整个分区表, 如果备份 GPT 也校验错误, 硬盘将不可使用. 具体内容如下表:

![config](images/4.jpg)

**Partition Table**: 分区表, 包含分区的类型 GUID(如: **EFI 系统分区**的 GUID 类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}), 名称, 起始终止位置, 该分区的 GUID 以及分区属性. 其内容如下:

![config](images/5.jpg)

Microsoft 对**分区属性**做了更详细的区分, 目前有:

![config](images/6.jpg)

相较于 MBR, GPT 具有以下优点:

(1)得益于**LBA 提升至 64 位, 以及分区表中每项 128 位设定, GPT 可管理的空间近乎无限大**, 假设一个扇区大小仍为 512 字节, 可表示扇区数为 2\^64, 算下来, 可管理的硬盘容量=18EB(1EB=1024PB=1,048,576TB=2\^20TB=2\^60byte), 2T 在它面前完全不在话下. 按目前的硬盘技术来看, 确实近乎无限, 不过, 以后的事谁知道呢.

(2)**分区数量几乎没有限制**, 由于可在表头中设置分区数量的大小, 如果愿意, 设置个分区也可以(有人愿意管理这么多分区吗), 不过, **目前 windows 仅支持最大 128 个分区**.

(3)自带保险, 由于在**磁盘的首尾部分各带一个 GPT 表头**, 任何一个受到破坏后都可以通过另一份恢复, 极大地提高了磁盘的抗性(两个一起坏的请出门买彩票).

(4)循环冗余检验值针对关键数据结构而计算, 提高了数据崩溃的检测几率.

(5)尽管目前分区类型不超过百数(十数也没有吧. ), GPT 仍提供了 16 字节的 GUID 来标识分区类型, 使其更不容易产生冲突.

(6)每个分区都可以拥有一个特别的名字, 最长 72 字节, 满足你的各种奇葩起名需求.

完美支持 UEFI, 毕竟它就是 UEFI 规范的衍生品. 在将来全行业 UEFI 的情境下, GPT 必将更快淘汰 MBR.

## 4. 其他

接下来进入加料时间, 更详细的讲述硬盘知识.

前面说到过, 磁化的弧段称作一个扇区, 一个扇区大小 512Byte, 但硬盘在进行文件操作时并非以扇区为单位, 而是簇, **"簇"是系统(文件系统)进行分配的最小单位**, 一个簇可以包含多个扇区, 假设目前一个簇包含 4 个扇区, 簇大小为 2KB, 一个文件大小恰为 2KB, 则占用了簇的所有可用空间, 即便你有一个 1B 大小的文件需要保存, 那么你占用的空间也是一个簇, 簇内其他空间不可读写.

而**对簇的大小进行管理的就是文件系统**:

FAT16/FAT32: 早期的 MS-DOS 和 WIN95 操作系统中最常见的硬盘分区格式. **一个簇最小为 512 个字节, 其大小可以成倍增长, 最大为 32K(2\^15)**, 系统为每个簇分配唯一的索引号——一个 16 位二进制数来标识. 因为 16 位二进制数最大为 65536, 所以 FAT 分区所拥有的簇的数量不可能超过 65536 个. 这正是**FAT 分区大小不能超过 2GB(2\^15 * 2\^16 = 2\^31 = 2GB)的原因**. FAT16 的继任者——FAT32 与其原理基本相同, 相比前任优势仅在于分区可以大于 2GB, 但不能存储大于 4GB 的单个文件, 看看现在一部 BD 的电影都要 3,4 个 G, 显然不能满足时代的需求, 被淘汰的很快.

更多 FAT 文件系统知识: [FAT 文件系统与 UEFI - 知乎专栏](https://zhuanlan.zhihu.com/p/25992179)

NTFS 文件系统相比 FAT, 最大优点在于**支持文件加密**, 通过采用**日志式文件系统**, 详细**记录磁盘的所有读写操作**, 提高了数据和系统的安全性, 另一点则是突破了 4GB 大小限制. 也是目前机械硬盘上的分区主流. 不过对于目前越来越亲民的的 flash 存储, 过多的操作记录对存储介质造成了较大的负担, 同样的存取操作, NTFS 下的读写次数就会比 FAT32 下来得多, 造成了寿命较短的缺陷. 因此针对移动存储设备和固态硬盘, 推出了 exFAT 文件系统.

exFAT: 分区大小和单文件大小最大可达 16EB(16×1024×1024TB); 簇大小非 常灵活, 最小 512B, 最高达 32MB; 采用了剩余空间分配表, 空间利用率更高; 同一目录下最大文件数可达 65536 个. 其特性未必强于 NTFS, 主要是针对 flash 存储设备进行了优化(SSD, U 盘), 传统硬盘不能格式化为该格式.

要是到现在你对扇区, 簇, 文件系统, 分区几个名词有点混淆, 不妨看看下图:

![config](images/7.jpg)

有人会问, 图中的怎么突然出现了 4k 扇区, 而且为什么下面又包含的是 8 个 512b 的扇区呢?边上的伪装是啥意思?恭喜你, 你已经抓住了近年来的硬盘发展潮流.

**扇区的大小虽然约定俗成, 但其实是可以更改的**, 开始于 2009 年晚期, 硬盘制造商正在从传统的 512 字节扇区迁移到更大、更高效的 4096 字节扇区, 国际硬盘设备与材料协会(International Disk Drive Equipment and Materials Association, IDEMA)将之称为高级格式化, 也就是现在常说的"4K 扇区".

多年来, 硬盘行业一直采用 512 字节扇区. 然而, 随着硬盘容量的不断增长, 扇区大小日渐成为提高硬盘容量和纠错效率方面的制约. 扇区分辨率(扇区大小和总存储大小的百分比)越来越低, 尽管在管理小型离散数据时, 分辨率越低越好. 但现代的计算系统中多的是大型数据块, 一般远比传统 512 字节扇区大小要大得多. 另外, 随着区域密度的增加, 小型 512 字节扇区在硬盘表面上占用的空间也将越来越小. 硬盘扇区中的数据占据的空间越小, 错误纠正就会变得越困难, 因为同样大小的介质缺陷对总体数据负载损害的百分比更高, 所以就需要更大的纠错强度. 现在, 硬盘开始通过先进的区域密度来提高错误纠正的上限. 因此, 为了改善错误纠正和实现格式化效率, 提高扇区大小是硬盘行业内的普遍诉求.

不过, 由于计算机系统的缓慢发展, 多数仍将扇区假定为 512 字节, 因此就产生了 4K 对齐问题. 即使**物理硬盘分区与计算机使用的逻辑分区对齐**, 保证硬盘读写效率.

有 4k 对齐当然就有 4k 对不齐. 这个锅, 或许应该甩给操作系统. 硬盘厂商为了保证与操作系统的兼容性, 将新标准的"4K 扇区"的硬盘模拟成扇区为 512B 的硬盘, 问题出现在此时: 当在一些特殊情况下格式化的系统(比如用 ghost11.5 以下版本), 会默认定义为 4096 字节大小为一个簇, 这没毛病, 但是, 由于其引导区只占用了不多不少 63 个扇区, 真正的文件系统在 63 号扇区之后,

我们可以算出前 63 个扇区大小为: 63*512B = 32256B.

63 个扇区占用簇个数: 32256B/4096B=7.875 簇.

从第 64 个扇区开始, 每个簇都会跨越两个物理单元, 占据前一个单元的一小部分和后一个单元的一大部分, 前面说过, 系统文件操作以簇为单位, 如果每个簇都要用到两个扇区, 势必拖累读写速度. 也就产生了"4k 对不齐"的概念, "4K 对齐"要做的事就是将硬盘的模拟扇区(512B)对齐到的 8 整数倍个"实际"4K 扇区, 即 8*4096 = 32768B, 使其正好跨过 63 扇区的特性, 从第 64 个扇区对齐.

其实不仅是操作系统, 一些广泛使用的软件程序也可能引发 4k 对不齐现象. 因此, 对齐技术的存在确有其必要性. 尽管 4k 必然取代 512b, 但冰冻三尺非一日之寒, 全行业仍需要一个时间来进行技术的全面推广.

## 5. 后记

一些经常被问到的关于 GPT 的问题:

1. Q: 怎么知道我的**硬盘是 MBR 的还是 GPT 的**?

A:  windows 自带个非常好用的工具-diskpart, 简单几条命令即可, 如图:

![config](images/8.jpg)

上图 GPT 下面有"\*", 所以是 GPT 分区表格式.

2. Q: 如何将 GPT 转换为 MBR?

A: 还是 diskpart,(警告: 请先备份内容), 通过 convert mbr 指令

![config](images/9.jpg)

不过我还是建议你不要这样做, 毕竟 MBR 是个被淘汰的技术. 在转换之前要删除所有分区或者直接用 clean. 如果不想丢失内容, 推荐使用 AOMEI Partition Assistant Standard, 它是个免费软件. 非常好用. 为谨慎起见还是建议提前备份内容.

3. Q: GPT 真好, 我想立刻使用, 可是如何将 MBR 转换为 GPT?

A: 这是个好主意, 答案还是 Diskpart

![config](images/10.jpg)

在转换之前要删除所有分区或者直接用 clean. 如果不想丢失内容, 我推荐使用 AOMEI Partition Assistant Standard, 它是个免费软件. 非常好用. 为谨慎起见还是建议提前备份内容.