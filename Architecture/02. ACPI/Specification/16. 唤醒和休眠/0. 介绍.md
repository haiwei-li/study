
ACPI 定义了在**工作状态** (`G0`) 和**休眠状态** (`G1`) 或**软关闭** (`soft-off`, `G2`, `S5`) 状态之间系统转换的机制. 在工作和休眠状态之间的转换期间, 将维护用户操作环境的上下文.

ACPI 通过定义**四种类型**的 ACPI **休眠状态**(`S1`、`S2`、`S3` 和 `S4`)的系统属性来定义 **G1 休眠状态**的质量. 每个休眠状态都经过定义, 以允许在成本、功耗和唤醒延迟之间进行权衡的实现. 此外, ACPI 还定义了休眠状态, 以便 ACPI 平台可以支持多个休眠状态, 从而允许平台在预定义的时间段内转换到特定的休眠状态, 然后转换到低功耗/较高的唤醒延迟休眠状态(通过 G0 状态转换)(请参阅下面的注释).

> OSPM 使用 RTC 唤醒功能或时间和警报命名空间设备在时间转换延迟中进行编程. 在休眠之前, OSPM 会将警报编程为最近的(及时)唤醒事件: 过渡到低功耗休眠状态或日历事件(运行某些应用进程).

ACPI 定义了一个**编程模型**, 该模型为 OSPM 提供了**一种机制**来启动**进入休眠**或**软关闭状态** (`S1-S5`); 该模型由一个 **3 位字段** `SLP_TYPx` 组成, 该字段指示要进入的**休眠状态类型**, 以及一个控制位 `SLP_EN` 来**启动休眠过程**. 在 HW 少的 ACPI 系统上, 使用 **FADT** 中的 `SLEEP_CONTROL_REG` 字段的寄存器, 而不是固定的 `SLP_TYPx` 和 `SLP_EN` 寄存器位字段.

> 请注意, 可以有**两个**固定的 `PM1x_CNT` 寄存器, 每个寄存器指向不同的**系统 I/O 空间区域**. 通常, 寄存器分组仅允许位或位字段驻留在单个寄存器组实例(a 或 b)中; 但是, 每个平台可以有两个实例 SLP_TYP(每个分组寄存器一个: a 和 b). \_Sx 控制方法给出一个包含两个值的包: 第一个是 `SLP_TYPa` 值, 第二个是 `SLP_TYPb` 值.

注意: 包含处理器的系统没有将处理器置于低功耗状态的硬件机制, 可能还需要执行适当的本机指令, 以便在之后将处理器置于低功耗状态. OSPM 设置 `SLP_EN` 位. 硬件可以实现许多低功耗休眠状态, 然后将这些状态与定义的 ACPI 休眠状态相关联(通过 `SLP_TYPx` 字段). **ACPI 系统固件**创建一个与每个受支持的**休眠状态**关联的**休眠对象**(不受支持的休眠状态由缺少休眠对象标识). **每个休眠对象**都包含**两个常量的 3 位值**, OSPM 将编程到 `SLP_TYPa` 和 `SLP_TYPb` 字段(在固定的寄存器空间中), 或者在硬件少的 ACPI 平台上, OSPM 将写入 FADT `SLEEP_CONTROL_REG` 字段指定的寄存器的单个 3 位值.

在不是减少硬件的 ACPI 平台的系统上, 定义了进入和退出 S4 状态的替代机制. 该机制将控制传递给平台运行时固件以保存和恢复平台上下文. 上下文所有权在定义上类似于 S3 状态, 但硬件将内存上下文保存和恢复到非易失性存储(例如磁盘驱动器), OSPM 将其视为具有隐含延迟和功率限制的 S4 状态. 这种进入 S4 状态的替代机制称为 S4BIOS 转换.

在进入休眠状态 (S1-S4) 之前, OSPM 将执行 `_PTS`(`Prepare To Sleep`, **准备休眠**)控制方法中包含的 **OEM 特定**的 `AML/ASL` 代码.  `_PTS` 控制方法的**一个用途**是它可以向嵌入式控制器指示系统将进入什幺休眠状态. 然后, 嵌入式控制器可以通过在进入休眠状态时执行正确的电源平面(`power-plane`)排序来做出响应.

然后执行 `_WAK`(唤醒)控制方法. 此控制方法再次包含 OEM 特定的 AML/ASL 代码.  `_WAK` 控制方法的一种用途是请求 OSPM 检查平台**是否有可能**在系统休眠时有任何已添加或从系统中删除的设备. 例如, 一个 PC 卡控制器可能已经添加或移除了一个 PC 卡, 并且由于该设备的电源在休眠状态下关闭, 因此不会生成状态更改事件.

本节讨论支持 ACPI 的平台的系统初始化顺序. 这包括启动顺序、不同的唤醒场景以及说明如何使用系统地址映射报告接口的示例. 此串行是 ACPI 事件编程模型的一部分.

注: 硬件减少的 ACPI 平台不实现旧模式, 也不实现下面所述的 S4BIOS 状态.

有关上述电源管理控制方法的详细信息, 请参阅 "电源和性能管理"
