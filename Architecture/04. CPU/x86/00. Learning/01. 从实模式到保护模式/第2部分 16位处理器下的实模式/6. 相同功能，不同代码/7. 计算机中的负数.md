```
6.7 计算机中的负数
　　6.7.1 无符号数和有符号数
　　6.7.2 处理器视角中的数据类型
```

## 1. 无符号数和有符号数

在编写程序的时候, 既可以使用正数, 也可以使用负数.

```
db 128,127,3,2,1,0,-1,-2,-3,-127,-128
```

查看编译后内容

```
root@Gerry:/home/project/nasm# nasm -o t.o t.asm
root@Gerry:/home/project/nasm# hexdump -C t.o
00000000  80 7f 03 02 01 00 ff fe  fd 81 80                 |...........|
0000000b
```

前面的正数好理解, 十进制 128 对应二进制 10000000, 对应十六进制 0x80.

-1 在编译器看来, 就是 0-1, 做一次减法. 二进制减法. 二进制 0 减去二进制 1, 结果是

```
···111111111111111111111111111111111111
```

相减过程中不停从左边借位.

-2 就是

```
···111111111111111111111111111111111110
```

在计算机中, **数字保存在寄存器中**, 在 16 位处理器中, 寄存器通常是 8 位或 16 位. 所以十进制数-1 在寄存器 AL 中就是

```
11111111
```

即 0xFF; 十进制数-2 在寄存器 AL 中二进制形式

```
11111110
```

即 0xFE.

当然, **数据还可以保存在内存中, 或者编译后的二进制文件中**. 在二进制文件中, 数据是用伪指令 db 或者 dw 等定义的. 但是, **数据的表示形式和它们在寄存器中的形式相同**, 以下代码片断很清楚地说明了这一点.

```
data0 db -1 ;初始化为 0xFF
data1 db -2 ;初始化为 0xFE
data2 dw -1 ;初始化为 0xFFFF
data3 dw -2 ;初始化为 0xFFFE
```

0xFF 等于十进制数 255, 但现在它又是十进制数－1, 哪一个才是正确的呢?我们应该以哪一个为准呢?

将计算机中的数分成两大类: 无符号数和有符号数.

在 8 位的字节运算中, 无符号数的范围是 00000000~11111111, 即十进制的 0~255; 在 16 位的字运算中, 无符号数的范围是 0000000000000000~1111111111111111, 即十进制的 0~65535; 在将来要讲到的 32 位运算中, 无符号数的范围是 000000000000000000000000 ~ 11111111111111111111111111111111, 即十进制的 0~4294967295.

有符号数是分正、负的, 而且规定, 数的正负要通过它的最高位来辨别. 如果最高位是 0, 它就是正数; 如果是 1, 就是负数. 如此一来, 在 8 位的字节运算环境中, 正数的范围是 00000000~01111111, 即十进制的 0~127; 负数的范围是 10000000~11111111, 即十进制的-128 ~ -1.

10000000~11111111 这些负数, 都是用 0 减去它们相对应的正数得到的. 想知道它们各自对应的正数是谁吗?很简单, 因为"负数的负数"是正数, 所以只需要用 0 减去这个负数就行.

```
00000000－10000000＝10000000(十进制数 128)
00000000－11111111＝00000001(十进制数 1)
```

所以, 10000000~11111111 这个范围内的有符号数, 对应着十进制数-128 ~ -1.

在 8086 处理器中, 有一条指令专门做这件事, 它就是 **neg**. neg 指令带有一个操作数, **可以是 8 位或者 16 位的寄存器, 或者内存单元**. 如

```
neg al
neg dx
neg word [label_a]
```

它的功能很简单, 用 0 减去指令中指定的操作数. 如果 AL 中的内容是 00001000(十进制数 8), 执行 neg al 后, AL 中的内容变为 11111000(十进制数－8); 如果 AL 中的内容为 11000100(十进制数－60), 执行 neg al 后, AL 中的内容为 00111100(十进制数 60).

一个字节容纳的范围是-128 ~ 127, 不要这样写

```
mov al, -200
```

编译时候被截断. 机器码为 B0 38.

```
mov ax, -200
```

这时, 编译后的机器码是 B8 38 FF.

同样的规则也适用于伪指令 db 和 dw(以下均为十进制数).

```
db 255      ;正确, 可以看成声明无符号数
db -125     ;正确, 数据未超范围
db -240     ;错误, 超过字节所能容纳的数据范围, 会被截断
dw -240     ;正确, 数据未超范围
dw -30001   ;正确, 数据未超范围
```

8 位、16 位、32 位同一个负数, 表现形式有差异.

一个 8 位的有符号数, 要想用 16 位的形式来表示, 只需将其最高位, 也就是用来辨别符号的那一位(几乎所有的书上都称之为符号位, 实际上这并不严谨), 扩展到高 8 位即可. 为了方便, 处理器专门设计了两条指令来做这件事: cbw(Convert Byte to Word)和 cwd(Convert Word to Double-word).

**cbw 没有操作数**, 操作码为 98. 它的功能是, **将寄存器 AL 中的有符号数扩展到整个 AX**. 如果 AL 中的内容为 01001111, 那么执行该指令后, AX 中的内容为 0000000001001111; 如果 AL 中的内容为 10001101, 执行该指令后, AX 中的内容为 1111111110001101.

**cwd** 也没有操作数, 操作码为 99. 它的功能是, **将寄存器 AX 中的有符号数扩展到 DX:AX**. 如果 AX 中的内容为 0100111101111001, 那么执行该指令后, DX 中的内容为 0000000000000000, AX 中的内容不变; 如果 AX 中的内容为 1000110110001011, 那么执行该指令后, DX 中的内容为 1111111111111111, AX 中的内容同样不变.

最高位既是数的一部分, 和其他比特一起共同表示数的大小, 同时又用来判断数的正负.

## 2. 处理器视角中的数据类型

假如寄存器 AX 中的内容是 0xB23C, 那么, 它到底是无符号数 45628 呢, 还是应当将其看成是－19908?

答案是取决于你. 对于处理器的多数指令来说, 执行的结果和操作数的类型没有关系. 换句话说, 无论你是从无符号数的角度来看, 还是从有符号数的角度来看, 指令的执行结果都是正确无误的.

```
mov ah,al
```

mov 指令不考虑类型.

```
mov ah,0xf0
inc ah
```

0xf0 的二进制形式是 11110000, 它既可以解释为无符号数 240(十进制), 也可以解释为有符号数-16, 毕竟它的符号位是 1. inc 后 ah 既是无符号数 241, 也是有符号数-15.

再考虑加法.

```
mov ax,0x8c03
add ax,0x05
```

0x8c03 既可以看做是无符号数 35843(十进制), 也可以看成是有符号数－29693(十进制). **在运算过程中, 数的视角要统一**, 如果把 0x8c03 看成是无符号数, 那么 0x05 也是无符号数; 如果 0x8c03 是有符号数, 那么 0x05 也是有符号数.

add 指令对于无符号和有符号都适用. 运算后 AX 中的内容是 0x8c08, 分别可以看成是无符号数 35848 和有符号数-29688.

再考虑下减法. 如果要计算 10－3, 这其实可以看成是 10＋(-3). 因此, 使用以下三条指令就可以完成减法运算:

```
mov ah,10
mov al,-3
add ah,al
```

所以很多处理器内部不构造减法电路, 而是使用加法电路来做减法.

处理器还是提供了**减法指令 sub**, 该指令和加法指令 add 相似, **目的操作数**可以是 8 位或者 16 位**通用寄存器**, 也可以是 8 位或者 16 位的**内存单元**; **源操作数**可以是**通用寄存器**, 也可以是**内存单元**或者**立即数**(不允许两个操作数同时为内存单元).

**处理器没有减法运算电路**, 举例来说, sub ah,al 指令实际上等效于下面两条指令:

```
neg al
add ah,al
```

几乎所有的处理器指令既能操作无符号数, 又能操作有符号数. **有几条指令除外, 比如除法指令和乘法指令**.

除法指令 div. 它应该叫做无符号除法指令(Unsigned Divide), 因为这条指令只能工作于无符号数. 换句话说, 只有从无符号数的角度来解释它的执行结果才能说得通.

```
mov ax,0x0400
mov bl,0xf0
div bl ;执行后, AL 中的内容为 0x04, 即十进制数 4
```

从无符号数的角度来看, 0x0400 等于十进制数 1024, 0xf0 等于十进制数 240. 相除后, 寄存器 AL 中的商为 0x04, 即十进制数 4, 完全正确.

但是, 从有符号数的角度来看, 0x0400 等于十进制数 1024, 0xf0 等于十进制数－16. 相除后, 寄存器 AL 中结果应当是 0xc0. 因其最高位是"1", 故为负数, 即十进制数为－64.

处理器专门提供了一个**有符号数除法指令** idiv(Signed Divide). idiv 的指令格式和 div 相同. 如果你决定要进行有符号数的计算, 必须采用如下代码:

```
mov ax,0x0400
mov bl,0xf0
idiv bl ;执行后, AL 中的内容为 0xc0, 即十进制数－64
```

在用 idiv 指令做除法时, 需要小心. 比如用 0xf0c0 除以 0x10, 也就是十进制数的除法-3904÷16.

```
mov ax,0xf0c0
mov bl,0x10
idiv bl
```

以上的代码是 16 位二进制数除法, 结果在寄存器 AL 中. 除法的结果应当是十进制数－244, 遗憾的是, 这样的结果超出了寄存器 AL 所能表示的范围, 必然因为溢出而不正确. 为此, 你可能会用 32 位的除法来代替以前的做法:

```
xor dx,dx ;如此一来, DX: AX 中的数成了正数
mov ax,0xf0c0
mov bx,0x10
idiv bl
```

但是还是错的. 十进制数-3904 的 16 位二进制形式和 32 位二进制形式是不同的. 前者是 0xf0c0, 后者是 0xfffff0c0. 应该用 cwd 指令把寄存器 AX 中数的符号扩展到 DX. 所以正确写法是:

```
mov ax,0xf0c0
cwd
mov bx,0x10
idiv bx
```

执行完后, 寄存器 AX 中内容是 0xff0c, 即十进制数-244.

如果是无符号数计算, 必须使用 div 指令; 如果是有符号数计算, 就使用 idiv 指令.