对于处理器来说, 取指令、执行是永无止尽的. 程序有大小, 处理器执行完后就会执行后面非指令的数据上, 然后······

所以我们有个无限循环:

```
infi: jmp near infi
```

jmp 是转移指令, **关键字 near 表示目标位置依然在当前代码段内**.

**处理器取指令、执行指令是依赖于段寄存器 CS 和指令指针寄存器 IP 的, 8086 处理器取指令时, 把 CS 的内容左移 4 位, 加上 IP 的内容, 形成 20 位的物理地址, 取得指令, 然后执行, 同时把 IP 的内容加上当前指令的长度, 以指向下一条指令的偏移地址. **

但是, 一旦处理器取到的是转移指令, 情况就完全变了.

指令 jmp near infi 的意图是转移到标号 infi 所在的位置执行. 按照之前说的, 程序在内存中的加载位置是 0x0000:0x7C00, 所以, 这条指令应当写成

```
jmp near 0x7c00+infi
```

实际上, 不加还好, 加上了 0x7C00, 就完全错了.

jmp 指令有多种格式. 最典型地, 它的操作数可以是直接给出的**段地址和偏移地址**, 这称为**绝对地址**.

```
jmp 0x5000:0xf0c0
```

在这种情况下, 指令的操作码为 0xEA, 故完整的机器指令是:

```
EA C0 F0 00 50
```

处理器执行时, 发现操作码为 0xEA, 于是, 将指令中给出的段地址传送到段寄存器 CS; 将偏移地址传送到指令指针寄存器 IP, 从而转移到目标位置处接着执行.

但是, jmp 指令使用了关键字"near", 且操作数是以标号(infi)的形式给出. 这很容易让我们想到, 这又是另一种形式的转移指令, 转移的目标位置处在当前代码段内, 指令中的操作数应当是目标位置的偏移地址. 实际上, 这是不正确的.

实际上, 这是一个**3 字节指令(指令包含操作码和操作数)**, **操作码是 0xE9**(与 jmp 不一样, 不是同一个！！), 后跟一个 16 位(两字节)的操作数. 但是, 该操作数**并非目标位置的偏移地址**, **而是目标位置相对于当前指令处的偏移量**(以字节为单位). 在编译阶段, 编译器是这么做的: **用标号(目标位置)处的汇编地址减去当前指令的汇编地址, 再减去当前指令的长度(3), 就得到了 jmp near infi 指令的实际操作数**(也是个地址)(这个算法核心在于 near 表示目标地址依然再当前代码段中, 所以 CS 不变). 也不是编译器愿意费这个事, 这是处理器的要求.

jmp near infi 的机器指令格式和它的汇编指令格式完全不同. 这种转移是相对的, 操作数是一个相对量.

比如之前的例子, 机器码是 E9FDFF, 指令是

```
infi: jmp near infi
```

**指令转机器码**. 该指令汇编地址是 0000012B. 目标位置的汇编地址也是 0000012B, 和当前指令的汇编地址相同, 相减, 然后再减去当前指令长度(3), 得到实际操作数(因为是个三字节指令, 所以操作数大小 2 字节), 0-3 = -3 = 0000000000000000 - 0000000000000011 = 1111111111111101 = 0xFFFD. 小端模式, 所以机器码是 E9FDFF.

**机器码转指令**. 机器码是 E9FDFF, 获取第一个字节, E9, 不是长字节操作码, 所以操作码是 E9, 三字节指令, 操作数是两个字节, 16 位操作数. 从内存中获取两个字节 FD FF(地址从低到高)数据. 因为小端模式, 操作数是 FFFDH, 这也就是相对位置偏移量. 然后计算指令中操作数, 偏移量+3+当前指令汇编地址 = 0xfffd + 3 + 0x012B = 0x012B, 指令的话, 多种选择, 可以是 jmp word 0x12b.

在指令执行阶段, 处理器用指令指针寄存器 IP 的内容加上该指令的操作数, 再加上该指令的长度(3), 就得到了要转移的实际偏移地址, 同时 CS 寄存器的内容不变. 因为改变了 IP 的内容, 这直接导致处理器的指令执行流程转向目标位置.