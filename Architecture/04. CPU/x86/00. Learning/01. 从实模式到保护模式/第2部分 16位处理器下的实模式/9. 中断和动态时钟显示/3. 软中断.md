软中断是由**int 指令引起的中断处理**. 这类中断也不需要中断识别总线周期, 中断号在指令中给出. int 指令的格式如下:

```
int3
int imm8
into
```

int3 是断点中断指令, 机器指令码为 CC. 当程序运行不正常时, 多数时候希望在某个地方设置一个检查点, 也称断点, 来查看寄存器、内存单元或者标志寄存器的内容, 这条指令就是为这个目的而设的.

指令都是连续存放的, 因此, 所谓的断点, 就是某条指令的起始地址. **int3 是单字节指令**, 这是有意设计的. 当需要设置断点时, 可以将断点处那条指令的第 1 字节改成 0xcc, 原字节予以保存. 当处理器执行到 int3 时, 即发生 3 号中断, 转去执行相应的中断处理程序. 中断处理程序的执行也要用到各个寄存器, 这会破坏它们的内容, 但 push 指令不会. 我们可以在该程序内先压栈所有相关寄存器和内存单元, 然后分别取出予以显示, 它们就是中断前的现场内容. 最后, 再恢复那条指令的第 1 字节, 并修改位于堆栈中的返回地址, 执行 iret 指令.

注意, int3 和 int 3 不是一回事. 前者的机器码为 CC, 后者则是 CD 03, 这就是通常所说的 int n, 其操作码为 0xCD, 第 2 字节的操作数给出了中断号. 举几个例子:

```
int 0x00 ;引发 0 号中断
int 0x15 ;引发 0x15 号中断
int 0x16 ;引发 0x16 号中断
```

into 是溢出中断指令, 机器码为 0xCE, 也是单字节指令. 当处理器执行这条指令时, 如果标志寄存器的 OF 位是 1, 那么, 将产生 4 号中断. 否则, 这条指令什么也不做.

## 1. 常用的 BIOS 中断

可以为所有的中断类型自定义中断处理过程, 包括内部中断、硬件中断和软中断. 特别是考虑到处理器允许 256 种中断类型, 而且大部分都没有被硬件和处理器内部中断占用.

不像 jmp 和 call 指令, int 指令不需要知道目标程序的入口地址. 远转移指令 jmp 和远调用指令 call 必须直接或者间接给出目标位置的段地址和偏移地址.

但如果想调用别人的代码, 比如操作系统的功能, 这就很麻烦了. 操作系统通常不会给出或者公布硬盘读写例程的段地址和偏移地址, 因为操作系统也是经常修改的, 经常发布新的版本. 这样一来, 例程的入口地址也会跟着变化. 而且, 也不能保证每次启动计算机之后, 操作系统总待在同一个内存位置.

有了软中断, 这是个利好条件. 每次操作系统加载完自己之后, **以中断处理程序的形式提供硬盘读写功能**, 并**把该例程的地址填写到中断向量表中**. 这样, 无论在什么时候, 用户程序需要该功能时, 直接发出一个软中断即可, 不需要知道具体的地址.

最有名的软中断是 BIOS 中断, 因为这些中断功能是在计算机加电之后, **BIOS 程序执行期间建立起来的**. 换句话说, 这些中断功能在加载和执行主引导扇区之前, 就已经可以使用了.

BIOS 中断, 又称 BIOS 功能调用, 主要是为了方便地使用最基本的硬件访问功能. 不同的硬件使用不同的中断号, 比如, 使用键盘服务时, 中断号是 0x16, 即

```
int 0x16
```

