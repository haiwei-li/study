
## 1. 寄存器寻址

```
mov ax,cx
add bx,0xf000
inc dx
```

## 2. 立即寻址

立即寻址又叫立即数寻址. 也就是说, 指令的操作数是一个立即数.

```
add bx,0xf000
mov dx,label_a
```

第一条指令中, 目的操作数采用寄存器寻址方式. 源操作数是立即数寻址.

第二条指令中, 目的操作数采用寄存器寻址方式. 标号是数值的的等价形式, 代表了一个汇编地址. 因此, 在编译阶段, 会被转化成一个立即数. 因此, 源操作数也是立即数寻址.

## 3. 内存寻址

寄存器寻址的操作数位于寄存器中, 立即寻址的操作数位于指令中, 是指令的一部分.

内存容量巨大, 在指令中使用内存地址, 来操作内存中数据.

8086 处理器访问内存时, 采用的是段地址左移 4 位, 然后加上偏移地址, 来形成 20 位物理地址的模式, 段地址由 4 个段寄存器之一来提供, 偏移地址要由指令来提供.

因此, 所谓内存寻址, 实际上就是寻找偏移地址, 这称为有效地址(Effective Address, EA). **内存寻址就是如何在指令中提供偏移地址**, 供处理器访问内存时使用.

### 3.1 直接寻址

操作数是一个偏移地址, 而且给出了该偏移地址的具体数值.

```
mov ax,[0x5c0f]
add word [0x0230],0x5000
xor byte [es:label_b],0x05
```

但凡表示内存地址的, 都必须用中括号括起来.

第一条指令中, 源操作数使用的是直接寻址方式, 当这条指令执行时, 处理器将数据段寄存器 DS 的内容左移 4 位, 加上这里的 0x5c0f, 形成 20 位物理地址. 接着, 从该物理地址处取得一个字, 传送到寄存器 AX 中.

第三条指令中, 目的操作数使用标号和段超越前缀, 但依然属于直接寻址方式. 标号是数值的等价形式, 在指令编译阶段, 会被转换成数值; 而段超越前缀仅仅用来改变默认的数据段.

### 3.2 基址寻址

一大堆的数据要处理, 而且它们通常都是挨在一起, 顺序存放的.

```
buffer dw 0x20,0x100,0x0f,0x300,0xff00
```

编译并查看内存分布(小端模式).

```
root@Gerry:/home/project/nasm# cat t.asm
buffer dw 0x20,0x100,0x0f,0x300,0xff00

root@Gerry:/home/project/nasm# nasm t.asm

root@Gerry:/home/project/nasm# hexdump -Cv t
00000000  20 00 00 01 0f 00 00 03  00 ff                    | .........|
0000000a
```

要让数据统统加一, 使用直接寻址指令:

```
inc word [buffer]
inc word [buffer+2]
inc word [buffer+4]
···
```

考虑到简洁性和效率, 使用循环完成的话, 可以使用基址寻址. 所谓**基址寻址**, 就是**在指令的地址部分使用基址寄存器 BX 或 BP 来提供偏移地址**.

```
mov [bx],dx
add byte [bx],0x55
```

第一条指令中的目的操作数采用了基址寻址. 指令执行时, 处理器将**数据段寄存器 DS**的内容左移 4 位, 加上基址寄存器 BX 中的内容, 形成 20 位物理地址. 然后, 把寄存器 DX 中的内容传送到该地址处的字单元中.

可以用以下的代码来处理上面的批量加一任务:

```
    mov bx,buffer
    mov cx,4

lpinc:
    inc word [bx]
    add bx,2
    loop lpinc
```

基址寻址的寄存器也可以是 BP.

```
mov ax,[bp]
```

源操作数使用了基址寻址方式. 不过, 这个与前面指令不同, 它采用的是基址寄存器 BP, 在形成 20 位物理地址时, 默认段寄存器是 SS. 即, 它经常用于访问堆栈. 这条指令执行时, **处理器将堆栈寄存器 SS 内容左移 4 位, 加上 BP 寄存器的内容, 形成 20 位物理地址**, 并将改地址处的一个字传送到寄存器 AX 中.

访问堆栈的一般方法是使用 push 和 pop 指令. 使用 pop 弹出顺序是不可变的, 而且堆栈中的数据也变化了, SP 指针也变化了.

有时候需要越过这种限制, 去访问栈中的内容, 还不能破坏堆栈的状态, 特别是堆栈指针寄存器 SP 的内容, 使得 push 和 pop 操作能正常进行. 一个典型的例子是高级语言里的函数调用, 所有的参数都位于堆栈中. 为了能访问到那些被压在栈底的参数, 这时, BP 就能派上用场:

```
mov ax,0x5000
push ax
mov bp,sp
mov ax,0x7000
push ax
mov dx,[bp] ;dx 中的内容为 0x5000
```

在压入 0x5000 之后, 立即将堆栈指针 SP 保存到 BP. 后面, 尽管栈顶的数据 0x7000 没
有出栈, 但依然可以用 BP 取出压在堆栈下面的 0x5000. 如此一来, 正常的 push 和 pop 操作照样进行, 同时, 还能访问到栈中的参数.

基址寻址允许在基址寄存器的基础上使用一个偏移量.

```
mov dx,[bp-2]
```

处理器在执行时, **将段寄存器 SS 的内容左移 4 位**, 加上 BP 的内容, 再减去偏移量 2 以形成物理地址. 在**保持基址寄存器 BP 内容不变**的情况下, 就可以访问栈中的任何元素. 这里, dx 寄存器值会是 0x7000.

这种增加偏移量的做法也适用于基址寄存器 BX.

```
    xor bx,bx
    mov cx,4
lpinc:
    inc word [bx+buffer]
    add bx,2
    loop lpinc
```

### 3.3 变址寻址

变址寻址类似于基址寻址, 唯一不同之处在于这种寻址方式使用的是变址寄存器(或称索引寄存器)SI 和 DI.

```
mov [si],dx
add ax,[di]
xor word [si],0x8000
```

除非使用了段超越前缀, 处理器会访问由段寄存器 DS 指向的数据段, 偏移地址由寄存器 SI 或者 DI 提供.

同样地, 变址寻址方式也允许带一个偏移量:

```
mov [si+0x100],al
and byte [di+label_a],0x80
```

使用的是标号, 但本质上属于一个编译阶段确定的数值.

### 3.4 基址变址寻址

让处理器支持多种寻址方式会增加硬件上的复杂性, 但可以增强它的数据处理能力, 这么做是值得的. 下面是一个稍微复杂一些的任务:

```
string db 'abcdefghijklmnopqrstuvwxyz'
```

将这 26 字节的数据在原地反向排列.

你可能很快想到使用堆栈, 先将这 26 个数据压栈, 再反向出栈, 因为堆栈是后进先出的, 正好符合要求.

```
    mov cx,26 ;循环次数, 从 26 到 1, 共 26 次
    mov bx,string ;数据区首地址(基地址)
lppush:
    mov al,[bx]
    push ax
    inc bx
    loop lppush ;循环压栈
    mov cx,26
    mov bx,string
lppop:
    pop ax
    mov [bx],al
    inc bx
    loop lppop ;循环出栈
```

不过, 8086 处理器也支持一种基址加变址的寻址方式, 简称基址变址寻址, 可能用起来更方便.

使用基址变址的操作数可以使用一个基址寄存器(BX 或者 BP), 外加一个变址寄存器(SI 或者 DI). 它的基本形式是这样的:

```
mov ax,[bx+si]
add word [bx+di],0x3000
```

第一条指令的源操作数采用了基址变址寻址. 当处理器执行这条指令时, 把数据段寄存器 DS 的内容左移 4 位, 加上基址寄存器 BX 的内容, 再加上变址寄存器 SI 的内容, 共同形成 20 位的物理地址. 然后, 从该地址处取得一个字, 传送到寄存器 AX 中.

采用基址变址寻址方式的排序代码如下:

```
    mov bx,string       ;数据区首地址
    mov si,0            ;正向索引
    mov di,25           ;反向索引
order:
    mov ah,[bx+si]
    mov al,[bx+di]
    mov [bx+si],al
    mov [bx+di],ah      ;以上 4 行用于交换首尾数据
    inc si
    dec di
    cmp si,di
    jl order            ;首尾没有相遇, 或者没有超越, 继续
```

同样地, 基址变址寻址允许在基址寄存器和变址寄存器的基础上带一个偏移量.

```
mov [bx+si+0x100],al
and byte [bx+di+label_a],0x80
```