# 1. 代码段执行时的保护

在 32 位模式下, 尽管**段的信息在描述符表中**, 但是, 一旦相应的描述符被加载到**段寄存器的描述符高速缓存器**, 则处理器取指令和执行指令时, 将**不再访问描述符表**, 而是直接**使用段寄存器的描述符高速缓存器, 从中取得线性基地址, 同指令指针寄存器 EIP 的内容相加, 共同形成 32 位的物理地址**从内存中取得下一条指令. 不过, 在指令实际开始执行之前, 处理器必须检验**其存放地址的有效性**, 以防止执行超出允许范围之外的指令.

每个代码段都有自己的段界限, 位于其描述符中. 实际使用的段界限, 其数值和粒度(G)位有关.

# 2. 堆栈操作时的保护

在截止到目前的所有例子中, **堆栈段一直是使用向下扩展的内存段**, 段界限的检查和向上扩展的数据段和代码段不同. 当然, **堆栈也可以使用向上扩展的段**, 即, **把数据段用做堆栈段**. 在这种情况下, **对段界限的检查按数据段的规则进行**, 但是无论如何, **堆栈本身始终总是向下增长的(这和堆栈往上或往下增长无关)**, 即, **向低地址方向推进**. 段的扩展方向用于处理器的界限检查, 而对堆栈的性质以及在堆栈上进行的操作没有关系.

在第 16、17 章中, 我们会接触到用向上扩展的段做为堆栈段的情况. 现在仍然只讨论向下扩展的堆栈段.

对堆栈操作的指令一般是**push、pop、ret、iret**等. **这些指令在代码段中执行, 但实际操作的却是堆栈段**.

现在只讨论 32 位的堆栈段, 即, **其描述符 B 位是 1 的堆栈段**. 处理器在这样的段上执行压栈和出栈操作时, 默认使用 ESP 寄存器.

在堆栈段中, 实际使用的段界限也和粒度(G)位相关.

堆栈段是向下扩展的, 每当**往堆栈中压入数据**时, **ESP 的内容要减去操作数的长度**. 所以, 和向高地址方向扩展的段相比, 非常重要的一点就是, 实际使用的段界限就是**段内不允许访问的最低端偏移地址**. 至于最高端的地址, 则没有限制, 最大可以是 0xFFFFFFFF. 也就是说, 在进行堆栈操作时, 必须符合以下规则:
```
实际使用的段界限＋1≤(ESP 的内容－操作数的长度)≤0xFFFFFFFF
```
在上一章里, **堆栈段的粒度是字节**(G＝0), **描述符中的段界限是 0x07A00**. 此时, **实际使用的段界限也是 0x07A00**.

假设现在 ESP 的内容是 0x00007A04,

```
push edx
```

因为是要压入一个双字(4 字节), 故处理器在向堆栈中写入数据之前, 先将 ESP 的内容减去 4, 得到 0x7A00, 这就是 ESP 寄存器在进行压栈操作时的新值. 因为该值小于实际使用的段界限 0x7A00 加一(0x7A01), 因此不允许执行该操作.

**堆栈指针寄存器 ESP**的内容仅仅在访问堆栈时提供**偏移地址**, 操作数在压入堆栈时的物理地址要用段寄存器的描述符高速缓存器中的**段基址**和**ESP 的内容相加**得到.

# 3. 数据访问时的保护

这里所说的数据段, 特指向上扩展的数据段, 有别于堆栈和向下扩展的数据段.

因为是向上扩展的, 所以代码段的检查规则同样适用于数据段. 不同之处仅仅在于, 对于**取指令**来说, 是否越界取决于**指令的长度**; 而对于**数据段**来说, 则取决于**操作数的尺寸**.

在 32 位模式下, 处理器使用 32 位的段基地址加上 32 位的偏移量, 共同形成 32 位的物理地址来访问内存. 段基地址由段描述符指定, 而偏移量由指令直接或者间接给出. 很显然, 在段最大的时候, 可以自由访问 4GB 空间内的任何一个单元.

