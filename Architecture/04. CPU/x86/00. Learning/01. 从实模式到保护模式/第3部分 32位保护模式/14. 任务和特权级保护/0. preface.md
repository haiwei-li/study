在保护模式下, 通过将内存分成大小不等的段, 并用描述符对每个段的用途、类型和长度进行指定, 就可以在程序运行时由处理器硬件施加访问保护.

段保护时处理器提供的基本保护功能, 但对于现实的需求来说, 仍是不够的.

首先, 当一个程序访问只属于自己的段时, 基本的段保护机制很有效. 但是一个恶意程序, 仍然可以通过追踪 和修改描述符表来达到它们访问任何内存位置的目的. 比如, 用户程序知道了 GDT 的位置, 可以通过向段寄存器加载操作系统的数据段描述符, 或者在 GDT 中增加一个指向操作系统数据区的描述符, 来修改只属于操作系统的私有数据.

其次, 32 位系统是为多任务系统而设计的. 也就是能同时执行两个以上的程序. 在单核系统中, 多个程序并不能真正同时执行, 但是, 处理器可以在多个任务之间周期性切换和轮转.

多任务系统, **对任务之间的隔离和保护**, 以及**任务和操作系统之间的隔离和保护**都提出了要求, 这可以看做对段保护机制的进一步强化. 同时, 在多任务系统中, 操作系统居于核心软件位置, 为各个任务服务, 负责任务加载、创建和执行环境的管理, 并执行任务之间的调度, 对操作系统的保护很重要. 事实上, 对这种要求, 基本段保护机制已经无能为力了.

**该章主要将特权级转移, 任务切换见下章**

```
第 14 章 任务和特权级保护	245
14.1 任务的隔离和特权级保护	246
    14.1.1 任务、任务的 LDT 和 TSS	246
    14.1.2 全局空间和局部空间	248
    14.1.3 特权级保护概述	250
14.2 代码清单 14-1	257
14.3 内核程序的初始化	257
    14.3.1 调用门	258
    14.3.2 调用门的安装和测试	261
14.4 加载用户程序并创建任务	264
    14.4.1 任务控制块和 TCB 链	264
    14.4.2 使用栈传递过程参数	266
    14.4.3 加载用户程序	268
    14.4.4 创建局部描述符表	269
    14.4.5 重定位 U-SALT 表	270
    14.4.6 创建 0、1 和 2 特权级的栈	271
    14.4.7 安装 LDT 描述符到 GDT 中	271
    14.4.8 任务状态段 TSS 的格式	272
    14.4.9 创建任务状态段 TSS	276
    14.4.10 安装 TSS 描述符到 GDT 中	276
    14.4.11 带参数的过程返回指令	277
14.5 用户程序的执行	278
    14.5.1 通过调用门转移控制的完整过程	278
    14.5.2 进入 3 特权级的用户程序的执行	281
    14.5.3 检查调用者的请求特权级 RPL	284
    14.5.4 在 Bochs 中调试程序的新方法
```