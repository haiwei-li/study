# 1. 通过调用门转移控制的完整过程

先看完整的调用门控制转移和返回过程.

## 转移的过程

首先, 通过调用门实施控制转移, 可以使用 jmp far 和 call far 指令. 指令执行时, **描述符选择子必须指向调用门(调用门描述符安装在 LDT 或 GDT 中**), 32 位偏移量被忽略. 使用下表的特权检查机制. 注意, 表比较关系是数值上的.

![config](images/11.png)

当使用 jmp far 指令通过调用门控制转移时, 要求当前特权级和目标代码段的特权级相同. 原因是用**jmp far 指令通过调用门控制转移时, 不改变 CPL**.

相反, 使用 **call far 指令通过调用门控制转移**时, 如果**改变了当前特权级, 则必须切换栈(任务内的控制转移, 必须切换栈)**. 即, 从当前任务的固有栈切换到与目标代码段特权级相同的栈上. 栈的切换由处理器自动进行.

当前栈是由 SS 和 ESP 的当前内容所指示的. 要切换到的新栈的相关信息位于当前任务的 TSS 中, 处理器知道如何找到它. **栈切换**过程如下:

1. 根据**目标代码段的 DPL**(也就是新的 CPL)到**当前任务的 TSS**中读取**新栈的选择子和栈指针**. 在读取栈选择子、栈指针或者栈段描述符的过程中, 任何违反段界限的错误都将导致产生一个无效 TSS 异常.
2. 检查栈段描述符的特权级和类型是否有效, 若无效同样产生一个无效 TSS 异常.
3. 临时保存 SS 和 ESP 的**当前值**, 把新栈的选择子和栈指针加载到 SS 和 ESP 中. 然后把临时保存的 SS 和 ESP 的内容压入新栈中.
4. 根据调用门描述符中"**参数个数"字段**, 把**旧栈中的所有参数**复制到**新栈**中. 如果参数个数为 0, 则不复制参数.

![config](images/23.png)

5. 将**当前 CS 和 EIP**的内容压入**新栈**. 通过调用门实施的控制转移一定是远转移, 所以要压入 CS 和 EIP.
6. 从**调用门描述符**中把**目标代码段的选择子和段内偏移值**传送到**CS 和 EIP**中, 开始执行被调用过程.

相反, 如果没有改变特权级别, 则不切换栈, 继续使用调用者**当前的栈**, 只是在原来的基础上压入当前**CS 和 EIP**的内容.

![config](images/22.png)

另外, 如果通过调用门的控制转移是 jmp far 指令发起的, **不会返回原来的调用者, 且没有特权级变化, 也不需要切换栈**. 相反, 如果是 call far 指令发起的, 则**可以使用远返回指令 retf 把控制返回到调用者**.

## 返回的过程

对于相同特权级的返回, CPU 从堆栈中弹出 EIP 和 CS; **会发生特权级改变的远返回仅允许返回到低特权级程序中**, 即返回到的代码段的 DPL 在数值上要大于 CPL. 返回的全部过程如下:

1. 检测被调用者栈中 CS 寄存器的 RPL 字段值, 以确定在返回时特权级是否发生改变.
2. 弹出并使用被调用过程栈上的值加载 EIP 和 CS 寄存器. 在此过程中会对代码段描述符和代码段选择子的 RPL 进行特权级与类型检查.
3. 如果远返回指令是带参数的, 则将参数和 ESP 寄存器的当前值相加, 以跳过被调用者栈中的参数部分, 最后的结果是 ESP 寄存器指向调用者 SS 和 ESP 的压栈值. 注意, retf 指令的参数必须等于调用门中所有参数的总字节数之和.
4. 如果返回时需要改变特权级, 则从栈中将 ESP 和 SS 弹出, 并把值代入寄存器 ESP 和 SS, 切换到调用者的栈.
5. 如果远返回指令是带参数的, 则将参数和 ESP 寄存器的当前值相加, 以跳过调用者栈中的参数部分, 最后的结果是调用者的栈恢复平衡.
6. 如果返回时需要改变特权级, 则检查 DS,ES,FS 和 GS 的内容, 如果段选择子指向数据段或者非一致代码段且段描述符的 DPL 在数值上小于返回后的新 CPL, 那么就把数值 0 传送到该段寄存器.

# 2. 如何转到用户程序(特权级 3)的执行

任务寄存器 TR 总是指向当前任务的 TSS, 而 LDTR 寄存器也总是指向当前任务的 LDT. TSS 是任务的主要标志, 因此要使 TR 寄存器指向当前任务; 而使用 LDTR 的原因是可以在任务执行期间加速对段的访问.

在多任务环境中, 从旧任务切换的新任务的时候, TR 和 LDTR 寄存器的值都会更新, 以指向新任务. 但是, **目前我们只有一个任务, 而且是特权级为 3 的任务, 不能用任务切换的方法使它运行**. 我们遇到的问题可以表述为: 如何从任务的全局空间(处于特权级 0)转移到它自己的局部空间(处于特权级 3)?

答案是分为两步:
1. 确立身份, 使 TR 和 LDTR 寄存器指向这个任务;
2. 假装从调用门返回;

## TR 和 LDTR 寄存器

TR 和 LDTR 寄存器都包括 16 位的选择器部分和描述符高速缓存器部分(如下图所示). 选择器部分的内容是 TSS 和 LDT 描述符的选择子; 描述符高速缓存器部分的内容则指向当前任务的 TSS 和 LDT, 以加速这两个段(表)的访问.

![config](images/24.png)

## ltr 和 lldt 指令

加载任务寄存器 TR 的指令是 ltr, 其格式为

```
ltr r/m16
```

1. 这条指令的操作数是通用寄存器或者 16 位的内存单元, 里面的内容是 16 位的 TSS 选择子.
2. 执行这条指令后, **处理器用选择子访问 GDT, 找到 TSS 描述符, 将基地址、段界限、段属性加载到描述符高速缓存器中, 同时将该描述符中的 B 位置 1, 但并不执行任务切换**.
3. 该指令属于特权指令, 只能在 0 特权级下执行.
4. 该指令不影响 EFLAGS 的任何标志位.

加载局部描述符表寄存器 LDTR 的指令是 lldt, 其格式为

```
lldt r/m16
```

ltr 和 lldt 指令执行时, **处理器首先要检查描述符的有效性, 包括审查它是不是 TSS 或 LDT 描述符. 在将 LDT 选择子加载到 LDTR 后, 处理器用该选择子访问 GDT 中对应的 LDT 描述符, 将段界限和段基地址加载到 LDTR 的描述符高速缓存器部分**. CS、SS、DS、ES、FS 和 GS 寄存器当前内容不受该指令影响, 包括 TSS 中的 LDT 选择子字段.

如图, 任务全景图.

![config](images/25.png)

注意, 现在, 局部描述符表(LDT)已经生效, 可以通过它访问用户程序的私有内存段了.

## 假装从调用门返回

从用户程序头部取出栈选择子和栈指针, 以及代码选择子和入口点, 并将它们顺序压入当前的 0 特权级栈中.

```
 ;以下假装是从调用门返回. 摹仿处理器压入返回参数
push dword [0x08]                  ;调用前的堆栈段选择子
push dword 0                       ;调用前的 esp

push dword [0x14]                  ;调用前的代码段选择子
push dword [0x10]                  ;调用前的 eip

retf
```

这段代码要结合用户程序头部的格式和调用门的返回过程来分析.

用户程序头部的格式如下图

![config](images/26.png)

参照上面从调用门的返回过程是:

1. 检测被调用者栈中 CS 寄存器的 RPL 字段值, 以确定在返回时特权级是否发生改变.
2. 弹出并使用被调用过程栈上的值加载 EIP 和 CS 寄存器. 在此过程中会对代码段描述符和代码段选择子的 RPL 进行特权级与类型检查.
3. 如果远返回指令是带参数的, 则将参数和 ESP 寄存器的当前值相加, 以跳过被调用者栈中的参数部分, 最后的结果是 ESP 寄存器指向调用者 SS 和 ESP 的压栈值. 注意, retf 指令的参数必须等于调用门中所有参数的总字节数之和.
4. 如果返回时需要改变特权级, 则从栈中将 ESP 和 SS 弹出, 并把值代入寄存器 ESP 和 SS, 切换到调用者的栈.
5. 如果远返回指令是带参数的, 则将参数和 ESP 寄存器的当前值相加, 以跳过调用者栈中的参数部分, 最后的结果是调用者的栈恢复平衡.
6. 如果返回时需要改变特权级, 则检查 DS,ES,FS 和 GS 的内容, 如果段选择子指向数据段或者非一致代码段且段描述符的 DPL 在数值上小于返回后的新 CPL, 那么就把数值 0 传送到该段寄存器.

上面代码执行完后, 栈的布局如下(这其实是内核的栈, 并不是用户的 0 特权级栈):

![config](images/27.png)

我们对着上面的返回步骤, 一步一步来看.
1. 因为用户程序的 CS 寄存器中的 RPL=3, 所以在返回的时候特权级要发生改变.
2. 弹出用户程序的 EIP 和 CS(绿色部分)加载 EIP 和 CS 寄存器.
3. 第 864 行的 retf 指令不带参数, 所以这步跳过.
4. 从栈中将用户程序的 ESP 和 SS(蓝色部分)弹出, 并把值代入寄存器 ESP 和 SS, 切换到调用者的栈(实际是用户程序的 3 特权级栈).
5. 第 864 行的 retf 指令不带参数, 所以这步跳过.
6. 因为 DS 中的内容是用户程序头部段的选择子, 其 DPL=3, 所以不会把数值 0 传到 DS; 至于 ES、FS 和 GS, 它们一般会指向内核数据段, 其 DPL=0, 所以这些寄存器很可能被数值 0 加载, 所以用户程序中应该对它们先初始化再引用.

执行远返回指令 retf, 假装从调用门返回.