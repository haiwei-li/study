
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 时钟分类](#1-时钟分类)
  - [1.1. 周期性时钟](#11-周期性时钟)
  - [1.2. 单次计时时钟](#12-单次计时时钟)
- [2. x86 平台的常用时钟](#2-x86-平台的常用时钟)
  - [2.1. PIT: 可编程间隔时钟](#21-pit-可编程间隔时钟)
  - [2.2. RTC: 实时时钟](#22-rtc-实时时钟)
  - [2.3. TSC: 时间戳计数器](#23-tsc-时间戳计数器)
  - [2.4. LAPIC Timer: 本地时钟中断](#24-lapic-timer-本地时钟中断)
  - [2.5. HPET: 高精度时钟](#25-hpet-高精度时钟)
- [3. 操作系统的时钟观](#3-操作系统的时钟观)
  - [3.1. 统计值和驱动事件](#31-统计值和驱动事件)
  - [3.2. 定时器](#32-定时器)

<!-- /code_chunk_output -->

# 1. 时钟分类

现代计算机中, 操作系统中很多事件都是时钟驱动的, 例如进程调度、定时器等.

操作系统时钟从作用上分为两种: 计时和定时器

硬件方面 x86 主流平台**计时**靠**tsc****定时**靠**local apic timer**.

软件方面 linux, 低精度高精度先低精度然后切换到高精度.

时钟根据**工作方式**不同, 可以分为如下两类.

## 1.1. 周期性时钟

⓵ **周期性时钟**(Periodic Timer): 时钟以固定频率产生时钟中断.

通常, 周期性时钟会有**一个计数器**,
- 要么以**固定值递减到 0**产生**中断**, 例如 PIT;
- 要么**固定增长**, 当**达到某个阙值**时产生**中断**, 同时自动将阙值增加一个固定值, **计数器继续递增**, 例如**HPET**.

## 1.2. 单次计时时钟

⓶ **单次计时时钟**(One\-shot Timer): 多数时钟都可以配置成这种方式, 例如 PIT、HPET.

其工作方式和**到达阙值产生中断的周期性时钟**类似, 不同的是**产生中断后阙值不会自动增加**, 而是需要**软件**(通常是时钟中断处理函数)**增加该阙值**.

这提供给软件**动态调整下一次时钟中断**到来时间的能力, 使一些新技术,例如**无滴答声内核**(**Tickless Kernel**)的实现成为可能.

# 2. x86 平台的常用时钟

由于历史原因, x86 平台有多种时钟, 目前仍广泛使用的有以下几种.

## 2.1. PIT: 可编程间隔时钟

(1) **PIT**: Programmable Interrupt Timer 或 Programmable Interval Timer, **可编程中断/间隔时钟**

IBM PC 平台产生, 频率为**1000Hz 左右**, 即**每次中断间隔约为 1ms**, 通常接**IRQ0**产生**周期性的时钟中断信号！！！** 来充当**系统定时器**, 软件可以通过`0x40~0x43 I/O`端口进行操作.

通过古老的 8259pic 0 号中断响应 `timer_interrupt` 这个中断处理函数

PIT 是一种低精度的时钟, 容易溢出(16 位), 已渐渐被高精度时钟取代. 现在的 Linux 基本上不怎么用它. 说白了它就是个**硬件实现的计数器系统**通过**时钟中断**来满足操作系统的**定时器需求**通过写某些位来设置定时器操作系统同时也要维护一套软件的定时器链表与这个硬件链表进行对应

PIT 支持**周期性**和**单次计时**两种方式.

8254 PIT 有**3 个计时通道**, 每个通道都有其不同的用途:

- **通道 0**用来负责**更新系统时钟**. 它在**每个时钟滴答**会通过**IRQ0**向系统发出一次**时钟中断信号**.
- **通道 1**通常用来控制**DMAC 对 RAM 的刷新**
- **通道 3**被连接到**PC 机的扬声器**, 以产生**方波信号**.

## 2.2. RTC: 实时时钟

(2) **RTC(Real Time Clock, 实时时钟**): 支持**周期性**和**单次计时**两种方式.

通常**和 CMOS 集成**在一起, 由**CMOS 电池供电**, 故能在**关机后继续计时**. 开机时读取需要的时候写入它能够提供**稳定的时钟脉冲**其频率范围是`2~8192Hz`, 通常接**IRQ8**, 软件可以通过`0x70~0x71 I/O`端口操作.

此外, 它还可以配置成**每秒产生一次中断！！！**, 具有**闹钟功能**. 由于具有**关机继续计时**的功能, RTC 常被用来作**为操作系统提供日期**. 即"年/月/日".

在 Linux 中可以用 RTC 来获取当前的时间. 它提供的稳定的脉冲就是可编程计数器的最底层. 也就是说它是 PIT 和 HPET 的源头.

## 2.3. TSC: 时间戳计数器

参见: `Architecture/Learning/x86_64 编程体系探索及编程/第 3 篇 调试和性能监控/第 15 章 性能监控/6. Time-stamp counter 与 clock.md`

(3) **TSC(Time Stamp Counter, 时间戳计数器**): 由于**不产生时钟中断！！！**, 故没有周期性或单次计时方式之说.

和普通时钟不同, 可以看作一个**单调递增的计数器(64 位**), 是由 x86 架构引入的.

TSC 的主体是位于 CPU 里面的一个 64 位的**TSC 寄存器**. **每个 CPU 时钟周期**其值加一, 即**每个时钟信号**到来时加 1.

其**时钟频率**和**CPU 的频率**相关, 操作系统在使用前**需要计算其频率**, 例如**1GHz**的 TSC, 其值**每纳秒增加 1**.

通过**rdtsc**指令, 可以读取**当前 TSC 的值**. 通过它**也可以校准 RTC**. 很多系统都是通过**读取这个时间**来作为**系统的时间**.



Linux 提供的 API —— `gettimeofday()`可以获取**微秒级的精度**. 但是首先它**不能**提供**纳秒级精度**其次他是一个**库函数**(可能不是系统调用)自身就有一定的开销当需要纳秒级精度时误差会很大.

而且**测定函数的性能**以**时钟周期**为单位比纳秒更加合理. 当不同型号的 CPU 的频率不同时运行时间可能差很多但是时钟周期应该差不了多少(如果指令集一样的话).

那么怎么测定时钟周期呢?x86 处理器为我们提供了 rdtsc 指令. 从 pentium 开始很多 x86 处理器都引入了 TSC(Time Stamp Counter)一个 64 位的寄存器每个 CPU 时钟周期其值加一. 它记录了 CPU 从上电开始总共经历的时钟周期数. 一个 2.5GHz 的 CPU 如果全速运行的话那么其 TSC 就会在一秒内增加 2,500,000,000. 在使用过程中不用担心 TSC 会溢出因此 64 位整数可以"应付"一个 2.5GHz 的 CPU 运行 217 年！

rdtsc 指令把 TSC 的低 32 位存放在 EAX 寄存器中把 TSC 的高 32 位存放在 EDX 寄存器中. 该指令可以在用户态执行.




## 2.4. LAPIC Timer: 本地时钟中断

(4) **LAPIC Timer**: 该时钟是根据**LAPIC 所在总线**(**系统总线**或**APIC 总线**)频率产生的.

这个是针对 smp 系统的时钟当系统没有本地时钟的时候也可以通过时钟广播的方式模拟这个本地时钟在 smp 系统中 linux 会优先选择这个时钟源一旦使用了这个时钟 0 号中断绑定的时钟源的 profiling 和 update 功能将会被 switched off. 比如 pit 将会从 periodic 转变为 oneshot. 所以只要打开了 local apic 将优先使用这个时钟源. 它的中断处理函数 smp_apic_timer_interrupt. 它在 x86 arch 里面的 entry_64.s 汇编文件中 built. 有点复杂. 实现在 apic.c 中.

为 32 位, 有如下两个特点.

⓵ 由于 LAPIC 是每个 CPU 一个, 故其中断也是**对于本地 CPU 的**(Per CPU Interrupt).

⓶ 可通过**寄存器配置**, 对总线周期进行不同的分频而产生**不同频率的时钟中断！！！**.

LAPIC Timer 可配置成**周期性**和**单次计时**两种工作方式.

## 2.5. HPET: 高精度时钟

(5) **HPET**(High Precision Event Timer, 高精度事件时钟): Intel 和微软共同开发的新型高精度时钟, **最低频率 10MHz**, 可作为 64 位或 32 位时钟使用.

HPET 可以提供**最多 8 个时钟**, 典型实现至少有一个时钟可用.

HPET 时钟通过**一个主计数器**, 和**32 个比较器、匹配器**一起, 又可以被配置成**32 个子时钟**(又称 channel), **每个子时钟**可按不同频率产生不同的中断.

例如, 可将**一个子时钟**配置成**每毫秒**产生一个**IRQ8 中断**, **另一个子时钟**可配置成每毫秒产生一个**IRQ0 中断**.

HPET 被设计用来**代替**传统 8254 **PIT**可编程定时器的**全部功能**和实时钟**RTC**芯片的**周期性中断功能**, 此时平台的**IRQ0**、**IRQ8**中断**被 HPET 占用**.  cpu 内部时钟源同样响应 0 号中断响应 timer_interrupt. Linux 中 hpet 已经取代了 pit 有 hpet 系统先选择 hpet.

HPET 支持**周期性**和**单次计时**两种工作方式.

同时使用多个时钟带来一个明显缺点是**过多时钟中断会影响系统的性能(！！！**).

所以, 当高精度时钟可用, **OS 通常会禁用低精度时钟(！！！**), 并根据需要使用**高精度时钟模拟低精度时钟**.

# 3. 操作系统的时钟观

* 硬件方面, x86 主流平台, **计时**靠`tsc`**定时**靠`local apic timer`.

* 软件方面, linux, 低精度高精度, 先低精度然后切换到高精度.

两个系统时钟的常识**jiffies**和**xtimer**前者是 linux 系统时钟的**累计数字**后者是系统的**墙上时间**.

从操作系统角度看, **时钟作用**可以分为如下两类.

## 3.1. 统计值和驱动事件

⓵ 提供**统计值**及**驱动事件**:

- 提供**统计值**是指操作系统用时钟来**维护一些必需的数据**, 例如一个**进程**在**用户态/内核态的时间**, 系统的日期、时间等.

- **驱动事件**是指**驱动以时间为资源的程序！！！**, 典型就是进程. 例如, 分时操作系统为**每个进程分配固定的时间片**, 调度时间片耗尽的进程睡眠, 唤醒分配到新时间片的进程运行.

## 3.2. 定时器

⓶ **维护定时器(Timer**): 定时器是程序中常用的组件, 用于在某个指定时间到达后执行特定的操作. 定时器大量运用于操作系统中, 例如内核为 I/O 操作注册的超时定时器、操作系统提供给应用程序使用的定时器接口等. 见图 2\-19.

![](./images/2019-07-01-17-41-22.png)

图中可看到, 操作系统使用时钟的功能, 是以时钟中断为基础的. 要了解时钟的作用, 可以以时钟中断为脉络, 勾画出整个框图.

操作系统往往会对时钟架构进行封装以方便维护和使用. 但从**硬件角度**看, 时钟中断仍然是所有封装的基础, 故**虚拟化**中**对时钟的处理**主要是提供**准确的时钟中断**以**模拟硬件**的行为.