参考:

http://blog.csdn.net/vito_bin/article/details/60779404

## 基本概念

MMIO(Memory mapping I/O)即内存映射 I/O 它是 PCI 规范的一部分 I/O 设备被放置在内存空间而不是 I/O 空间. 从处理器的角度看内存映射 I/O 后系统设备访问起来和内存一样. 这样访问 AGP/PCI-E 显卡上的**帧缓存**BIOSPCI 设备就可以使用读写内存一样的汇编指令完成简化了程序设计的难度和接口的复杂性.

I/O 作为**CPU 和外设交流的一个渠道**主要分为两种一种是 Port I/O(也叫**I/O 映射方式**I/O mapped)一种是 MMIO(Memory mapping I/O 即**内存映射方式**memory mapped).

Port I/O 就是我们常说的 I/O 端口它实际上的应该被称为**I/O 地址空间**.

**x86 为外设专门实现有单独的地址空间可以称为"I/O 地址空间"或"I/O 端口空间"**这个是独立与 CPU 和 RAM 物理地址空间它将所有外设的 IO 端口均在这一空间进行编址. I/O 地址空间通过 IN/OUT 指令访问这就是"**I/O 映射方式**"(不是 MMIO 访问方式).

与物理地址空间相比 I/O 地址空间大小通常较小 X86 架构一共有 65536(2\^16)个 8bit 的 I/O 端口组成 64K I/O 地址空间编号从 0~0xFFFF. 连续两个 8bit 的端口可以组成一个 16bit 的端口连续 4 个组成一个 32bit 的端口. 空间小是"I/O 映射方式"的一个主要缺点可以通过 cat /proc/ioports 查看 IO port 空间的地址分配情况是以树状结构显示. 这源于 X86 平台的设计思想目前基本不用了获取这些资源接口如 request\_region 和 ioremap.

**I/O 地址空间**和 CPU 的**物理地址空间**是两个不同的概念例如 I/O 地址空间为 64K 一个 32bit 的 CPU 物理地址空间是 4G.

MMIO 占用 CPU 的物理地址空间对它的访问可以使用 CPU 访问内存的指令进行. 一个形象的比喻是把文件用 mmap()后可以像访问内存一样访问文件、同样 MMIO 是用访问内存一样的方式访问 I/O 资源如设备上的内存. MMIO 不能被 cache(有特殊情况如 VGA).

32 位操作系统 32bit 的处理器拥有 32bit 寻址能力即可访问 2\^32=4G 的物理地址那么就具有 4G 内存的识别能力.

物理地址: 并不是指物理内存的地址而是指处理器和系统内存之间所用到的地址可以理解为 CPU 最为方便访问的地址(有别于我们之前所知道的物理地址的定义: 段地址\*16+偏移地址\<8086\>)而这一个内存并不独属于物理内存而被分成了很多部分物理内存当然也能够占用其中的一部分. 物理地址并不一定指向内存它有可能指向一个芯片组的功能块也可能指向外设甚至什么也没有指到.

地址范围: 0x0000 0000   -------->0xFFFF FFFF

我们所提到的**4G 物理地址和所安装的内存条没有任何关系是相互独立的**.

**即使安装的是 2G 内存但计算机依然会分配 4G 的内存空间(线性地址空间??)**.

Linux 设计了一个通用的数据结构 resource 来描述各种 I/O 资源(如: I/O 端口、外设内存、DMA 和 IRQ 等). 该结构定义在 include/linux/ioport.h 头文件中. Linux 是以一种倒置的树形结构来管理每一类 I/O 资源. 每一类 I/O 资源都对应有一颗倒置的资源树树中的每一个节点都是个 resource 结构. 基于上述这个思想 Linux 将基于 I/O 映射方式的 I/O 端口和基于内存映射方式的 I/O 端口资源统称为"I/O 区域"(I/O Region).

/proc/iomem 这个文件记录的是物理地址的分配情况也是以树状结构显示对其使用也是 request\_mem\_region 和 ioremap 空间大小为 16EB 远大于 io port 的 64K.

ioport 和 iomem 地址空间分别编制均是从地址 0 开始如果硬件支持 MMIOport 地址也可以映射到 memory 空间去.

这里以 pci 设备为例硬件的拓扑结构就决定了硬件在内存映射到 CPU 的物理地址由于内存访问都是虚拟地址所有就需要 ioremap 此时物理内存是存在的所以不用再分配内存只需要做映射即可

应用总结: 使用 I/O 内存首先要申请,然后才能映射,使用 I/O 端口首先要申请,对 I/O 端口的请求是让内核知道你要访问该端口,内核并让你独占该端口.

申请 I/O 端口的函数是 request\_region,申请 I/O 内存的函数是 request\_mem\_region. request\_mem\_region 函数并没有做实际性的映射工作只是告诉内核要使用一块内存地址声明占有也方便内核管理这些资源. 重要的还是 ioremap 函数 ioremap 主要是检查传入地址的合法性建立页表(包括访问权限)完成物理地址到虚拟地址的转换.

在 intel 的 X86 平台 GPIO 资源也是类似应用如果 IO 配置为 SCI 或者 SMI 中断 SCI 可以产生 GPE 然后经历 acpi 子系统不过 GPE 中断号默认是 0x10+GPIO 端口号.

## Port I/O 和 MMIO 主要区别

- 前者不占用 CPU 的物理地址空间后者占有(这是对 x86 架构说的一些架构如 IA64 port I/O 占用物理地址空间).

- 前者是顺序访问. 也就是说在一条 I/O 指令完成前下一条指令不会执行. 例如通过 Port I/O 对设备发起了操作造成了设备寄存器状态变化这个变化在下一条指令执行前生效. uncache 的 MMIO 通过 uncahce memory 的特性保证顺序性.

- 使用方式不同

由于 port I/O 有独立的 64K I/O 地址空间但 CPU 的地址线只有一套所以必须区分地址属于物理地址空间还是 I/O 地址空间.

## 映射地址空间

目前大多数的 CPU 都支持 36bit 寻址也就是说寻址范围达到了 64G 但这只是从"系统"的视角来说从"内存控制器"的视角来说由于 32bit 的寻址能力的限制只能访问 4G 空间. 如果需要计算机正常工作则所有必须的设备地址都需要存在这 4G 的空间当中使计算机正常工作除了内存之外也包括许多 IO 设备. 图中展示了 4Gb 地址的大致分布除去 main memory 之外大多数都只占据极少的内存一般为几 M 或者几十 M 除了 PCI ECAM. (PCI Memory range)

![config](images/1.png)

