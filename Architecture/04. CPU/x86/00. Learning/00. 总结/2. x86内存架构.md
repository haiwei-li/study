
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 地址空间](#1-地址空间)
  - [1.1. 物理地址空间](#11-物理地址空间)
  - [1.2. 线性地址空间](#12-线性地址空间)
- [2. 地址](#2-地址)
  - [2.1. 逻辑地址](#21-逻辑地址)
  - [2.2. 线性地址](#22-线性地址)
  - [2.3. 物理地址](#23-物理地址)
- [3. x86 内存管理机制](#3-x86-内存管理机制)
  - [3.1. 分段机制](#31-分段机制)
    - [3.1.1. 段选择符 (Segment Selector)](#311-段选择符-segment-selector)
    - [3.1.2. 段描述符 (Segment Descriptor)](#312-段描述符-segment-descriptor)
    - [3.1.3. 段描述符表](#313-段描述符表)
    - [3.1.4. 逻辑地址转换总结](#314-逻辑地址转换总结)
  - [3.2. 分页机制](#32-分页机制)
    - [3.2.1. 页表](#321-页表)
      - [3.2.1.1. 未开启 PAE 的 32 位分页](#3211-未开启-pae-的-32-位分页)
      - [3.2.1.2. 启用 PAE 的 32 位分页](#3212-启用-pae-的-32-位分页)
    - [3.2.2. CR3 寄存器](#322-cr3-寄存器)
    - [3.2.3. TLB](#323-tlb)
    - [3.2.4. 线性地址转换为物理地址的过程](#324-线性地址转换为物理地址的过程)
- [4. x86-64 架构](#4-x86-64-架构)
  - [4.1. IA-32e 的分段机制](#41-ia-32e-的分段机制)
  - [4.2. IA-32e 的分页机制](#42-ia-32e-的分页机制)

<!-- /code_chunk_output -->

**内存架构**往往是硬件架构中**最复杂的部分**.

# 1. 地址空间

很多把内存(这里特指安插在主板上的 RAM)比作一个大数组, 地址就是这个数组的索引. 类似的, 地址空间则是更大的数组, 它是所有可用资源的集合, 同样, 地址是这个数组的索引. 地址空间可以划分成如下两种类型.

## 1.1. 物理地址空间

硬件平台可粗略分为三部分: CPU, 内存和其它硬件设备. 其中, CPU 是平台主导者, 从**CPU 的角度**来看, **内存**和**其它硬件设备**都是可以使用的**资源**. 这些**资源组合(！！！**)在一起, 分布在**CPU 的物理地址空间内(！！！内存只是一部分！！！**). CPU 使用**物理地址索引这些资源(！！！**). **物理地址空间的大小**, 由 CPU 实现的**物理地址位数**决定, **物理地址位数**和**CPU 处理数据的能力(即 CPU 位数**)没有必然关系, 例如**16 位的 8086 CPU**具有**20 位地址空间**.

内存和其它硬件设备分布在物理地址空间中. 假设一个平台, CPU 的**物理地址空间为 4GB**, 有**512MB 内存**, **其它硬件设备的 I/O 寄存器**被映射到**512MB 的 I/O 地址**内, 则该平台的物理地址空间可能是如图所示划分的.

![](./images/2019-07-01-16-29-21.png)

如图, 512MB 内存和 I/O 地址只占用物理地址空间的一部分, 还有大部分处于空闲. 数组再次显示了它的作用, 有一个 4GB 大小的数组, 其中 1GB 的元素具有有效值(512MB 内存, 512MB I/O 地址), 其它元素不存在.

## 1.2. 线性地址空间

**一个平台只有一个物理地址空间**, 但**每个程序**都认为自己**独占整个平台的硬件资源**, 为让多个程序能够有效地相互隔离和使用物理地址空间的资源, 线性地址空间概念被引入. 和物理地址空间一样, 线性地址空间大小取决于 CPU 实现的线性地址位数, 例如实现了 32 位线性地址的 CPU 具有 4GB 大小的线性地址空间. 需要注意, 线性地址空间大小和物理地址空间大小没有必然关系. 例如 Intel 的 PAE 平台就具有 4GB 的线性地址空间, 64GB 的物理地址空间.

线性地址空间会被映射到物理地址空间某一部分或整个物理地址空间. CPU 负责将线性地址转换成物理地址, 使程序能正确访问到该线性地址空间所映射的物理地址空间. **一个平台**可以有**多个线性地址空间**, 在现代操作系统中, 每个进程都拥有自己的私有线性地址空间. 一个典型的线性地址空间如图.

![](./images/2019-07-01-16-29-34.png)

# 2. 地址

地址是访问地址空间的索引. 根据访问地址的不同, 索引可以分为线性地址和物理地址. 但由于 x86 特殊的段机制, 还有一个额外的地址, 逻辑地址.

## 2.1. 逻辑地址

该地址即程序直接使用的地址(x86 架构无法禁用段机制, 逻辑地址一直存在). 例如

```cpp
int a = 1;
int *p = &a;
```

这里, 指针变量 p 存储的就是一个逻辑地址. **逻辑地址**由一个**16 位的段选择符**和一个**32 位的偏移量(32 位平台**)构成. 逻辑地址的转换过程在后面介绍. 在上面例子中, 指针变量 p 实际上存储逻辑地址的偏移部分, 该偏移对应的段选择符位于段寄存器中, 并没有在程序中反映出来.

## 2.2. 线性地址

又称虚拟地址. **线性地址**是**逻辑地址转换后的结果**, 用于**索引线性地址空间**. 当 CPU 使用分页机制时, 线性地址必须转换成物理地址才能访问平台内存或硬件设备; 当分页机制未启用时, 线性地址等于物理地址.

## 2.3. 物理地址

该地址索引物理地址空间, 是 CPU 提交到总线用于访问平台内存和硬件设备的最终地址. 它和上面两个地址有如下关系.

(1) 分段机制启用, 分页未启用: 逻辑地址->线性地址=物理地址

(2) 分段 分页机制同时启用: 逻辑地址->线性地址->物理地址

有些资料还有"总线地址"的提法, 因为**给设备寄存器分配的物理地址(！！！**)和**寄存器在设备上的地址(！！！**)是不同的(通常**设备的寄存器**都**认为自己是从地址 0 开始**的), 两者存在一个**映射关系**, 由设**备的电子线路负责转换并对 CPU 透明(！！！**). 由于**CPU 用于访问设备的物理地址(！！！**)是**设备寄存器展现给总线的地址**, 所以在 x86 下有时称**物理地址为总线地址**.

# 3. x86 内存管理机制

x86 架构的内存管理机制分为两部分: 分段机制和分页机制.

分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域从而避免了同一个处理器上运行的多个程序互相影响.

分页机制实现了传统的按需分页、虚拟内存机制可以将程序的执行环境按需映射到物理内存. 此外分页机制还可以用于提供多任务的隔离.

分段机制和分页机制都可以通过配置支持简单的单任务系统、多任务系统或共享内存的多处理器系统. 需要强调的一点是处理器无论在何种运行模式下都不可以禁止分段机制但是分页机制却是可选选项.

## 3.1. 分段机制

分段是一种简单的内存管理机制, 它将内存划分成以起始地址(Base)和长度(Limit)描述的块, 这些内存块就称为"段". 段可以与程序最基本的元素联系起来, 例如程序可以简单的分为代码段、数据段和栈, 段机制中就有对应的代码段、数据段和栈段.

**分段机制**由**4 个基本部分**组成: **逻辑地址**、**段选择寄存器**、**段描述符**和**段描述符表**.

其**核心思想**是: 使用**段描述符**描述段的基地址、长度以及各种属性(例如**读写属性**、**访问权限**). 当程序使用**逻辑地址**访问内存的某个部分时, CPU 通过逻辑地址中的**段选择符**索引**段描述符表**以得到该内存对应的**段描述符**, 并检测程序的访问是否合法, 合法的话, 根据**段描述符中的基地址**将逻辑地址转换为线性地址.

![](./images/2019-07-01-16-29-57.png)

### 3.1.1. 段选择符 (Segment Selector)

**段选择符**是**逻辑地址**的一个组成部分用于**索引段描述符表**以获得该段对应的段描述符. 段选择符存放于段选择寄存器中共 16 位结构如图 1-4 所示.

图 1-4 段选择符的结构

![](./images/2019-07-01-16-30-08.png)

各字段的含义如下.

- 索引(Index): 段描述符表的索引.
- TI: 指明索引哪个段描述符表. 当 TI=0 时表示索引全局段描述符表(Global Descriptor Table 下面简称为 GDT); 当 TI=1 时表示索引本地段描述符表(Local Descriptor Table 下面简称为 LDT).
- RPL: Requested Privilege Level 的简称即所要求的权限级别. RPL 存在于段选择寄存器的 0、1 位为程序访问段时增加一级检查.

段选择符作为逻辑地址的一部分对应用程序是可见的. 但是正如前面在逻辑地址中介绍的**应用程序**中**只存储**和使用逻辑地址的**偏移部分****段描述符**的**修改和分配**由**连接器和加载器**完成.

为了使 CPU 能够快速地获得段选择符 x86 架构提供了 6 个段寄存器存放当前程序中各个段的段选择符. 这 6 个段寄存器分别如下.

- CS(Code\-Segment 代码段): 存放代码段的段选择符.
- DS(Data\-Segment 数据段): 存放数据段的段选择符.
- SS(Stack\-Segment 栈段): 存放栈的段选择符.
- ES、FS、GS: 可以存放额外三个数据段的段选择符由程序自由使用.

由于段选择符是用来索引段描述符表访问段描述符的为了**加速段描述符的访问**x86 在段寄存器后增加了一个程序**不可见的段描述符寄存器**. 当**段寄存器**被加载到一个**新的段选择符**后 CPU 自动将**该段选择符索引的段描述符**加载到这个**不可见的段描述符寄存器**中. 这 6 个段寄存器的构造如图 1-5 所示.

图 1-5 段寄存器的构造:

![](./images/2019-07-01-16-30-23.png)

### 3.1.2. 段描述符 (Segment Descriptor)

段描述符描述某个段的基地址、长度以及各种属性(例如读/写属性、访问权限等). 这是分段机制的核心思想.

段描述符的结构如图 1\-6 所示.

图 1-6 段描述符的结构

![](./images/2019-07-01-16-30-51.png)

有关段描述符的详细解释可查阅 Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A 一书中 3.4.5 节的内容(附下载网址: http://www.intel.com/Assets/PDF/manual/253668.pdf ). 在此我们只详细介绍其中的 Base 字段、Limit 字段和 DPL 字段.

- Base 字段描述了该段的**基地址**.
- Limit 字段描述了该段的**长度**.
- DPL 字段指明**描述符权限级别**表示该段所具有的权限. 它表示代码**访问此段所需要的最低权限！！！**.

当 CPU 通过一个逻辑地址的段选择符获得该段对应的段描述符后会使用段描述符中各种属性字段对访问进行检查一旦确认访问合法 CPU 将段描述符中的 32 位基地址和程序中逻辑地址的 32 位偏移量相加. 至此 CPU 便获得了逻辑地址所对应的线性地址.

正如前面所讲 x86 在段寄存器后增加了一个程序不可见的段描述符寄存器每当**段寄存器**被加载入一个**新的段选择符**后 CPU 自动将该段选择符索引的**段描述符**加载到这个**不可见的段描述符寄存器**中. 也就是说 CPU**只有在更新段寄存器**时才**索引段描述符表！！！**.

### 3.1.3. 段描述符表

在前面介绍段选择符的结构时我们了解到段选择符中的 TI 字段用于指明索引哪个段描述符表. TI 字段的必要性源于 x86 架构提供了两种段描述符表 — GDT 和 LDT.

系统中至少有一个 GDT 可以被所有的进程访问. 与此同时系统中可以有一个或多个 LDT 可以**被某个进程私有**也可以**被多个进程共享**.

- GDT 是内存中的一个数据结构. 简单地讲可以将**GDT**看成是一个**数组**由**基地址(Base**)和**长度(Limit**)描述.
- LDT 是一个段需要用一个**段描述符**来描述. LDT 的段描述符存放在**GDT**中当系统中有多个 LDT 时 GDT 中必须有对应数量的段描述符.

为了**加速对 GDT 和 LDT**的访问 x86 架构提供了**GDTR 寄存器**和**LDTR 寄存器**. 关于这两种寄存器的具体描述如下.

- GDTR: 包括一个**32 位的基地址(Base**)和**一个 16 位的长度(Limit**).
- LDTR: 结构与段寄存器相同(同样**包含对程序不可见的段描述符寄存器**).

通过使用**LGDT/SGDT 指令**对**GDTR**进行读取/存储;

通过使用**LLDT/SLDT**对 LDTR 进行读取/存储.

在进行**进程切换**时 LDTR 的值会被换成**新进程对应的 LDT 的段描述符**.

通过段选择符索引 GDT/LDT 的过程如图 1-7 所示.

图 1-7 通过段选择符索引段描述符表

![](./images/2019-07-01-16-31-05.png)

### 3.1.4. 逻辑地址转换总结

假设程序中某条语句访问了数据段, 例如:

```c
int a = 100; //全局变量
int func(){
    int b;
    b = a;
}
```

程序从加载到变量 a 的逻辑地址转换为线性地址过程如下.

1. 程序加载

⓵ 通过**该进程 LDT 的段选择符！！！**索引**GDT**, 获得**LDT 的段描述符**, 被加载到**LDTR 寄存器的不可见部分**中.

⓶ 该进程的 CS、DS、SS 被加载到了相应的段选择符. 同时, CPU 根据段选择符的 TI 字段, 索引 GDT/LDT, 获得相应的段描述符并加载到 CS、DS、SS 对应的**不可见部分**.

2. 程序执行到 b=a, 需要从 a 所在的内存中取值, 必须先把 a 的逻辑地址转换成线性地址,

⓵ 进行必要的属性、访问权限检查

⓶ 从 DS 对应的段描述符寄存器获得该段的基地址

⓷ 将变量 a 的 32 位偏移量和描述符中的基地址相加, 获得变量 a 的线性地址.

## 3.2. 分页机制

分页是更加粒度化的内存管理机制, 分页是用粒度化的单位"页"来管理线性地址空间和物理地址空间. x86 下一个典型的页大小是 4KB, 则一个 4GB 的**虚拟地址空间**可以**划分为 1024X1024 个页面**. **物理地址空间的划分同理**. x86 允许大于 4KB 的页面大小, 这里只介绍 4KB 页面.

同时, **分页机制**让操作系统中的**虚拟内存机制**称为可能. **一个页面**可以存在于**物理内存(！！！**)中, 也可以存放在**磁盘的交换区域！！！**(如**Linux 下的 Swap 分区！！！**, **Windows 的虚拟内存文件！！！**)中, 程序可以使用比机器**物理内存更大的内存区域！！！**.

分页机制的核心思想是通过**页表**将**线性地址转换为物理地址**, 并配合**旁路转换缓冲区(Translation Lookaside Buffer, TLB！！！**)来加速地址转换过程. **操作系统**在**启动过程**中, 通过将**CR0 寄存器**的**PG 位置 1**来启动**分页机制**.

![](./images/2019-07-01-16-31-55.png)

从图中看到, 分页机制主要由页表、CR3 和 TLB 三个部件构成. 下面以 4KB 页面的 32 位分页为例进行讲解.

### 3.2.1. 页表

**页表(Page Table**)是用于将**线性地址转换成物理地址**的主要数据结构.

**一个地址对齐到页边界(！！！**)后的值称为**页帧号**, 它实际是**该地址所在页面的基地址**.

- **线性地址对应的页帧号！！！**即**虚拟页帧号(Virtual Frame Number, VFN！！！**),

- **物理地址对应的页帧号！！！**即**物理页帧号(Physical Frame Number, PFN！！！**)或**机器页帧号(Machine Frame Number**).

**页表**就是存储**VFN**到**PFN**映射的数据结构.

#### 3.2.1.1. 未开启 PAE 的 32 位分页

在**传统的 32 位**的保护模式中 x86 处理器使用**两级转换**方案在这种方案中**CR3**指向一个**4KB 的页目录**页目录又分为**1024 个 4KB 大小的页表**最后页表分为 1024 个长为 4KB 的页.

**未启用 PAE 的 4KB 大小**的页面如图 1-9 所示.

图 1-9 未启用 PAE 的 4KB 页——二级页表:

![](./images/2019-07-01-16-32-08.png)

⓵ **页目录项(Page Directory Entry**): 包含**页表的物理地址(！！！不是线性地址！！！**). **页目录项**存放在**页目录(Page Directory, 也称为页目录表 PDT！！！**)中, CPU 使用线性地址的 22\~31 位(高 10 位)索引页目录, 以获得该线性地址对应的页目录项. 每个页目录项为 4B 大小, 故页目录占用 4KB 大小的物理页面, 共包含 1024 的页目录项.

⓶ 页表项(Page Table Entry): 页表项包含**该线性地址对应的 PFN(！！！物理地址页帧号！！！**). **页表项**存放在**页表(Page Table**)中, CPU 使用线性地址的**12\~21 位**索引页表, 获得该**线性地址**对应的**页表项**. 通过将**线性地址**的**0\~11 位**偏移量和**基地址**相加, 就可以得到线性地址对应的物理地址. 页表项为 4B 大小, 故页表包含 1024 个页表项, 占用一个 4KB 页面.

![](./images/2019-07-01-16-32-23.png)

图 2\-9 显示了页目录项、页表项的构成, 通过其中的各个字段, 可以对页面访问权限, 缓存机制, 全局页等属性进行控制.

这里只关注 P(Present)字段, 该字段使虚拟内存的实现成为可能. P 根据其值不同, 可以代表两种情况:

1. P=1: 物理页面存在于物理内存中, CPU 完成地址转换后, 可以直接访问该页面.

2. P=0: **页面不在物理内存**中, 当 CPU 访问该页面时会产生一个**缺页错误(Page Fault**)并交由**操作系统**的**缺页错误处理程序处理**. 通常**操作系统**会将**存放在磁盘上的页面(！！！**)调入**物理内存**, 使访问可以继续. 需要注意的是由于程序的**局部性特点****操作系统**会将该页面**附近的页面一起调入物理内存**方便 CPU 的访问. **P=0**时的**PDE 和 PTE**的**1~31 位**都将为操作系统提供**物理页面在磁盘上的信息**. 通常情况下这些位存储着物理页面在磁盘上的位置. **P=0**时, **页目录项**、**页表项格式**变成图 2-10 中的格式. 此时**1\~31 位**供操作系统使用以记录物理页面在磁盘上的信息, 通常是**物理页面在磁盘上的位置！！！**.

![](./images/2019-07-01-16-32-34.png)

#### 3.2.1.2. 启用 PAE 的 32 位分页

启用物理地址扩展(之后简称为 PAE)后页表结构将发生相应的变化. **页表**和**页目录**的**总大小**仍是**4KB**但**页表**和**页目录**中的**表项**都从**32**位扩为**64 位**以使用附加的地址位.

这样**页表和页目录**都只有**512 个表项**变成了原来方案的一半所以又加入了一个级: **CR3**指向**页目录指针表**即一个包含**4 个页目录指针的表**. 启用 PAE 的 4KB 大小的页面使用的三级页表如图 1\-10 所示.

图 1-10 **启用 PAE 的 4KB 页**——三级页表:

![](./images/2019-07-01-16-32-55.png)

### 3.2.2. CR3 寄存器

CPU 在**索引页目录**前, 必须知道**页目录所在的物理地址**, 该**物理地址**存放在**CR3(Control Register 3)寄存器**中, 也称为**页目录基地址寄存器(Page\-directory base register, PDBR**). 一个**进程在运行前(！！！**), 必须将**其页目录的基地址存入 CR3**. 页目录的基地址必须**对齐到 4K 边界**.

启用 PAE 时 CR3 指向页目录指针表(PDPT).

### 3.2.3. TLB

为提高地址转换效率, x86 架构使用**TLB**对最近用到的**页面映射**进行**缓存**, 当 CPU 访问**某个线性地址**, 其**所在页面的映射**存在于 TLB 中, 无须查找页表即可进行地址转换. 注意, 很多资料说 TLB 存放的是线性地址到物理地址的转换, 准确来说应该是: **VFN 到 PFN 的转换！！！**. 即, **CPU 从 TLB**获得一个**线性地址对应的 PFN**后, 仍然要**和线性地址的偏移相加**, 才能得到**最后的物理地址**, 而**非直接从 TLB 中获取物理地址**.

TLB 作为缓存, 其能存放的映射条目有限, 当 TLB 中没有空闲条目可用时, 替换哪一个旧条目由 CPU 决定.

**TLB**也有**缓存一致性**的问题这主要是指**TLB 中的映射条目(！！！**)和**页表中的映射条目(！！！**)的一致性. 当**操作系统**对**页表进行修改**要**负责对 TLB 中对应条目或整个 TLB 进行刷新(！！！**).

从**软件的角度**来看, x86 提供了**两种方式刷新 TLB**:

⓵ **更新 CR3**: 此操作可以**导致 TLB 被整体刷新**, TLB 中**所有映射条目失效**(**全局 TLB 除外**). 操作系统将**当前 CR3 中的值**重新写会**CR3**以**刷新整个 TLB**. 进程切换时, 新进程的页目录基地址会写入 CR3 而使老进程在 TLB 中的条目失效.

⓶ **INVLPG 指令**: 这是一种更细粒度的刷新, **操作系统**用它对**TLB**中**单独的页目录项**、**页表项**进行刷新. 这通常是在**操作系统修改页表**后进行的(例如**分配/释放页面！！！**).

### 3.2.4. 线性地址转换为物理地址的过程

将分页机制的三个部件——**页表**、**CR3 寄存器**和**TLB**介绍完后这里再对 CPU 使用分页机制将线性地址转换成物理地址的过程进行总结.

⓵ CPU 访问一个线性地址, 映射在 TLB 中跳到⓺. 如映射不存在于 TLB 中, 称为 TLB Miss 发生, 进行下一步.

⓶ **查找页表**, **页面在物理内存！！！** 中跳到⓸, 不会再进行下一步.

⓷ 操作系统的**缺页处理函数**接管, 通常进行如下操作:

a)将页面从磁盘复制到物理内存中;

b)更改对应页表项, 设置 P 为 1, 并对其他字段相应设置;

c)**刷新 TLB 中对应的页表项**;

d)从缺页错误处理函数中返回.

⓸ 到这一步, **页面**已经存在于**物理内存**中, 并且**页表**已经**包含了该映射**. 此时, 重新执行引发 TLB Miss 的指令.

⓹ **TLB Miss 再次发生(！！！**), **CPU 重新查页表**, 把**相应的映射插入到 TLB**中.

⓺ 到这一步, **TLB**已经包含了**该线性地址对应的 PFN**. 通过将**线性地址**中的**偏移部分和 PFN 相加**, 就得到了**对应的物理地址**.

# 4. x86-64 架构

IA\-32e 是 Intel 发布的 64 位指令集扩展技术在此以 IA\-32e 为例介绍 64 位架构下的内存管理机制.

IA\-32e 模式有如下两个子模式.

- **兼容模式**. 此模式下**只用了 32 位的线性地址**将地址的**32~47 位全部视为 0**.
- **64 位模式**. 这种模式产生**64 位的线性地址**处理器需要保证地址的 47~63 位完全相同. 实际上**只使用了 48 位**的地址.

## 4.1. IA-32e 的分段机制

分段机制的表现与处理器的工作模式有关.

- 在**兼容模式**下分段机制的作用过程与前面介绍的**传统的分段机制完全相同**.
- 在**64 位模式**下分段机制的分段功能**基本上被禁用**同时提供 64 位的通用线性地址空间. 处理器将**CS、DS、ES、SS**中的**段基址视为 0**而**FS、GS**中存储的**段基址**可在线性地址的**计算过程中使用**. **FS、GS**方便了**本地数据的寻址**及操作系统数据结构的确定. 这里还有一点需要引起注意在**64 位模式**下处理器**不会执行段长度检查！！！**.

## 4.2. IA-32e 的分页机制

**64 位寻址模式(长模式**)下**PAE 是必需**的**内存页大小**可以是**4KB**、**2MB**、**1GB**.

与前面介绍的启用 PAE 时的三级标签页表机制不同长模式下系统使用**四级标签页表**——附加了一个第四级页面映射表(Page\-Map Level 4 Table 之后简称为 PML 4 Table). 这种机制将**48 位的线性地址**转换为**52 位的物理地址**. 下面以 4KB 页面为例对这种机制进行介绍四级页表的结构如图 1\-11 所示.

- **第四级页面映射表(PML4**): 包含页目录指针表的物理基地址、访问权限和内存管理信息. PML4 的**物理基地址**存在**CR3**中.
- **页目录指针**: 包含一个页目录表的**物理基地址**、**访问权限**和**内存管理信息**.
- **页目录项**: 包含一个页表的物理基地址、访问权限和内存管理信息.
- **页表项**: 包含一个页面的物理地址、访问权限和内存管理信息.

图 1\-11 四级页表结构:

![](./images/2019-07-01-16-33-10.png)