1. 概念

物理地址(physical address)
用于内存芯片级的单元寻址. 它们与从微处理器的地址引脚发送到内存总线上的电信号相对应. 虽然可以直接把物理地址理解成插在机器上那根内存本身把内存看成一个从 0 字节一直到最大空量逐字节的编号的大数组然后把这个数组叫做物理地址但是事实上这只是一个硬件提供给软件的抽像内存的寻址方式并不是这样. 所以说它是"与地址总线相对应"是更贴切一些.

虚拟内存(virtual memory)
这是对整个内存(不要与机器上插那条对上号)的抽像描述. 它是相对于物理内存来讲的可以直接理解成"不真实的""假的"内存例如一个 0x08000000 内存地址它并不对就物理地址上那个大数组中 0x08000000 - 1 那个地址元素; 之所以是这样是因为现代操作系统都提供了一种内存管理的抽像即虚拟内存(virtual memory). 进程使用虚拟内存中的地址由操作系统协助相关硬件把它"转换"成真正的物理地址. 这个"转换"是所有问题讨论的关键.
有了这样的抽像一个程序就可以使用比真实物理地址大得多的地址空间. 甚至多个进程可以使用相同的地址. 不奇怪因为转换后的物理地址并非相同的.
可以把连接后的程序反编译看一下发现连接器已经为程序分配了一个地址例如要调用某个函数 A 代码不是 call A 而是 call 0x0811111111 也就是说函数 A 的地址已经被定下来了. 没有这样的"转换"没有虚拟地址的概念这样做是根本行不通的.

逻辑地址(logical address)
Intel 为了兼容将远古时代的段式内存管理方式保留了下来. 逻辑地址指的是机器语言指令中用来指定一个操作数或者是一条指令的地址. 以上例我们说的连接器为 A 分配的 0x08111111 这个地址就是逻辑地址.
这样说好像又违背了 Intel 中段式管理中对逻辑地址要求"一个逻辑地址是由一个段标识符加上一个指定段内相对地址的偏移量表示为 [段标识符: 段内偏移量]也就是说上例中那个 0x08111111 应该表示为[A 的代码段标识符: 0x08111111]"

线性地址(linear address)或也叫虚拟地址(virtual address)
跟逻辑地址类似它也是一个不真实的地址如果逻辑地址是对应的硬件平台段式管理转换前地址的话那么线性地址则对应了硬件页式内存的转换前地址.

CPU 将一个虚拟内存空间中的地址转换成物理地址需要进行两步: 首先将一个逻辑地址(其实是段内偏移量一定要理解)CPU 要利用其段式内存管理单元先将逻辑地址转换成一个线性地址再利用其页式内存管理单元转换成最终物理地址.

这样做两次转换的确是非常麻烦而且没有必要的因为直接可以把线性地址抽像给进程. 之所以这样冗余 Intel 完全是为了兼容而已.

2. CPU 段式内存管理逻辑地址如何转换成线性地址

我们写个最简单的 hello world 程序用 gcc 编译再反汇编后会看到以下指令:

mov    0x80495b0, %eax

这里的内存地址 0x80495b0 就是一个逻辑地址(偏移量)必须加上**隐含的 DS 数据段的基地址**才能构成线性地址. 也就是说 0x80495b0 是当前任务的 DS 数据段内的偏移.

一个逻辑地址由两部分组成段标识符: 段内偏移量. **段标识符**是由一个 16 位长的字段组成称为**段选择符(Segment Selector)**. 其中前 13 位是一个索引号. 后面 3 位包含一些硬件细节. 如图:

![段标识符](images/segment_identifier.png)

索引号是"段描述符(segment desciptor)"的索引**段描述符**具体描述了一个段(包含段基线性地址、长度、权限等)段的信息(段描述符)无法直接存放在段寄存器中(段寄存器只有 2 字节). 很多段描述符组成"段描述符表". 这样可以通过段标识符的前 13 位直接在段描述符表中找到一个具体的段描述符这个描述符就描述了一个段.

每一个段描述符(段的信息)由 8 个字节组成如下:

![段描述符](images/segment_descriptor.png)

![段描述符](images/segment_descriptor.jpg)

这个很复杂可以使用一个数据结构来定义. 在这里只关心 Base 字段它描述了一个段的开始位置的线性地址.

Intel 设计的本意是一些全局的段描述符就放在"全局段描述符表(GDT)"中一些局部的例如每个进程自己的就放在所谓的"局部段描述符表(LDT)"中. 那究竟什么时候该用 GDT 什么时候该用 LDT 呢?这是由段选择符中的 T1 字段表示的=0 表示用 GDT=1 表示用 LDT.

GDT 在内存中的地址和大小存放在 CPU 的 gdtr 控制寄存器中而 LDT 则在 ldtr 寄存器中. 段寄存器中存放的是段描述符在 GDT 或 LDT 内的索引值(index).


GDT(全局描述符表)、IDT(中断描述符表)、LDT(局部描述符表)都是在内存中. GDT 和 IDT 分别只有一个 LDT 分别对应进程可能会有多个. 寄存器 GDTR 和 IDTR 指向 GDT 和 IDTLDTR 则指向当前进程的 LDT.

![各概念的关系](images/relations.png)

首先给定一个完整的逻辑地址[段选择符:段内偏移地址]

1. 看段选择符的 T1=0 还是 1 知道当前要转换是 GDT 中的段还是 LDT 中的段再根据相应寄存器得到其地址和大小. 我们就有了一个数组了.
2. 拿出段选择符中前 13 位可以在这个数组中查找到对应的段描述符这样它的 Base 即基地址就知道了.
3. 把 Base + offset 就是要转换的线性地址了.

还是挺简单的对于软件来讲原则上就需要把硬件转换所需的信息准备好就可以让硬件来完成这个转换了. OK 来看看 Linux 怎么做的.

3. Linux 的段式管理

Intel 要求两次转换这样虽说是兼容了但是却是很冗余呵呵没办法硬件要求这样做了软件就只能照办怎么着也得形式主义一样.

另一方面其它某些硬件平台没有二次转换的概念 Linux 也需要提供一个高层抽像来提供一个统一的界面. 所以 Linux 的段式管理事实上只是"哄骗"了一下硬件而已.

按照 Intel 的本意全局的用 GDT 每个进程自己的用 LDT——不过 Linux 则对所有的进程都使用了相同的段来对指令和数据寻址. 即用户数据段用户代码段对应的内核中的是内核数据段和内核代码段. 这样做没有什么奇怪的本来就是走形式嘛像我们写年终总结一样.

```
__USER_CS: 用户代码段
__USER_DS: 用户数据段
__KERNEL_CS: 内核代码段
__KERNEL_DS: 内核数据段
```

include/asm-i386/segment.h

```cpp
#define GDT_ENTRY_DEFAULT_USER_CS        14
#define __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)
#define GDT_ENTRY_DEFAULT_USER_DS        15
#define __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)
#define GDT_ENTRY_KERNEL_BASE        12
#define GDT_ENTRY_KERNEL_CS                (GDT_ENTRY_KERNEL_BASE + 0)
#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)
#define GDT_ENTRY_KERNEL_DS                (GDT_ENTRY_KERNEL_BASE + 1)
#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)
```

把其中的宏替换成数值则为:

```
#define __USER_CS 115        [00000000 1110  0  11]
#define __USER_DS 123        [00000000 1111  0  11]
#define __KERNEL_CS 96      [00000000 1100  0  00]
#define __KERNEL_DS 104    [00000000 1101  0  00]
```

方括号后是这四个段选择符的 16 位二制表示它们的索引号和 T1 字段值也可以算出来了

```
__USER_CS             index= 14   T1=0
__USER_DS             index= 15   T1=0
__KERNEL_CS           index= 12   T1=0
__KERNEL_DS           index= 13   T1=0
```

T1 均为 0 则表示都使用了 GDT 再来看初始化 GDT 的内容中相应的 12-15 项(arch/i386/head.S):

```
.quad 0x00cf9a000000ffff        /* 0x60 kernel 4GB code at 0x00000000 */
.quad 0x00cf92000000ffff        /* 0x68 kernel 4GB data at 0x00000000 */
.quad 0x00cffa000000ffff        /* 0x73 user 4GB code at 0x00000000 */
.quad 0x00cff2000000ffff        /* 0x7b user 4GB data at 0x00000000 */
```

按照前面段描述符表中的描述可以把它们展开发现其 16-31 位全为 0 即四个段的基地址全为 0.

这样给定一个段内偏移地址按照前面转换公式 0 + 段内偏移转换为线性地址可以得出重要的结论"在 Linux 下逻辑地址与线性地址总是一致(是一致不是有些人说的相同)的即逻辑地址的偏移量字段的值与线性地址的值总是相同的. ！！！"

内核任务使用__KERNEL_CS 和__KERNEL_DS. 所有的用户任务共用__USER_CS 和__USER_DS 也就是说不需要给每个任务再单独分配段描述符. 内核段描述符和用户段描述符虽然起始线性地址和长度都一样但是 DPL(描述符特权级)不一样__KERNEL_CS 和__KERNEL_DS 的 DPL 值为 0(最高特权)__USER_CS 和__USER_DS 的 DPL 值为 3.

忽略了太多的细节例如段的权限检查.

用 gdb 调试程序的时候用 info reg 显示当前寄存器的值:

```
cs             0x73     115

ss             0x7b     123

ds             0x7b     123

es             0x7b     123
```

ds 的值为 0x7b 转换成二进制为 00000000 01111011TI 字段是 0 表明使用 GDTGDT 的索引值是 0111 即十进制 15 对应的就是 GDT 内__USER_DS 用户数据段描述符.

![逻辑地址转线性地址](images/logic_address_to_linear.gif)

Linux 中绝大部份进程并不利用 LDT 除非使用 Wine 仿真 Windows 程序的时候.

4. CPU 的页式内存管理

在保护模式下控制寄存器 CR0 的最高位 PG 位控制着分页管理机制是否生效如果 PG=1 分页机制生效需通过页表查找才能把线性地址转换物理地址. 如果 PG=0 则分页机制无效线性地址就直接做为物理地址.

CPU 的页式内存管理单元负责把一个线性地址最终翻译为一个物理地址. 从管理和效率的角度出发线性地址被分为以**固定长度**为单位的组称为**页(page)**例如一个 32 位的机器线性地址最大可为 4G 可以用 4KB(2^12)为一个页来划分(先不考虑扩展分页的情况)这样每页的起始地址都是 4K 字节对齐而整个线性地址就被划分为一个 tatol_page[2\^20]的大数组共有 2 的 20 次方个页. 这个大数组我们称之为**页目录**. 目录中的每一个目录项就是一个地址——对应的页的地址.

另一类"页"我们称之为物理页或者是页框、页桢的. 是分页单元把所有的物理内存也划分为固定长度的管理单位它的长度一般与内存页是一一对应的.

这里注意到这个 total_page 数组有 2\^20 个成员每个成员是一个地址(32 位机一个地址也就是**4 字节**)那么要单单要表示这么一个数组就要占去 4MB(4MB = 2\^20 * 2\^2 字节)的内存空间. 为了节省空间引入了一个二级管理模式的机器来组织分页单元. 文字描述太累看图直观一些:

![分页单元](images/paging.png)

如上图:

1. 分页单元中页目录是唯一的它的地址放在 CPU 的 CR3 寄存器中是进行地址转换的开始点.

2. 每个活动的进程因为都有其独立的对应的虚拟内存(页目录也是唯一的)那么它也对应一个独立的页目录地址. ————运行一个进程需要将它的页目录地址放在 CR3 寄存器中将别个的保存下来.

3. 每一个 32 位的线性地址被划分为三部分页目录索引(10 位): 页表索引(10 位): 物理页内的字节偏移(12 位)

我们需要给 CPU 提供**当前任务**的线性地址转物理地址的查找表即页表(page table). 注意为了实现每个任务的平摊的虚拟内存每个任务都有自己的页目录表和页表.

页目录表的大小为 4k(刚好是一个页的大小)包含 1024 项(2\^10)每个项 4 字节(32 位)项目里存储的内容就是**页表的物理地址**. 如果页目录表中的页表尚未分配则物理地址填 0.

页表的大小也是 4k 同样包含 1024(2^10)项每个项 4 字节内容为最终物理页的物理内存起始地址.

每个活动的任务必须要先分配给它一个页目录表并把页目录表的物理地址存入 cr3 寄存器. 页表可以提前分配好也可以在用到的时候再分配.

依据以下步骤进行转换:

1、从 cr3 中取出进程的页目录地址(操作系统负责在调度进程的时候把这个地址装入对应寄存器);

2、根据线性地址前十位在数组中找到对应的索引项因为引入了二级管理模式页目录中的项不再是页的地址而是一个页表的地址. (又引入了一个数组)页的地址被放到页表中去了.

3、根据线性地址的中间十位在页表(也是数组)中找到页的起始地址;

4、将页的起始地址与线性地址中最后 12 位相加得到最终我们想要的物理地址.

以 mov 0x80495b0, %eax 中的地址为例分析一下线性地址转物理地址的过程.

前面说到 Linux 中逻辑地址等于线性地址那么我们要转换的线性地址就是 0x80495b0. 转换的过程是由 CPU 自动完成的 Linux 所要做的就是准备好转换所需的页目录表和页表(假设已经准备好给页目录表和页表分配物理内存的过程很复杂后面再分析).

- 内核先将当前任务的页目录表的物理地址填入 cr3 寄存器.

- 线性地址 0x80495b0 转换成二进制后是 0000 1000 0000 0100 1001 0101 1011 0000 最高 10 位 0000 1000 00 的十进制是 32CPU 查看页目录表第 32 项里面存放的是页表的物理地址. 线性地址中间 10 位 00 0100 1001 的十进制是 73 页表的第 73 项存储的是最终物理页的物理起始地址. 物理页基地址加上线性地址中最低 12 位的偏移量 CPU 就找到了线性地址最终对应的物理内存单元.

![线性地址转物理地址](images/Linear_to_physical.gif)

我们知道 Linux 中用户进程线性地址能寻址的范围是 0 － 3G 那么是不是需要提前先把这 3G 虚拟内存的页表都建立好呢?一般情况下物理内存是远远小于 3G 的加上同时有很多进程都在运行根本无法给每个进程提前建立 3G 的线性地址页表. Linux 利用 CPU 的一个机制解决了这个问题. 进程创建后我们可以给页目录表的表项值都填 0CPU 在查找页表时如果表项的内容为 0,则会引发一个缺页异常进程暂停执行 Linux 内核这时候可以通过一系列复杂的算法给分配一个物理页并把物理页的地址填入表项中进程再恢复执行. 当然进程在这个过程中是被蒙蔽的它自己的感觉还是正常访问到了物理内存.

这个转换过程应该说还是非常简单地. 全部由硬件完成虽然多了一道手续但是节约了大量的内存还是值得的. 那么再简单地验证一下:

1、这样的二级模式是否仍能够表示 4G 的地址;

页目录共有: 2^10 项也就是说有这么多个页表
每个目表对应了: 2^10 页;
每个页中可寻址: 2^12 个字节.
还是 2^32 = 4GB

2、按<深入理解计算机系统>中的解释,二级模式空间的节约是从两个方面实现的:

A、如果一级页表中的一个页表条目为空那么那所指的二级页表就根本不会存在. 这表现出一种巨大的潜在节约因为对于一个典型的程序 4GB 虚拟地址空间的大部份都会是未分配的;

B、只有一级页表才需要总是在主存中. 虚拟存储器系统可以在需要时创建并页面调入或调出二级页表这就减少了主存的压力. 只有最经常使用的二级页表才需要缓存在主存中. ——不过 Linux 并没有完全享受这种福利它的页表目录和与已分配页面相关的页表都是常驻内存的.

值得一提的是虽然页目录和页表中的项都是 4 个字节 32 位但是它们都只用高 20 位低 12 位屏蔽为 0——把页表的低 12 屏蔽为 0 是很好理解的因为这样它刚好和一个页面大小对应起来大家都成整数增加. 计算起来就方便多了. 但是为什么同时也要把页目录低 12 位屏蔽掉呢?因为按同样的道理只要屏蔽其低 10 位就可以了不过我想因为 12>10 这样可以让页目录和页表使用相同的数据结构方便.

这个只是一般性转换的原理扩展分页、页的保护机制、PAE 模式的分页这些麻烦点的东西可以参考其它专业书籍.

5. Linux 的页式内存管理

原理上来讲 Linux 只需要为每个进程分配好所需数据结构放到内存中然后在调度进程的时候切换寄存器 cr3 剩下的就交给硬件来完成了(呵呵事实上要复杂得多不过我们只分析最基本的流程).

前面说了 i386 的二级页管理架构不过有些 CPU 还有三级甚至四级架构 Linux 为了在更高层次提供抽像为每个 CPU 提供统一的界面. 提供了一个四层页管理架构来兼容这些二级、三级、四级管理架构的 CPU. 这四级分别为:

- 页全局目录 PGD(对应刚才的页目录)
- 页上级目录 PUD(新引进的)
- 页中间目录 PMD(也就新引进的)
- 页表 PT(对应刚才的页表)

整个转换依据硬件转换原理只是多了二次数组的索引罢了如下图:

![Linux 地址转换](images/Linux_address_transfer.png)

那么对于使用二级管理架构的 32 位硬件现在又是四级转换它们怎么协调的呢?

从硬件的角度 32 位地址被分为了三部分. 也就是说不管软件怎么做最终落实到硬件也只认识三部分.

从软件的角度由于多引入了两部分也就是说共有五部分. 要让二层架构的硬件认识五部分也容易在地址划分的时候将页上级目录和页中间目录的长度设置为 0 即可.

这样操作系统见到的是五部分硬件还是按照三部分划分也不会出错.

这样虽说多此一举但是考虑到 64 位地址使用四层转换架构的 CPU 我们就不再把中间两个设为 0 了.

例如一个逻辑地址已经被转换成线性地址 0x08147258 换成二进制也就是:

0000 1000 0001 0100 0111 0010 0101 1000

0000100000 0101000111 001001011000

内核对这个地址进行划分

- PGD = 0000100000
- PUD = 0
- PMD = 0
- PT = 0101000111
- offset = 001001011000

现在理解 Linux 怎么向下对硬件的因为硬件根本不感知 PUD 和 PMD 所以本质上要求 PGD 索引直接就对应了 PT 的地址. 而不是去 PUD 和 PMD 中去查数组(虽然他们两个在线性地址中长度为 02^0=1 也就是说他们都是有一个数组元素的数组)那么内核会如何安排地址呢?

从软件上来讲因为它的项只有一个 32 位刚好可以存放与 PGD 长度一样的地址指针. 那么所谓先到 PUD 到 PMD 中做映射转换就变成了保持原值不变转手就可以了. 这样就实现了"逻辑上指向一个 PUD 再指向一个 PDM 但在物理上是直接指向相应的 PT 的这个抽象因为硬件不感知 PUD、PMD".

然后交给硬件硬件对这个地址进行划分看到的是:

- 页目录 = 0000100000
- PT = 0101000111
- offset = 001001011000

先根据 0000100000(32)在页目录数组中索引找到其元素中的地址取其高 20 位找到页表的地址页表的地址是由内核动态分配的接着再加上 offset 就是最终的物理地址了.

地址转换总览:

![地址转换](images/translate_address.jpg)