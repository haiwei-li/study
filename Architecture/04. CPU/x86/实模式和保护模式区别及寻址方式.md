
```
转载请注明出处: http://blog.csdn.net/rosetta
```

# 1 64KB－4GB－64TB?

为什么实模式下最大寻址空间为 1MB?

段的最大长度不超过 64KB?

而保护模式下为啥最大寻址能力就变成了 64TB?每个段最大也达 4GB?

分段和分页?

**寻址能力都达 64TB**了为啥我的电脑内存只有 2GB 呢?这 64TB 就是所谓的**虚拟地址空间**也叫**逻辑地址空间**它能够寻址这么多只是它有这个能力并不代表你的内存就要装这么大你内存比它小再多也不会影响你工作反过来要是它的寻址能力只有 1MB 而你有 2GB 的内存那么那 1.999GB 就没有实际用处了这就太浪费资源了.

而实际上这个 64TB 也没有什么实际意义因为**32 位的地址总线**能寻址的**线性地址空间和物理地址空间**都是 2\^32(其实指的是 2\^32 个地址)=4GB(根据单位为字节算出来的). 这个 64TB 是怎么出来的稍后揭晓.

# 2 实模式与保护模式的来历

最早期的 8086 CPU 只有一种工作方式那就是**实模式**而且**数据总线为 16 位****地址总线为 20 位**实模式下**所有寄存器都是 16 位**.

而从 80286 开始就有了保护模式从 80386 开始 CPU**数据总线和地址总线均为 32 位**而且**寄存器都是 32 位**.

但 80386 以及现在的奔腾、酷睿等等 CPU 为了向前兼容都保留了实模式现代操作系统在刚加电时首先运行在实模式下然后再切换到保护模式下运行.

# 3 三种地址

**逻辑地址**: 即逻辑上的地址**实模式**下由"段基地址+段内偏移"组成; **保护模式**下由"段选择符+段内偏移"组成.

**线性地址**: 逻辑地址经分段机制后就成线性地址它是平坦的; 如果不启用分页那么此线性地址即物理地址.

**物理地址**: 线性地址经分页转换后就成了物理地址.

# 4 实模式寻址方式

刚才说了 8086 CPU**数据总线**为 16 位也就是一次最多能取**2\^16(数值范围是 0x0000 ~ 0xFFFF)＝64KB 数据**这个数据也解释了实模式下为什么**每个段最大只有 64KB**. 但刚才还说了其地址总线为 20 位这样它能寻址的能力其实是 2^20=1MB 这也就是实模式下 CPU 的最大寻址能力. 既然它有 1MB 寻址能力那怎么用 16 位的段寄存器表示呢?

这就引出了分段的概念 8086 CPU 将 1MB 存储空间分成许多逻辑段每个段最大限长为 64KB(但不一定就是 64KB). 这样每个存储单元就可以用"段基地址+段内偏移地址"表示. 段基地址由**16 位段寄存器值**左移 4 位表达段内偏移表示相对于某个段起始位置的偏移量.

比如:

```
SEG=0x07c0
jmpi offset, #SEG
offset: mov ax,cs
```

# 5 保护模式寻址方式

在定义"逻辑地址"时看到保护模式和实模式的区别在于它是**用段选择符而非段基地址**这也许就是保护模式的真谛所在从段选择符入手全面理解保护模式编程基本概念和寻址方式.

## 5.1 分段机制

下面来看下保护模式是怎样通过"段选择符+段内偏移"寻址最终的线性地址或物理地址的.

图 1 逻辑地址到线性地址转换这里的逻辑地址即指保护模式下的"段选择符+段内偏移地址"如果不启用分页管理的情况下那么此线性地址即最终的物理地址.

![图 1](images/logical_linear.png)

在理解此图时必须要明白段选择符结构、描述符表概念等下面就一一介绍.
如图 2 段选择符结构段选择符为 16 位它不直接指向段而是通过指向的段描述符段描述符(一会介绍)再定义段的信息.

![图 2](images/segment_selector_str.png)

其中 TI 用来指明全局描述符表 GDT 还是局部描述符表 LDTRPL 表示请求特权级索引值为 13 位所以从这里看出在保护模式下最多可以表示 2^13=8192 个段描述符而 TI 又分 GDT 和 LDT(如图 3 所示)所以一共可以表示 8192\*2=16384 个段描述符每个段描述符可以指定一个具体的段信息所以一共可以表示 16384 个段. 而图 1 看出段内偏移地址为 32 位值所以一个段最大可达 4GB 这样 16384\*4GB＝64TB 这就是所谓的 64TB 最大寻址能力也即逻辑地址/虚拟地址.

在保护模式实际编程中如下一条语句: jmpi 0, 8. 其中的 8 即段选择符 8 的二进制表示为: 0000 0000 0000 1000b 所以这条语句的意思是跳转到 GDT 表(TI＝0)中的第 2 个(段描述符表从０开始编号所以这里的 1 指表中的第 2 个)段描述符定义的段中其段内偏移为 0.

![图 3](images/images3.png)

下面再来看段描述符结构段描述符表中的每一项为一个段描述符每一项为 8 字节其结构如图 4 所示.

![图 4](images/images4.png)

从图中可知段选择符指向的段描述符里有三个部分基地址信息这三部分组成一个 32 位地址就决定了段基地址位置此地址再加上段内偏移最终确定线性地址位置.

段描述符中的 S 位和 TYPE 字段(四位)的不同又分为数据段描述符、代码段描述符(S=1)和系统段描述符(S=0). 数据段和代码段描述符类型如图 5 所示.

![图 5](images/images5.png)

系统段描述符如图 6 所示.

![6](images/images6.png)

## 5.2 分页机制

到目前为止我们知道了保护模式下是怎样通过段选择符指向一个段描述符最终由段描述符+段内偏移定位线性地址在不启用分页情况下此线性地址就是物理地址那么在启用分页情况下又是怎样实现内存的映射转换的呢?这就是伟大的分页机制.

分页机制如下图所示它把**物理内存**分成相同固定大小的页面 2\^12=4KB. 每个**页面**的 0~4KB 范围由**线性地址**的低 12 位表示线性地址空间的**高 10**位用来指定**页目录**中的位置可以选择 2\^10=1024 个目录项每个目录项为**四字节**所以页目录为 1024\*4B=4KB. 每个目录项中的高 20 位用以查找页表在物理内存中的页面每个页表含 1024 个页表项每个页表项也是四字节这样一页表也是 1024\*4B=4KB. 所以一个页目录可以查找 1024 个页表每个页表为 4KB 所以总共可以查找的页表大小为 1024\*4KB＝4MB 大. 最后每个页表项的高 20 位用以定位物理地址空间中的某个页基地址此地址再加上线性地址空间的偏移值就是最后物理内存空间单元. 目录项和页表项结构如图 8 所示.

![7](images/images7.png)

![8](images/images8.png)

从一个逻辑地址经过分段和分页寻址物理地址的整个过程就如图 9 所示. 总的来说整个过就是逻辑地址经分段机制变成线性地址如果不启用分页的情况下此线性地址就是物理地址; 如果启用分页那么线性地址经分页机制变成物理地址.

![9](images/images9.png)

## 5.3 分段和分页的意义

说了半天分段和分页的原理它们到底有何用?这里以保护模式下分段和分页讲解.

![10](images/images10.png)

如图 10 所示. 一个多段模型充分发挥了段机制的对代码、数据结构和程序提供硬件保护的能力. 每个程序都有自己的段描述符表和自己的段. 段可以完全属于程序私有也可以和其它程序之间共享.
访问权限的检查不仅仅用来保护地址越界也可以保护某一特定段不允许操作. 例如代码段是只读段硬件可以阻击向代码段进行写操作.
分页为需求页、虚拟内存提供实现机制. 具体的实现机制可以再深入学习.

# 6 文献资料

- 《深入理解 Linux 内核》
- 《Linux 内核完全剖析》赵炯
- 《Linux 内核设计与实现》
- 《Linux 内核修炼之道》
- 《新版汇编语言程序设计》钱晓捷著
- 《windows 环境下 32 位汇编语言程序设计》罗云彬著