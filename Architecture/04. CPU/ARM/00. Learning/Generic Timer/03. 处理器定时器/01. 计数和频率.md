
`CNTPCT_EL0` 系统寄存器报告了**当前的系统计数值**.

读 CNTPCT_EL0 可以是推测性的. 这意味着它们可以在程序流程中乱序读取.

在某些情况下, 这可能很重要, 例如比较时间戳. 当计数器读取的顺序很重要时, 可以使用 ISB, 如下代码所示:

```
loop:           // 在某些通信进行 polling 以表明需要读取定时器
  LDR X1, [X2]  // 加载 X2 值的内存地址中的值到 X1
  CBZ x1, loop  // 判断 X1 是否为零, 0 则跳回 loop
  ISB           // 如果没有这一步, CNTPCT 可能在 [X2] 所指向的内存位置尚未写入值 0 之前就被读取
  MRS X1, CNTPCT_EL0 // 读取 CNTPCT_EL0 到 X1
```

> 注意: Armv8.6-A 和 Armv9.1-A 增加了 CNTPCT_EL0 寄存器的自同步版本, 这被称为 CNTPCTSS_EL0.

`CNTFRQ_EL0` 报告**系统计数的频率**. 然而, 这个寄存器并不是由硬件填充的. 该寄存器可以在**最高实现的异常级别**进行**写入**, 并且在**所有异常级别**都可以**读取**. **固件**通常在 EL3 级别运行, 作为早期系统初始化的一部分来**填充**这个寄存器. 然后, 像**操作系统**可以使用该寄存器来**获取频率**.
