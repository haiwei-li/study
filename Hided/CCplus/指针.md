
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 复杂类型说明](#1-复杂类型说明)
  - [1.1. int p](#11-int-p)
  - [1.2. int *p](#12-int-p)
  - [1.3. int p[3]](#13-int-p3)
  - [1.4. int *p[3]](#14-int-p3)
  - [1.5. int (*p)[3]](#15-int-p3)
  - [1.6. int **p](#16-int-p)
  - [1.7. int p(int)](#17-int-pint)
  - [1.8. int (*p)(int)](#18-int-pint)
  - [1.9. int *(*p(int))[3]](#19-int-pint3)
- [2. 细说指针](#2-细说指针)
  - [2.1. 指针的类型](#21-指针的类型)
  - [2.2. 指针所指向的类型](#22-指针所指向的类型)
  - [2.3. 指针的值 --- 或叫指针所指向的内存区或地址](#23-指针的值---或叫指针所指向的内存区或地址)
  - [2.4. 指针本身所占据的内存区](#24-指针本身所占据的内存区)
- [3. 指针的算术运算](#3-指针的算术运算)
- [4. 运算符&和*](#4-运算符和)
- [5. 指针表达式](#5-指针表达式)
- [6. 数组和指针的关系](#6-数组和指针的关系)
- [7. 指针和结构类型的关系](#7-指针和结构类型的关系)
- [8. 指针和函数的关系](#8-指针和函数的关系)
- [9. 指针类型转换](#9-指针类型转换)
- [10. 指针的安全问题](#10-指针的安全问题)
- [11. 指针和 const](#11-指针和-const)
  - [11.1. const 理解](#111-const-理解)
    - [11.1.1. 变量](#1111-变量)
    - [11.1.2. 函数](#1112-函数)
  - [11.2. 指向 const 的指针](#112-指向-const-的指针)
  - [11.3. const 指针](#113-const-指针)
  - [11.4. 指针和内容都不可变](#114-指针和内容都不可变)
  - [11.5. 理解记忆](#115-理解记忆)
- [12. 参考](#12-参考)

<!-- /code_chunk_output -->

# 1. 复杂类型说明

要了解指针,多多少少会出现一些比较复杂的类型, 所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单, **一个类型**里会出现**很多运算符**, 他们也像**普通的表达式**一样, 有**优先级**, 其优先级和**运算优先级**一样, 所以我总结了一下其原则:

>从**变量名**处起,根据**运算符优先级结合**,一步一步分析

注: 指针是一个**带有大小范围的地址**

下面让我们先从简单的类型开始慢慢分析吧:

## 1.1. int p

```c
int p;
```

这是一个普通的整型变量

## 1.2. int *p

```c
int *p;
```

**首先从 P 处开始**, 先**与\*结合**, 所以说明 P 是**一个指针**, 然后再**与 int 结合**, 说明**指针所指向的内容**的**类型为 int 型**.

所以 P 是**一个返回整型数据的指针**

## 1.3. int p[3]

```c
int p[3];
```

首先从 P 处开始, **先与[]结合**,说明 **P 是一个数组**, 然后**与 int 结合**, 说明**数组里的元素是整型的**.

所以 P 是一个**由整型数据组成的数组**

## 1.4. int *p[3]

```c
int *p[3];
```

首先从 P 处开始, **先**与 `[]` 结合, 因为其**优先级**比 `*` **高**, 所以 **P 是一个数组**, 然后**再**与 `*` 结合, 说明**数组里的元素是指针类型**, 然后**再与 int 结合**, 说明**指针所指向的内容的类型是整型**的.

所以 P 是一个由**返回整型数据的指针**所**组成的数组**

## 1.5. int (*p)[3]

```
int (*p)[3];
```

首先从 P 处开始, **先与\*结合**, 说明 P 是**一个指针**, 然后**再与[]结合**(与"()"这步可以忽略, 只是为了改变优先级), 说明**指针所指向的内容是一个数组**, 然后**再与 int 结合**, 说明**数组里的元素是整型**的.

所以 P 是一个指向由**整型数据组成的数组**的**指针**

## 1.6. int **p

```c
int **p;
```

首先从 P 开始, **先与\*结合**, 说是 P 是**一个指针**, 然后**再与\*结合**, 说明**指针所指向的元素是指针**, 然后**再与 int 结合**, 说明**该指针所指向的元素是整型数据**. 由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针.

## 1.7. int p(int)

```c
int p(int);
```

从 P 处起, **先与()结合**, 说明 P 是**一个函数**,然后进入()里分析, 说明该函数**有一个整型变量的参数**, 然后再与外面的 int 结合, 说明**函数的返回值**是一个**整型数据**

## 1.8. int (*p)(int)

```c
int (*p)(int);
```

从 P 处开始, **先与指针结合**, 说明 P 是**一个指针**, 然后**与()结合**, 说明**指针指向的是一个函数**, 然后再与()里的int 结合, 说明函数有一个 int 型的参数, 再与最外层的int 结合, 说明函数的返回类型是整型, 所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针

## 1.9. int *(*p(int))[3]

```c
int *(*p(int))[3];
```

从 P 开始, **先与()结合**, 说明 **P 是一个函数**, 然后进入()里面, 与 int 结合, 说明**函数有一个整型变量参数**, 然后再与外面的\*结合, 说明函数**返回的是一个指针**, 然后到最外面一层, 先与[]结合, 说明**返回的指针指向的是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针**, 然后再与 int 结合, 说明**指针指向的内容是整型数据**.

所以 P 是一个**参数为一个整数据**且返回一个指向由整型指针变量组成的数组的指针变量的函数.

# 2. 细说指针

指针是一个**特殊的变量**, 它里面**存储的数值**被解释成为**内存里的一个地址**.

要搞清一个指针需要搞清指针的**四方面的内容**:

* **指针的类型**、
* 指针**所指向的类型**、
* 指针的**值**或者叫指针**所指向的内存区**、
* 指针**本身所占据的内存区**.

让我们分别说明.

先声明几个指针放着做例子:

(1) `int *ptr`;

(2) `char *ptr`;

(3) `int **ptr`;

(4) `int (*ptr)[3]`;

(5) `int *(*ptr)[4]`;

## 2.1. 指针的类型

从语法的角度看, 你只要把**指针声明语句**里的**指针名字去掉**, 剩下的部分就是这个**指针的类型**. 这是指针本身所具有的类型. 让我们看看例一中各个指针的类型:

(1) `int *ptr`; //指针的类型是 `int*`

(2) `char *ptr`; //指针的类型是 `char*`

(3) `int **ptr`; //指针的类型是 `int**`

(4) `int (*ptr)[3]`; //指针的类型是 `int(*)[3]`

(5) `int *(*ptr)[4]`; //指针的类型是 `int*(*)[4]`

## 2.2. 指针所指向的类型

当你通过指针来访问**指针所指向的内存区**时, **指针所指向的类型**决定了**编译器**将把**那片内存区里的内容**当做什么来看待.

从语法上看, 你只须把**指针声明语句**中的**指针名字**和**名字左边的指针声明符\*去掉**, 剩下的就是指针所指向的类型. 例如:

(1) `int *ptr`; //指针所指向的类型是 `int`

(2) `char *ptr`; //指针所指向的的类型是 `char`

(3) `int **ptr`; //指针所指向的的类型是 `int*`

(4) `int (*ptr)[3]`; //指针所指向的的类型是`int()[3]`

(5) `int *(*ptr)[4]`; //指针所指向的的类型是 `int*()[4]`

在指针的算术运算中, 指针所指向的类型有很大的作用.  指针的类型(即指针本身的类型)和指针所指向的类型是两个概念. 当你对 C 越来越熟悉时, 你会发现, 把与指针搅和在一起的"类型"这个概念分成 "指针的类型"和"指针所指向的类型"两个概念, 是精通指针的关键点之一.  我看了不少书, 发现有些写得差的书中, 就把指针的这两个概念搅在一起了,  所以看起书来前后矛盾, 越看越糊涂.

## 2.3. 指针的值 --- 或叫指针所指向的内存区或地址

**指针的值**是指针**本身存储的数值**, 这个值将被**编译器当作一个地址**, 而不是一个一般的数值.

在 32 位程序里, **所有类型**的**指针的值**都是一个 **32 位整数**, 因为 **32 位程序**里**内存地址**全都是 **32 位长**.  **指针所指向的内存区**就是从**指针的值**所代表的**那个内存地址开始**, 长度为 **sizeof(指针所指向的类型**)的**一片内存区**.

以后, 我们说**一个指针的值**是 **XX**, 就相当于说**该指针指向了以 XX 为首地址**的**一片内存区域**; 我们说**一个指针**指向了**某块内存区域**,  就相当于说该指针的值是**这块内存区域的首地址**.

指针所指向的内存区和指针所指向的类型是两个完全不同的概念. 在例一中, 指针所指向的类型已经有了, 但由于指针还未初始化, 所以它所指向的内存区是不存在的, 或者说是无意义的.

以后, 每遇到一个指针, 都应该问问:这个指针的类型是什么?指针指的类型是什么?该指针指向了哪里?(重点注意)

## 2.4. 指针本身所占据的内存区

**指针本身**占了**多大的内存**? 你只要用函数 **sizeof(指针的类型**) 测一下 就知道了. 在 **32 位平台**里, 指针本身占据了 **4 个字节的长度**.

指针本身占据的内存这个概念在判断一个**指针表达式**(后面会解释)是否是**左值**时很有用.

# 3. 指针的算术运算


# 4. 运算符&和*

这里`&`是**取地址运算符**, `*`是**间接运算符**.

`&a` 的**运算结果**是**一个指针**, **指针的类型**是 **a 的类型加个**`*`, 指针**所指向的类型**是 **a 的类型**, 指针所指向的地址嘛, 那就是 **a 的地址**.

`*p` 的运算结果就五花八门了. 总之 `*p` 的结果是 **p 所指向的东西**,  这个东西有这些特点:它的类型是 **p 指向的类型**, 它所占用的地址是 p 所指向的地址.

例子:

```c
int a=12;
int b;
int *p;
int **ptr;

p=&a;
*p=24;
ptr=&p;
*ptr=&b;
**ptr=34;
```

`p = &a`;      // `&a` 的结果是一个指针, 类型是 `int*`, 指向的类型是int, 指向的地址是 a 的地址.

`*p = 24`;     // `*p` 的结果, 在这里它的类型是 int, 它所占用的地址是p 所指向的地址, 显然, `*p` 就是变量 a

`ptr = &p`;    // `&p` 的结果是个指针, 该指针的类型是 p 的类型加个\*, 在这里是 `int **`. 该指针所指向的类型是 p 的类型, 这里是 `int*`. 该指针所指向的地址就是指针 p 自己的地址.

`*ptr = &b`;  // `*ptr` 是个指针, `&b` 的结果也是个指针, 且这两个指针的类型和所指向的类型是一样的, 所以用 `&b` 来给`*ptr` 赋值就是毫无问题的了.

`**ptr = 34`; // `*ptr` 的结果是 ptr 所指向的东西, 在这里是一个指针, 对这个指针再做一次`*`运算, 结果是一个 int 类型的变量.

# 5. 指针表达式

一个**表达式的结果**如果是**一个指针**, 那么这个表达式就叫指针表式.

下面是一些指针表达式的例子:

```c
int a,b;

int array[10];

int *pa;

pa=&a;          // &a 是一个指针表达式.

int **ptr=&pa;  // &pa 也是一个指针表达式.

*ptr=&b;        // *ptr 和&b 都是指针表达式.

pa=array;

pa++;           //这也是指针表达式.
```






# 6. 数组和指针的关系

# 7. 指针和结构类型的关系

# 8. 指针和函数的关系

# 9. 指针类型转换

# 10. 指针的安全问题

# 11. 指针和 const

## 11.1. const 理解

const 是C语言的一个关键字, 需要注意的是, const 关键字是把变量变为一个只读的变量(也就是不可以作为左值), 绝对不是将这个变量变为常量. 也就是说经过const 修饰的变量成为只读的变量之后, 那么这个变量就只能作为右值(只能赋值给别人), 绝对不能成为左值(不能接收别人的赋值).

而 C++ 则是将 const 修饰的常量变为一个真正的常量(变量的内容不可以被修改),  这一点的区别需要进行注意. 当 const 变量的时候, 就将这个常量放在符号表里面, 编译的过程中发现使用了变量, 那么就从符号表里面的值进行替换.

* const 是由编译器进行处理, 执行类型检查和作用域的检查; 

* define 是由预处理器进行处理, 只做简单的文本替换工作而已.

const 本质上被命名为 readonly 更为合适.

### 11.1.1. 变量

经过const 修饰的变量, 在定义的时候, 就要进行初始化.

```cpp
const int a = 10;  // 正确

const int a;  // 错误
```

### 11.1.2. 函数

const 关键字最有用的地方是用来限定函数的形参

```cpp
func(const char *ptr)
{
    ...
}
```

这样, func 函数将不会修改实参指针所指的数据, 但是其他的函数却可以修改他

## 11.2. 指向 const 的指针

首先, 是一个指针, 但是这个指针是指向一个const 类型的指针.

```cpp
const int *p  // 一般使用这个
// 或者
int const *p
```

第一种: 首先 P 是一个指针, P所指向的内容(`*P`)所指向的内容是 const int 类型的.

第二种, : 首先 P 也是一个指针, 指向的内容是 const int 类型的, 也就是所指向的内容是是绝对不能被修改的.

一句话,  P 这个地址可以随便指, 但是地址里面保存的值却是不能改变.

## 11.3. const 指针

首先是一个指针, 只不过这个指针是 const 类型的, 也就是这个指针变量的地址, 只能在初始化之后, 就一直指向这个地址, 地址所被保存的内容是可变的.

```
int * const p = 地址 // 因为P 所指向的地址是不能被修改的, 所以必须被初始化
```

首先, 这个P 是一个指针, 而这个指针是指向了 int 类型的 const 指针. 只不过地址是被固定, 不能改变, 但是地址所保存的数值确实可变的, 比如: 

```cpp
*p = 3;
```

## 11.4. 指针和内容都不可变

顾名思义, 就是指针的地址和地址所被保存的内容都是不可变的.

```cpp
const int * const p = 地址值
int const * const p = 地址值
```
可见 P 是一个指针, 但是这个指针, 前面有 const 进行修饰, 所以, 这个 P 指针就是一个指针常量, 所以 P 的地址就被固定了, 所以只能进行初始化了.  而对于 `*p` 而言, 前面又有 const 进行修饰, 所以 `*p` 就是一个常量了, 也就是 p 指向地址, 地址上保存的数据是一个常量, 不能被改变的.

## 11.5. 理解记忆

其实就看 const 的位置. const, 在指针的星号之前, 那么就是指向const 的指针, 也就是 *p 的内容是常量, 不能被改变.

const 在星号之后的话, 那么, 就是指向 const 的指针, 也就是这个指针指向的地址, 不能被改变的, 所以, const 指针就必须进行初始化, 然后这个地址就是一直被固定住了, 不能内改变的.

# 12. 参考

网络资源: <让你不再害怕指针>