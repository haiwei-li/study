
对于Rust来说, 无法合理处理的情况就必须引发恐慌. 比如, 使用thread: : spawn无法创建线程只能产生恐慌, 也许是平台内存用尽之类的原因, 在这种情况下 Result＜T, E＞已经无用. 

Rust的恐慌本质上(底层的实现机制)相当于C++异常. C++支持通过throw抛出异常, 也可以使用try/catch来捕获异常, 但是如果使用不当, 就会引起内存不安全的问题, 从而造成Bug或比较严重的安全漏洞. 使用C++写代码, 需要开发人员来保证异常安全(Exception Safety). 

为什么抛出异常有可能产生内存不安全的问题呢?这其实很容易理解. 可以想象一个函数, 如果执行了一半, 突然抛出了异常, 那么会发生什么?函数提前返回, 异常发生点之后的代码也许就永远不会被调用到, 有可能造成资源泄漏和数据结构恶化(比如合法指针变成了悬垂指针). 这就是异常不安全. 

异常安全的代码要求就是不能在异常抛出时造成资源泄漏和数据结构恶化. 现代C++使用RAII 可以解决此问题, 在异常抛出时, 利用栈回退(Stack Unwind)机制来确保在栈内构造的局部变量或指针的析构函数都可以被一一调用. 这样就可以保证异常安全. 而对于Rust语言, 其底层也是基于 RAII 机制来管理资源的, 在恐慌发生之后, 同样会利用栈回退机制触发局部变量的析构函数来保证异常安全. Rust和C++的不同点在于, Rust中的一切都是编译器可以保证的; 而C++要靠开发者自己来保证, 如果开发者没有使用RAII, 那么就有可能导致异常不安全. 

在Rust中, 使用恐慌安全(Panic Safety)来代替异常安全的说法. 虽然在Rust中可以保证基本的恐慌安全, 但还是有很多代码会引发恐慌, 比如对None进行unwrap操作、除以0等, 这些恐慌发生在Safe Rust中是没有问题的, Rust提供了一个叫作UnwindSafe的标记trait, 专门用来标记那些恐慌安全的类型. 但是在Unsafe Rust中就需要小心了, 这里是Rust编译器鞭长莫及的地方. 在第13章中会有关于Unsafe Rust更详细的介绍. 

Rust也提供了catch_unwind方法来让开发者捕获恐慌, 恢复当前线程. Rust团队在引入 catch_unwind 方法时考虑了很多关于内存安全的问题, 所以该方法只针对那些实现了UnwindSafe的类型. 这样做其实是为了避免开发者滥用catch_unwind, Rust并不希望开发者把catch_unwind当作处理错误的惯用方法. 万一将catch_unwind方法用于恐慌不安全的代码, 则会导致内存不安全. 除trait限定之外, 还有一些恐慌是catch_unwind无法捕获的. 比如在一些嵌入式平台中, 恐慌是使用abort(进程中止)来引发的, 并不存在栈回退, 所以也就无法捕获了. 

代码清单9-33: catch_unwind使用示例

```rust

```

