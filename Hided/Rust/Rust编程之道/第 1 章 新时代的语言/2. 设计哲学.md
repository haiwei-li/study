<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 内存安全](#1-内存安全)
- [2. 零成本抽象](#2-零成本抽象)
- [3. 实用性](#3-实用性)

<!-- /code_chunk_output -->

三条设计哲学:

* 内存安全
* 零成本抽象
* 实用性

# 1. 内存安全

现代编程语言: "程序即类型证明". 类型系统的重要性.

简单来讲, 类型安全是指类型系统可以保证程序的行为是意义明确的、不出错的. `C/C++` 语言的类型系统就不是类型安全的, 比如对数组越界不检查.

Rust 借鉴了 Haskell 的类型系统, 因为它的类型系统既有类型论理论"背书", 而且在生产环境中也久经考验.

类型系统的作用是定义编程语言中值和表达式的类型, 将它们归类, 赋予它们不同的行为, 指导它们如何相互作用. 所以, Rust 还需要一个安全内存管理模型, 并通过类型系统表达出来, 才能保证内存安全.

简单说, 内存安全就是不会出现内存访问错误.

只有当程序访问未定义内存时才会产生内存错误. 一般, 下面情况就会产生内存错误:

* **引用空指针**

* 使用**未初始化内存**

* **释放后使用**, 即使用**悬垂指针**(`Dangling Pointer`).

* **缓存区溢出**, 比如数组越界

* **释放已经释放过的指针或未分配的指针**

为了保证内存安全, Rust 建立了严格的安全内存管理模型:

* 所有权系统. 每个被分配的内存都有一个独占其所有权的指针. 仅当指针被销毁, 内存才释放.

* 借用和生命周期. 每个变量都有生命周期, 一旦超出生命周期, 变量就被自动释放. 如果是借用, 通过标记生命周期参数供编译器检查的方式, 防止悬垂指针.

借助类型系统的强大, Rust 在编译阶段对类型进行检查, 看是否满足安全内存模型, 阻止未定义行为.

内存安全的 Bug 和 并发安全的 Bug 产生的内在原因是相同的, 都是因为内存的不正当访问造成的. 利用装载了所有权的强大类型系统, Rust 还解决了并发安全的问题. 编译器静态检查多线程并发代码中所有的数据竞争问题.

# 2. 零成本抽象

Zero cost abstraction. 高效开发和性能.

为了高效开发, 必须有一定抽象能力. 抽象表达能力, 代表性就是 Ruby.

```
# Ruby
5.times{ puts "Hello Ruby"}
2.days.from_now

// Rust
5.times(|| println!("Hello Rust"));
2.days.from_now();
```

对于一门系统级编程语言, 运行时零成本是非常重要的.

Ruby 的抽象表达是靠牺牲性能换来的. Rust 是零成本的.

Rust 的抽象并不会存在运行时性能开销, 都是在编译期完成的. 上面代码 "迭代 5 次" 的抽象代码, 在编译期会被展开成和汇编代码相近的底层代码, 所以不存在运行时因为解释这一层抽象而产生的性能开销.

Rust 中零成本抽象的基石是泛型和trait.

# 3. 实用性

实用性没有统一的说法, 可以从三个方面进行评判:

* 实践性

* 有益性

* 稳定性

