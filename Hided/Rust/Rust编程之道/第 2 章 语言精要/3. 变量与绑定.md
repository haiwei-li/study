
let 关键字创建的变量一般称为**绑定** (`Binding`), 表明**标识符** (`Identifier`) 和**值** (`Value`) 之间的关联.

# 1. 位置表达式和值表达式

表达式一般分为 **位置表达式**(`Place Expression`) 和 **值表达式**(`Value Expression`). 在其他语言中, 一般称为 左值(LValue) 和右值(RValue).

顾名思义, **位置表达式**就是**表示内存位置的表达式**. 可以对某个数据单元的**内存进行读写**. 主要是进行写操作, 这也是位置表达式可以被赋值的原因. 分为几类:

* 本地变量
* 静态变量
* 解引用(`*expr`)
* 数组索引(`expr[expr]`)
* 字段引用(`expr.field`)
* 位置表达式组合

**值表达式**一般**只引用某个存储单元地址中的数据**. 只能**读操作**.

**求值上下文**也分为**位置上下文**(Place Context)和**值上下文**(Value Context).

下面几种表达式属于**位置上下文**:

* 赋值或者复合赋值语句**左侧的操作数**;

* 一元引用表达式的**独立操作数**;

* 包含隐式借用(引用)的操作数;

* match 判别式或 let 绑定右侧在使用 **ref 模式**匹配的时候.

其余表达式都是值上下文. **值表达式不能出现在位置上下文**中. 如下

```rust
pub fn temp() -> i32 {
	return 1;
}

fn main() {
	let x = &temp();
	temp() = *x; // error[E0070]: invalid left-hand side expression
}
```

# 2. 不可变绑定与可变绑定

let 声明的位置表达式默认不可变, 即不可变绑定.

通过 mut 关键字可声明可变的位置表达式, 即可变绑定.

```rust
fn main() {
	let a = 1;
	// a = 2; // immutable and error
	let mut b = 2;
	b = 3; //mutable
}
```

# 3. 所有权与引用

**所有权转移**: **位置表达式出现在值上下文**中, 该位置表达式将**把内存地址转移给另一个位置表达式**.

```rust
1. fn main() {
2.     let place1 = "hello";
3.     let place2 = "hello".to_string();
4.     let other = place1;
5.     println!("{:?}", other);
6.     let other = place2;
7.     println!("{:?}", other);    // Err: other value used here after move
8. }
```

使用 let 声明了两个绑定, place1 和 place2.

第 4 行和第 6 行, **place1** 和 **place2** 是一个**位置表达式**, 出现在了赋值操作符的右侧, 即一个值上下文中, 所以会**将其内存地址转移给 other**.

第 5 行正常, 第 7 行失败. 报错: "该处使用了已经移动的值". 与底层内存安全管理有关, 第 3 章详细解释.

语义上, **每个变量绑定**实际上都**拥有该存储单元的所有权**, 这种**转移内存地址**的行为就是**所有权(OwnerShip)的转移**, Rust 中称为**移动**(Move)语义, 不转移的情况是**复制**(Copy)语义. Rust 没有 GC, 所以完全依赖所有权进行内存管理.

Rust 提供**引用操作符**(`&`), 可以直接获取表达式的**存储单元地址**, 即内存位置.

> &a 或 &mut c, 并没有引起所有权的转移, 只是对a和c**所有权的借用**, a 和 c 还保留它们的所有权, 所以引用也被称为**借用**.

```rust
fn main_2_6() {
	let a = [1,2,3];	// 定义了固定长度数组
	let b = &a;		// 取的 a 的内存地址赋值给 b
	println!("{:p}", b); 	// 0x7ffcbc067704

	let mut c = vec![1,2,3];// 声明了动态长度数组
	let d = &mut c;		// 获取c的可变引用
	d.push(4);
	println!("{:?}", d); 	// [1, 2, 3, 4]
	println!("{:?}", c); 	// [1, 2, 3, 4]
	
	let e = &42;
	assert_eq!(42, *e);	//
}
```

引用操作符 & 取地址赋值, 并**不会引起所有权转移**, 因为 & 已经将**赋值表达式右侧**变成**位置上下文**.

通过 `&mut` 获取 c 的可变引用之前, 必须先声明可变绑定.

字面量 42, 本身属于值表达式. 通过引用操作符, 相当于**值表达式**在**位置上下文**中进行求值, 所以编译器会为 `&42` 创建一个临时值. 类似于如下:

```rust
let mut _0: &i32;
let mut _1: i32;
_1 = const 42i32;
_0 = &_1;
```

最后, 解引用操作符 * 将引用 e 中的值取出来.

