
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 语言规范](#1-语言规范)
  - [1.1. Rust 语言参考](#11-rust-语言参考)
  - [1.2. RFC 文档](#12-rfc-文档)
- [2. 编译器](#2-编译器)
- [3. 核心库](#3-核心库)
- [4. 标准库](#4-标准库)
- [5. 包管理器](#5-包管理器)

<!-- /code_chunk_output -->

Rust 语言主要由几个核心部件组成:

* **语言规范**

* **编译器**

* **核心库**

* **标准库**

* **包管理器**

# 1. 语言规范

Rust 语言规范主要由 Rust **语言参考**(The Rust Reference) 和 **RFC 文档**构成.

## 1.1. Rust 语言参考

Rust 语言参考是官方维护的一份参考文档, 包含三类内容:

* 对每种**语言结构及其用法**的描述

* 对**内存模型**、**并发模型**、**链接**、**调试**等内存的描述

* 影响语言设计的基本原理和参考

## 1.2. RFC 文档

RFC 文档是涵盖了语言特性的**设计意图**、**详细设计**、**优缺点**的完整技术文档.

**RFC 源码**中也规范地使用了 **RFC 编号**来对应**相应的功能特性**. 好处是, 形成了规范化的文档, 利于方案实施和后期维护, 利于核心开发组主导项目进展方向. 可以通过 RFC 深入了解某个语言特性的来龙去脉.

# 2. 编译器

Rust 是一门**静态编译型语言**. Rust 官方**编译器**叫 **rustc**, 负责将 rust 源码编译成可执行文件或其他库文件(.a、.so、.lib、.dll等).

rustc 的特点:

* rustc 是**跨平台**的应用, UNIX/Linux/Windows上都有

* 支持**交叉编译**, 当前平台编译出**可运行于其他平台**上的应用或库

* 使用 **LLVM** 作为**编译器后端**

* rustc 是用 **Rust 语言开发**的, 包含在 Rust 语言源码中

* rustc 对 Rust 源码进行词法语法分析、静态类型检查, 最终将代码翻译为 **LLVM IR**

* 输出的错误信息很友好

# 3. 核心库

Rust 语法由核心库和标准库共同提供. 其中核心库是标准库的基础.

核心库是 Rust 语言的核心, **不依赖于操作系统和网络**等相关的库, 甚至**不知道堆分配**, 也**不提供并发和 I/O**.

# 4. 标准库

Rust 标准库提供应用程序开发所需要的**基础**和**跨平台支持**.

# 5. 包管理器

将按**一定规则组织**的**多个 rs** 文件**编译**后就得到一个**包**(`crate`).

包是 Rust 代码的**基本编译单元**, 也是程序员间**共享代码的基本单元**.

社区的公开**第三方包**都集中在 [crates.io](https://crates.io/) 网站上, 它们的**文档被自动发布**到 [docs.rs](https://docs.rs/) 网站.

Rust 的**包管理器**是 **Cargo**. 类似于 `Ruby` 的 `bundler`, `Python` 的 `pip`, `Node.js` 的 `npm`.

Cargo 既有包管理, 还为 Rust 生态系统提供了**标准的工作流**. Cargo 能管理整个工作流程, 从创建项目、运行单元测试和基准测试, 到构建发布链接库, 再到运行可执行文件等等.

```
// 默认创建一个用于编写可执行二进制文件的项目
$ cargo new bin_crate

// 创建用于编写库的项目
$ cargo new --lib lib_crate

// 编译
$ cargo build

// 运行
$ cargo run

// 测试
$ cargo test

// 构建文档
$ cargo doc

// 发布库到 crates.io
$ cargo publish
```

