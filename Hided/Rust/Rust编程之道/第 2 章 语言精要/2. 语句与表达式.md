
Rust 中的语法可以分为两大类:

* **语句** (`Statement`): 要执行的操作和产生副作用的表达式, (**后面都要加分号**)

* **表达式** (`Expression`): 用于计算求值

**语句**又分为两种:

* **声明语句** (`Declaration statement`): 用于声明各种语言项 (Item), (**以分号结尾**).

* **表达式语句** (`Expression statement`): 特指**以分号结尾的表达式**. 此类**表达式求值结果会被舍弃**, 并**总是返回单元类型 ()**.

```rust
1. //extern crate std;
2. //use std::prelude::v1::*;
3. fn main () {
4. 	pub fn answer () -> () {
5. 		let a = 40;
6. 		let b = 2;
7. 		assert_eq!(sum (a, b), 42);
8. 	}
9. 	pub fn sum (a: i32, b: i32) -> i32 {
10.	 	a + b
11.	}
12.	answer ();
13. }
```

第 1 行和第 2 行是**声明语句**, 引入**标准库**以及 prelude 模块. 注释掉是因为 Rust 为每个 crate 都**自动引入标准库模块**, 除非 `#[no_std]` 属性明确指定不需要标准库.

函数 answer 没有输入参数, 且返回值为 **单元类型()**. 单元类型拥有**唯一的值就是它本身**, 称为**单元值**. 单元类型表示 "没什么特殊的价值". 所以将单元类型作为函数返回值, **表示该函数没有返回值**.

函数 answer 中, **let 声明了两个变量**, 其后**必须加分号**; `assert_eq!` 这种以叹号结尾并且像函数一样被调用的语句, 被叫做 **宏**.

可以将代码去掉换行符, 完全写成一整行, 不影响编译.

Rust 编译器解析代码: 遇到分号, 继续后面执行; 遇到语句, 执行语句; 遇到表达式, 对表达式求值, 如果**分号后面什么都没有**, Rust 编译器会补上单元值 ().

遇到函数, 将函数体的花括号识别为**块表达式** (`Block Expression`). 块表达式由一堆花括号和一系列表达式组成, 它总是返回块中**最后一个表达式的值**. answer 函数最后一个表达式是宏语句, 返回 `单元值 ()`. sum 函数最后一行是一个表达式, 因为没有分号, 直接返回求值结果.

所以, 可以将 Rust 看做 **一切皆表达式**.

* **分号**后面什么都没有自动补`单元值 ()`, 所以可将**语句**看做计算结果为 **单元值()** 的**特殊表达式**;

* 而普通的表达式, 则得到正常的求值结果.