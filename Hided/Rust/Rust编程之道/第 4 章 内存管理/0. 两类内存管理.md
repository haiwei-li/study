
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 分类](#1-分类)
- [2. 手动内存管理](#2-手动内存管理)
- [3. GC 自动内存管理](#3-gc-自动内存管理)
- [4. 现代语言使用现状](#4-现代语言使用现状)
- [5. Rust](#5-rust)

<!-- /code_chunk_output -->

# 1. 分类

不同的编程语言对内存有着不同的管理方式.

按照**内存的管理方式**可将**编程语言**大致分为两类: 

* **手动内存管理类**. 需要**开发者**手动使用 **malloc** 和 **free** 等函数**显式管理内存**, 比如C语言.
* **自动内存管理类**. 使用 **GC**(`Garbage Collection`, **垃圾回收**)来对内存进行自动化管理, 而无须开发者手动开辟和释放内存, 比如 `Java`、`C＃`、`Ruby`、`Python` 等语言都是靠GC自动化管理内存的.

# 2. 手动内存管理

优势在于性能, 因为可以直接操控内存, 但同时也带来不少问题.

* 可能会**忘记释放内存**
* **悬垂指针**(`Dangling Pointer`). 如果某个指针引用的**内存被非法释放**掉了, 而该**指针**却**依旧指向**被释放的内存, 这种情况下的指针就叫悬垂指针.

# 3. GC 自动内存管理

GC 自动内存管理接管了开发者**分配和回收内存**的任务, 并帮助提升了**代码的抽象度和可靠性**. 像悬垂指针之类的问题完全可以避免, 因为一个被引用的对象的内存永远不会被释放, 只有当它**不被引用时才可被回收**. GC 使用了各种精确的算法来解决**内存分配和回收**的问题, 但并不代表能解决所有的问题.

GC **最大的问题**是会引起"**世界暂停**", GC 在工作的时候必须保证程序不会引入新的"垃圾", 所以要使运行中的程序暂停, 这就造成了性能问题.

# 4. 现代语言使用现状

所以, 编程语言的使用现状就是, **对性能要求高**并且需要**对内存进行精确操控**的**系统级开发**, 一般只能选择 C 和 `C++` 之类的语言, 存在的问题是, 如果开发者稍不留神就会造成**内存不安全**问题.

其他类型的开发就选择 Java、Python、Ruby 之类的高级语言, 一般不会出现内存不安全的问题, 但是它们的性能却降低了不少.

# 5. Rust

Rust 就是想将两者优势结合起来, 做到**既无GC**又可以**安全地进行手动内存管理**, 还不缺**更高的抽象**, 可以像其他高级语言那般进行**快速开发**.

作为一门强大的**系统编程语言**, Rust允许开发者**直接操控内存**, 所以了解内存如何工作对于编写出高效的Rust代码至关重要.