
虽然当前的trait系统很强大, 但依然有很多需要改进的地方, 主要包括以下三点:

* 孤儿规则的局限性
* 代码复用的效率不高
* 抽象表达能力有待改进

# 孤儿规则的局限性

在设计 trait 时, 还需要考虑**是否会影响下游的使用者**. 

比如在标准库实现一些trait时, 还需要考虑**是否**需要为**所有**的 **T** 或 `&'a T` **实现该 trait**:

```rust
impl<T: Foo> Bar_3_73 for T { }
impl<'a, T: Bar_3_73> Bar_3_73 for &'a T { }
```

对于下游的子 crate, 要**避免孤儿规则**, **必须**使用 **NewType** 模式或其他方式**将远程类型包装成本地类型**.

另外, 对于**一些本地类型**, 如果将其**放到一些容器**中, 比如 `Rc＜T＞` 或 `Option＜T＞`, 那么这些**本地类型**就会变成**远程类型**(如下代码), 因为**这些容器类型**都是在**标准库**中定义的, 而**非本地**. 

`Option<T>` 会**将本地类型变成远程类型**:

```rust
//use std::ops::Add;
#[derive(PartialEq)]
struct Int3_74(i32);
impl Add<i32> for Int3_74 {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
// impl Add<i32> for Option<Int3_74> {
//     // TODO
// }
impl Add<i32> for Box<Int3_74> {
    type Output = i32;
    fn add(self, other: i32) -> Self::Output {
	(self.0) + other
    }
}
fn main_3_74() {
	assert_eq!(Int3_74(3) + 3, 6);
	assert_eq!(Box::new(Int3_74(3)) + 3, 6);
}
```

在**本地**创建了**自定义类型 Int**, 然后为其**实现 Add trait**. Add trait 是定义于**标准库**中的, Int是在本地的, 所以并**不违反孤儿规则**. 

但是当给 `Option＜Int＞` 实现 Add 时, 编译器就会报错, 因为**触发了孤儿规则**. 

但是当给 `Box＜Int＞` 实现 Add 时, 则可以**正常编译执行**. 看到这里是不是有些困惑?

这是因为`Box＜T＞`在Rust中属于**最常用的类型**, 经常会遇到像上面代码的情况: 从子 crate 为 `Box＜Int＞` 这种自定义类型扩展 trait 实现. 标准库中根本做不到覆盖所有的 crate 中的各种可能性, 所以必须将 `Box＜T＞` 开放出来, **脱离孤儿规则的限制**, 否则就会**限制子 crate** 要实现的一些功能. 

那么, `Box＜T＞`是怎么做到如此特殊的呢?这其实是因为 Rust内部使用了一个叫 `#[fundamental]` 的**属性标识**, Box＜T＞的实现源码如下. 

```rust
#[fundamental]
pub struct Box<T: ?Sized>(Unique<T>);
```

该属性的作用就是告诉编译器, `Box＜T＞`享有"特权", **不必遵循孤儿规则**. 

还有Fn、FnMut、FnOnce、Sized等都加上了`#[fundamental]`属性, 代表这些trait也同样不受孤儿规则的限制. 所以, 在阅读Rust源码的时候, 如果看到**该属性标识**, 就应该知道它和孤儿规则有关. 

# 代码复用的效率不高

除了孤儿规则, Rust 其实还遵循另外一条规则: **重叠**(Overlap)**规则**. 该规则规定了**不能为重叠的类型实现同一个 trait**. 

什么叫重叠的类型?如代码

```rust
impl<T> AnyTrait for T {...}
impl<T> AnyTrait for T where T: Copy {...}
impl<T> AnyTrait for i32 {...}
```

分别为三种类型实现了AnyTrait. 

* `T` 是**泛型**, 指代**所有的类型**. 
* `T where T: Copy` 是**受 trait 限定约束**的**泛型 T**, 指代**实现了 Copy trait 的类型 T**, 是**所有类型的子集**. 
* i32 是一个**具体的类型**. 

显而易见, 上面三种类型发生了**重叠**. T **包含**了 `T: Copy`, 而 `T: Copy` **包含**了 **i32**. 这**违反了重叠规则**, 所以编译会失败. 这种实现 trait 的方式在 Rust 中叫**覆盖式实现**(`Blanket Impl`). 

重叠规则和孤儿规则一样, 都是为了**保证 trait 一致性**, 避免发生混乱, 但是它也带来了一些问题, 主要包括以下两个方面:

* **性能问题**
* **代码很难重用**

性能会有什么问题呢?且看一个示例:

```rust
impl<R, T: Add<R> + Clone> AddAssign<R> for T {
	fn add_assign(&mut self, rhs: R) {
	    let tmp = self.clone() + rhs;
	    *self = tmp;
	}
}
```

为**所有类型 T 实现了 AddAssign**, 该 trait 定义的 `add_assign` 方法是 `+=` 赋值操作对应的方法. 这样实现虽然好, 但是会带来性能问题, 因为会**强制所有类型都使用 clone 方法**, clone 方法会有一定的成本开销, 但实际上有的类型并不需要 clone. 因为有重叠规则的限制, **不能**为某些**不需要 clone 的具体类型重新实现** add_assign 方法. 所以, 在标准库中, 为了实现**更好的性能**, 只好为**每个具体的类型**都**各自实现一遍 AddAssign**. 

从上面可以看出来, **重叠规则严重影响了代码的复用**. 试想一下, 如果没有重叠规则, 则可以默认使用上面对泛型 T 的实现, 然后对不需要 clone 的类型重新实现AddAssign, 那么就完全没必要为每个具体类型都实现一遍add_assign方法, 可以省掉很多重复代码. 当然, 此处只是为了说明重叠规则的问题, 实际上在标准库中会使用宏来简化具体的实现代码. 

那么为了缓解重叠规则带来的问题, Rust 引入了特化(Specialization). 特化功能暂时只能用于impl实现, 所以也称为impl特化. 不过该功能目前还未稳定发布, 只能在Nightly版本的Rust之下使用 `＃！[feature(specialization)]` 特性. 

trait包含默认实现的特化示例如代码清单3-78所示. 

```rust

```

在代码清单 3-78 中, 定义了一个泛型结构体 Diver＜T＞, 以及一个携带默认实现的Swimmer trait. 然后为Diver＜T＞实现了该trait, 如第10行所示. 

代码第11行到第15行为Diver＜& 'static str＞实现了Swimmer. 

然后在main函数中分别调用Diver: : ＜& 'static str＞和Diver: : ＜String＞类型的swim方法, 输出不同的结果. 

看得出来, 特化功能有点类似面向对象语言中的继承, Diver: : ＜String＞"继承"了Diver: : ＜T＞中的实现. 而Diver: : ＜& 'static str＞则使用了本身的swim方法实现. 

代码清单3-78展示了trait默认实现的情况. 如果trait没有默认实现, 特化功能的写法就会稍微有点区别, 如代码清单3-79所示. 

代码清单3-79: trait没有默认实现的特化示例

```rust

```

代码清单3-79是对代码清单3-78进行的修改. 将原本Swimmer中的默认实现去掉, 然后在为Diver＜T＞实现Swimmer的时候编写具体的swim实现. 请注意这里多了一个default关键字. 代码清单3-78中其余的代码保持不变. 

如果不加 default, 编译会报错. 这是因为默认 impl 块中的方法不可被特化, 必须使用default关键字来标记那个需要被特化的方法, 这是出于代码的兼容性考虑的. 同时, 通过显式地使用default标记, 也增强了代码的维护性和可读性. 

目前特化的功能还在不断地演进和完善, 在不远的将来会稳定发布. 到时候Rust代码的性能和重用性将会显著提高, 而且在特化的支持下, 还可能会实现高效的继承方案. 让我们拭目以待. 

# 抽象表达能力有待改进

迭代器在Rust中应用广泛, 但是它目前有一个缺陷: 在**迭代元素**的时候, **只能按值进行迭代**, 有的时候必须**重新分配数据**, 而**不能通过引用来复用原始的数据**. 比如标准库中的std: : io: : Lines 类型用于按行读取文件数据, 但是该实现迭代器只能读一行数据分配一个新的String, 而不能重用内部缓存区. 这样就影响了性能. 这里提到的迭代器相关的内容会在第6章进行详细介绍. 

这是因为迭代器的实现基于关联类型, 而关联类型目前只能支持具体的类型, 而不能支持泛型. 不能支持泛型就导致无法支持引用类型, 因为Rust里规定使用引用类型必须标明生命周期参数, 而生命周期参数恰恰是一种泛型类型参数. 

为了解决这个问题, 就必须允许迭代器支持引用类型. 只有支持引用类型, 才可以重用内部缓存区, 而不需要重新分配新的内存. 所以, 就必须实现一种更高级别的类型多态性, 即泛型关联类型(Generic Associated Type, GAT)[3], 如代码清单3-80所示. 

```

```


我们在代码清单 3-80 中定义了一种迭代器StreamingIterator, 它的特点是包含了泛型关联类型, 这里Item＜ 'a＞中的 'a 就是一种泛型类型参数, 叫作生命周期参数, 表示这里可以使用引用. 

这样一来, 如果给std: : io: : Lines实现了StreamingIterator迭代器, 它就可以复用内存缓存区, 而不需要为每行数据新开辟一份内存, 因而提升了性能. 

Item＜ 'a＞是一种类型构造器. 就像Vec＜T＞类型, 只有在为其指定具体的类型之后才算一个真正的类型, 比如Vec＜i32＞. 所以, GAT也被称为ACT(Associated typeconstructor), 即关联类型构造器. 

但遗憾的是, 目前 GAT 功能还在紧张地实现中, 还不能使用. 在不久的将来, GAT 稳定功能会被发布, 到时候将进一步提升Rust类型系统的抽象能力. 