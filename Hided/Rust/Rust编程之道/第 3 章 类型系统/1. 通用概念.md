
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 类型系统的引入](#1-类型系统的引入)
- [2. 类型系统的作用](#2-类型系统的作用)
- [3. 类型系统的分类](#3-类型系统的分类)
- [4. 类型系统和多态性](#4-类型系统和多态性)
  - [4.1. 多态分类](#41-多态分类)
  - [4.2. 参数化多态](#42-参数化多态)
  - [4.3. Ad-hoc 多态](#43-ad-hoc-多态)
  - [4.4. 子类型多态](#44-子类型多态)

<!-- /code_chunk_output -->

# 1. 类型系统的引入

所谓**类型**, 其实就是对表示信息的值进行的细粒度的区分. **不同的类型占用的内存不同**. 创建一个 u32 类型的值, Rust 会自动分配 4 个字节来存储.

计算机不只是用来存储信息的, 它还需要处理信息. 这就必然会面临一个问题: **不同的类型该如何计算**?因此需要对这些基本的类型定义一系列的组合、运算、转换等方法. **类型之间的纷繁复杂的交互形成了类型系统**, 类型系统是编程语言的基础和核心, 因为编程语言的目的就是存储和处理信息. 不同编程语言之间的区别就在于如何存储和处理信息.

在计算机科学中, **对信息的存储和处理**不止**类型系统**这一种方式, 还有其他的一些理论框架, 只不过类型系统是最轻量、最完善的一种方式. 

**在类型系统中, 一切皆类型. 基于类型定义的一系列组合、运算和转换等方法, 可以看作类型的行为**. 类型的行为决定了类型该如何计算, 同时也是一种约束, 有了这种约束才可以保证信息被正确处理.

# 2. 类型系统的作用

* 排查错误. 很多编程语言都会在**编译期**或**运行期**进行**类型检查**, 以排查违规行为, 保证程序正确执行.
* 抽象. 类型允许开发者在更高层面进行思考, 这种抽象能力有助于**强化编程规范**和**工程化系统**. 比如, 面向对象语言中的类就可以作为一种类型. 
* 文档. 在阅读代码的时候, 明确的类型声明可以表明程序的行为.
* 优化效率. 这一点是针对**静态编译语言**来说的, 在编译期可以通过类型检查来**优化一些操作**, 节省运行时的时间. 
* 类型安全.
  * 可以避免类型间的无效计算. 比如 `3/"hello"`
  * 可以保证内存安全. 避免诸如空指针、悬垂指针和缓存区溢出等导致的内存安全问题
  * 可以避免语义上的逻辑错误. 比如以毫米为单位的数值和以厘米为单位的数值虽然都是以整数来存储的, 但可以用不同的类型来区分, 避免逻辑错误

# 3. 类型系统的分类

* 在**编译期**进行**类型检查**的语言属于**静态类型**;
* 在**运行期**进行**类型检查**的语言属于**动态类型**.

如果一门语言不允许**类型的自动隐式转换**, 在强制转换前不同类型无法进行计算, 则该语言属于**强类型**, 反之则属于**弱类型**.

**静态类型的语言**能在编译期对代码进行静态分析, 依靠的就是类型系统. 以数组越界访问为例. 有些静态语言, 如 C 和 C++, 在编译期并不检查数组是否越界访问, 运行时可能会**越界而程序依旧正常运行**, 这属于类型系统中未定义的行为, 所以它们**不是类型安全的语言**. Rust语言在编译期就能检查出数组是否越界访问, 并给出警告, 如果没有修改, 在运行时也会抛出错误并退出, 从而保证运行时的内存安全, 所以 Rust 是类型安全的语言. 强大的类型系统也可以对类型进行**自动推导**, 因此一些静态语言在编写代码的时候不用显式地指定具体的类型, 比如 **Haskell** 就被称为**隐式静态类型**. Rust 语言的类型系统受Haskell启发, 也可以自动推导, 但不如Haskell强大. 在Rust中大部分地方还是需要**显式地指定类型**的, 类型是Rust语法的一部分, 因此 **Rust** 属于**显式静态类型**. 

**动态类型的语言**只能在**运行时**进行类型检查, 但是当有数组越界访问时, 就会**抛出异常**, 执行**线程退出**操作, 而不是给出奇怪的结果. 所以一些动态语言也是**类型安全**的, 比如Ruby和Python语言. ......

# 4. 类型系统和多态性

如果**一个类型系统**允许**一段代码**在**不同的上下文**中具有**不同的类型**, 这样的类型系统就叫作**多态类型系统**. 对于静态类型的语言来说, 多态性的好处是可以在不影响类型丰富的前提下, **为不同的类型编写通用的代码**. 

## 4.1. 多态分类

现代编程语言包含了三种多态形式: 
* **参数化多态**(`Parametric polymorphism`)
* **Ad-hoc 多态**(`Ad-hoc polymorphism`)
* **子类型多态**(`Subtype polymorphism`)

如果按**多态发生的时间**来划分, 又可分为:

* **静多态**(`Static Polymorphism`), 发生在**编译期**. **参数化多态**和 **Ad-hoc 多态**一般是静多态;
* **动多态**(`Dynamic Polymorphism`), 发生在**运行时**. **子类型多态**一般是**动多态**.

静多态牺牲灵活性获取性能, 动多态牺牲性能获取灵活性. 动多态在运行时需要查表, 占用较多空间, 所以一般情况下都使用静多态.

Rust语言同时支持静多态和动多态, **静多态**就是一种**零成本抽象**. 

## 4.2. 参数化多态

**参数化多态**实际就是指**泛型**.

很多时候**函数**或**数据类型**都需要适用于**多种类型**, 以避免大量的重复性工作.

泛型使得语言极具表达力, 同时也能保证静态类型安全. 

## 4.3. Ad-hoc 多态

**Ad-hoc 多态也叫特定多态**. Ad-hoc 短语源自拉丁语系, 用于表示**一种特定情况**.

Ad-hoc 多态是指**同一种行为定义**, 在**不同的上下文**中会响应**不同的行为实现**. 

Haskell 语言中使用 Typeclass 来支持 Ad-hoc 多态, Rust 受 Haskell 启发, 使用 **trait** 来支持 Ad-hoc 多态.

## 4.4. 子类型多态

**子类型多态**的概念一般用在面向对象语言中, 尤其是Java语言. Java语言中的多态就是子类型多态, 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有时也可以看作父类型的值, 反之则不然. 而 Rust 语言中并**没有**类似Java 中的**继承**的概念, 所以也不存在子类型多态. 

所以, Rust 中的类型系统目前只支持**参数化多态**和**Ad-hoc多态**, 也就是, **泛型**和**trait**. 