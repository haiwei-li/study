
假设需要写一个函数, 用于修改数组的第一个元素. 基本思路可以是, 将此数组直接当作函数的参数传入, 修改之后再返回, 如代码清单5-20所示. 

代码清单5-20: 将数组作为函数参数传递

[插图]

在代码清单5-20中, 因为数组类型签名为[T; N], 所以foo函数中参数v的类型直接指定为[i32; 3], 代表长度为3的i32整数数组, 并使用mut关键字将其指定为可变. 在foo函数中, 直接使用数组下标0来修改第一个元素的值, 然后返回此数组. 

在main函数中, 第7行代码声明了一个不可变数组v, 然后将其传入foo函数中. 因为数组v的元素均为基本数字类型, 所以v是复制语义, 在传入foo函数时会按位复制. 所以, 在foo函数中修改后的v是[3, 2, 3], 而main函数中的v是[1, 2, 3](代码第9行). 

这里还需要注意的地方是, 第7行代码声明的数组v是不可变的, 但是传入了foo函数中就变成了可变数组, 主要原因是函数参数签名也支持模式匹配, 相当于使用let 将 v 重新声明成了可变绑定. 

所以, 如果想使用foo函数返回的修改后的数组, 则需要将其重新绑定方可继续使用. 这是所有权系统带来的不便之处. 其实大多数情况下可以使用Rust提供的引用来处理这种情况, 如代码清单5-21所示. 

代码清单5-21: 使用引用作为函数参数
