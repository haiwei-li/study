
内存管理不外如是. **栈内存**的生命周期是**短暂**的, 会随着**栈展开**(常见的是函数调用)的过程而**被自动清理**. 而**堆内存**是**动态**的, 其分配和重新分配并**不遵循**某个**固定的模式**, 所以需要使用**指针**来对其进行**跟踪**. 

Rust受现代C++的启发, 同样引入了**智能指针**来管理**堆内存**. **智能指针**在**堆**上**开辟内存空间**, 并拥有其**所有权**, 通过存储于**栈中的指针**来**管理堆内存**. 

**智能指针**的 **RAII** 机制利用栈的特点, 在**栈元素被自动清空时自动调用析构函数**, 来**释放**智能指针所管理的**堆内存空间**. 

现代 C++ 的RAII机制解决了无GC自动管理内存的基本问题, 但并没有解决全部问题, 还存在着很多安全隐患.

```cpp
#include <iostream>
#include <memory>
using namespace std;
int main()
{
	unique_ptr<int>
}
```

