# identifier
## 保留的标示符类型
除了关键字之外, 还有几类标示符有特殊的含义. 这些标示符类型使用以
下划线开头和结尾的模式: 
```
1. _*: 这种标示符不会被 from module import * 
导入. 在交互式解释器中, 它被用来保存最后一次求值的结果. 它被保存
在__builtin__模块中. 当处于非交互式模式时, 名称"_"并无特殊含义, 
也未被定义. 注意, "_"经常与国际化一起使用. 
2. __*__: 系统定义的名称. 这些名称由解释器及其实现(包括标准库)
定义. 在任何上下文中对此类名称的任何使用, 如果没有伴随显示的文档
记录, 就很容易在没有任何警告的情况下遭到破坏. 
3. __*: 类的私有名称. 这种类别的名称, 当用在 类定义的 
上下文中(within the context of a class 
definition)时, 会被重写以使用一个改编的形式(a mangled 
form)帮助避免基类和派生类私有属性间的命名冲突. 
```
## 私有名称的改编(Private name mangling)
GerryLee     文件    发布       
    
identifier

保留的标示符类型

除了关键字之外, 还有几类标示符有特殊的含义. 这些标示符类型使用以下划线开头和结尾的模式: 

1. _*: 这种标示符不会被 from module import * 导入. 在交互式解释器中, 它被用来保存最后一次求值的结果. 它被保存在__builtin__模块中. 当处于非交互式模式时, 名称"_"并无特殊含义, 也未被定义. 注意, "_"经常与国际化一起使用. 
2. __*__: 系统定义的名称. 这些名称由解释器及其实现(包括标准库)定义. 在任何上下文中对此类名称的任何使用, 如果没有伴随显示的文档记录, 就很容易在没有任何警告的情况下遭到破坏. 
3. __*: 类的私有名称. 这种类别的名称, 当用在 类定义的 上下文中(within the context of a class definition)时, 会被重写以使用一个改编的形式(a mangled form)帮助避免基类和派生类私有属性间的命名冲突. 
私有名称的改编(Private name mangling)

在类定义中, 如果一个标示符以两个或多个下划线开头, 且不以两个或多个下划线结尾, 它就被认为是该类的私有名称. 在为私有名称生成代码之前, 它们被转换为更长的形式. 转换过程为在私有名称前加上类名, 再开头加上前缀字符"_". 例如, 类Ham中有一个私有名称__spam, 它将会被转换为_Ham__spam. 如果转换后的名称极其长(超过了255个字符), 截断可能会发生. 如果类名仅由下划线组成, 就不会发生转换. 

@GerryLee 2017-03-02 19:56 字数 阅读 0